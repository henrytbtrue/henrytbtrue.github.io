<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>题解 CF506D Mr. Kitayuta&#39;s Colorful Graph</title>
    <url>/2020/07/%E9%A2%98%E8%A7%A3-CF506D-Mr-Kitayuta-s-Colorful-Graph/</url>
    <content><![CDATA[<p>神仙题。</p>
<p>暴力+暴力=AC。</p>
<p>没错，先想出两个暴力，然后拼起来，你就 AC 了这道题。</p>
<p><strong>用分块来选择用哪个暴力，可能也是一种正解的做法。</strong></p>
<a id="more"></a>
<p>首先我们能想到最无脑的暴力 1 。</p>
<h2 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力 1"></a>暴力 1</h2><p>对于每种颜色建一个仅含有这一种颜色的边的图，然后用并查集判连通，扫一次所有询问统计贡献。</p>
<p>时间复杂度：首先 $\operatorname{O}(m)$ 的枚举颜色，然后 $\operatorname{O}(n\alpha(n))$ 的建图+并查集（其实建图可以不用，直接并查集就够了），再加上 $\operatorname{O}(q\alpha(n))$ 的处理询问。总时间复杂度 $\operatorname{O}(m\alpha(n)(n+q))$ 。</p>
<p>这显然是过不了这道题的，那么我们再来想另一个暴力。</p>
<h2 id="暴力-2"><a href="#暴力-2" class="headerlink" title="暴力 2"></a>暴力 2</h2><p>其实只是对暴力 1 的一点修改。</p>
<p>对于每种颜色建一个仅含有这一种颜色的边的图，然后用并查集判连通，在每个连通块内枚举所有的点对 $(u,v)$ ，更新 $(u,v)$ 这个点对的贡献。</p>
<p>这个东西在连通块很小（连通块大小的平方小于 $q$ ）的时候会比暴力 1 更优一些。</p>
<p>时间复杂度：首先 $\operatorname{O}(m)$ 的枚举颜色，然后 $\operatorname{O}(n\alpha(n))$ 的建图+并查集（其实建图可以不用，直接并查集就够了），然后 $\operatorname{O}(n^2\alpha(n))$ 的算贡献。总时间复杂度 $\operatorname{O}(mn^2\alpha(n))$。</p>
<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>那么，我们就想到：可不可以在连通块大小的平方小于 $q$ 的时候用暴力 2 ，而在连通块大小的平方大于 $q$ 的时候再用暴力 1 呢？</p>
<p>当然可以。</p>
<p>什么时候一个颜色的图中每个连通块大小的平方都小于 $q$ ？</p>
<p>在 该颜色边数 $&lt;\sqrt{m}$ 的时候，所有这种颜色的所有连通块内点数的平方和不会超过 $n\sqrt n$ 。</p>
<p>于是，暴力 2 就可以胜任这部分的任务，复杂度 $\operatorname{O}(n\alpha(n)\sqrt n)$。</p>
<p>在 该颜色边数 $\ge\sqrt{m}$ 的时候，我们就可以用暴力 1 ，因为此时满足这种情况的颜色数量只会 $\le\sqrt m$。这样的话再扫一遍所有询问，复杂度是 $\operatorname{O}(\sqrt m(q\alpha(q)))$ 的。</p>
<p>这样，两个暴力拼起来，就打出了正解。</p>
<p>考虑实现统计答案时用 <code>map</code> 统计，复杂度应乘上 $\operatorname{O}(\log q)$。所以，总复杂度为：$\operatorname{O}((n\alpha(n)\sqrt n+\sqrt m(q\alpha(q)))\log q)$ 。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; e[N],qs;</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; ans,lst;</span><br><span class="line"><span class="keyword">int</span> f[N],sz[N],qto[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]==i?i:f[i]=find(f[i]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u=find(u);v=find(v);</span><br><span class="line">    <span class="keyword">if</span>(u!=v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sz[u]&gt;sz[v]) &#123;</span><br><span class="line">            f[v]=u;</span><br><span class="line">            sz[u]+=sz[v];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[u]=v;</span><br><span class="line">            sz[v]+=sz[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bao1</span><span class="params">(<span class="keyword">int</span> co)</span> </span>&#123;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) f[i]=i,sz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=e[co].begin();ii!=e[co].end();++ii) &#123;</span><br><span class="line">        merge(ii-&gt;first,ii-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=qs.begin();ii!=qs.end();++ii) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=ii-&gt;first,v=ii-&gt;second;</span><br><span class="line">        u=find(u),v=find(v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) &#123;</span><br><span class="line">            ++ans[make_pair(ii-&gt;first,ii-&gt;second)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bao2</span><span class="params">(<span class="keyword">int</span> co)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ps[N],tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=e[co].begin();ii!=e[co].end();++ii) &#123;</span><br><span class="line">        ps[++tot]=ii-&gt;first;</span><br><span class="line">        ps[++tot]=ii-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ps+<span class="number">1</span>,ps+tot+<span class="number">1</span>);</span><br><span class="line">    tot=unique(ps+<span class="number">1</span>,ps+tot+<span class="number">1</span>)-ps<span class="number">-1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,tot) f[ps[i]]=ps[i],sz[ps[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=e[co].begin();ii!=e[co].end();++ii) &#123;</span><br><span class="line">        merge(ii-&gt;first,ii-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,tot) &#123;</span><br><span class="line">        rep(j,i+<span class="number">1</span>,tot) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> u=find(ps[i]),v=find(ps[j]);</span><br><span class="line">            <span class="keyword">if</span>(u==v) flg=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(flg&amp;&amp;ans.count(make_pair(ps[i],ps[j]))) &#123;</span><br><span class="line">                ans[make_pair(ps[i],ps[j])]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;c);</span><br><span class="line">        num[c]++;e[c].push_back(make_pair(min(u,v),max(u,v)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,q) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(!ans.count(make_pair(min(u,v),max(u,v)))) &#123;</span><br><span class="line">            qs.push_back(make_pair(min(u,v),max(u,v)));</span><br><span class="line">            ++now;</span><br><span class="line">            lst[make_pair(min(u,v),max(u,v))]=now;</span><br><span class="line">            qto[i]=now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> qto[i]=lst[make_pair(min(u,v),max(u,v))];</span><br><span class="line">        ans[make_pair(min(u,v),max(u,v))]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&gt;=<span class="built_in">sqrt</span>(m)) &#123;</span><br><span class="line">                bao1(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> bao2(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,q) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=qs[qto[i]<span class="number">-1</span>].first,v=qs[qto[i]<span class="number">-1</span>].second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[make_pair(u,v)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年 7 月水题选做</title>
    <url>/2020/07/7%E6%9C%88%E6%B0%B4%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<h1 id="7-20"><a href="#7-20" class="headerlink" title="7/20"></a>7/20</h1><p>这个东西是为了膜 <a href="https://registergen.github.io" target="_blank" rel="noopener">RegisterGen神仙</a> 而发出来的。</p>
<a id="more"></a>
<p><a href="https://www.luogu.com.cn/problem/CF506D" target="_blank" rel="noopener">$\color{green}{\text{CF506D}}$</a></p>
<p>神仙题。</p>
<p>暴力+暴力=AC。</p>
<p>没错，先想出两个暴力，然后拼起来，你就 AC 了这道题。</p>
<p>详细见<a href="/2020/07/题解-CF506D-Mr-Kitayuta-s-Colorful-Graph">我的题解</a>。</p>
<h1 id="7-21"><a href="#7-21" class="headerlink" title="7/21"></a>7/21</h1><p>今天打了场 div2 的 CF 。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1382A" target="_blank" rel="noopener">$\color{green}{\text{CF1382A}}$</a></p>
<p>sb 题。找一下两个数组有没有相同的数，完事。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1382B" target="_blank" rel="noopener">$\color{green}{\text{CF1382B}}$</a></p>
<p>仔细想想，发现所有 $\ge 2$ 的数都可以换成 $2$ 。</p>
<p>再想想，对于一个 $2$ ，先取到它的人可以调整先后手顺序。</p>
<p>那么，拿到第一个 $2$ 的人就可以调整顺序，使得他拿到第二个 $2$ ，以此类推。</p>
<p>这样，拿到第一个 $2$ 的人就把调整顺序的主动权牢牢控制在了他手中。所以拿到第一个 $2$ 的人有必胜策略。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1381A1" target="_blank" rel="noopener">$\color{green}{\text{CF1382C1}}$</a> 和 <a href="https://www.luogu.com.cn/problem/CF1381A2" target="_blank" rel="noopener">$\color{green}{\text{CF1382C2}}$</a></p>
<p>这题没让我们最小化操作次数啥的，只用求出一个可行解就完事了。</p>
<p>那么我们就可以随便乱搞了。</p>
<p>想想有什么状态是这两个 $01$ 串都能达到的？而且很好写的？</p>
<p>当然是 $111\cdots1$ 啦！</p>
<p>那么我们就可以处理一下第一个串到 $111\cdots1$ 的操作、第二个串到 $111\cdots1$ 的操作，然后拼起来，完事。</p>
<p>处理这个操作怎么 $\operatorname{O}(n)$ 呢？</p>
<p>我们可以预处理这两个串的极大全 $0$ 子串，然后随便做就完事了。</p>
<h1 id="7-21-1"><a href="#7-21-1" class="headerlink" title="7/21"></a>7/21</h1><p>全天有课且无 CF ，咕咕。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>luogu</tag>
        <tag>题解</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>ZR2020春季NOIP模拟赛day4总结</title>
    <url>/2020/03/ZR2020%E6%98%A5%E5%AD%A3NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9Bday4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="be840ca8ecf2dcfa0e2f67641f8663d5c0849e1c3742c55f562b159bce9c50c0">a3e4f48b81db38135a5ff9adeee672dc202c767c025bac6bbf465deff10e4a8711aba74008397e266eef2d9b9ad75dffc952d6a6ee1fd944640ed39c6b4a68a1ffda5062de1fc206cd29cd43cf4dfd6b6e3ee40877de9ae01ff67da8df5b4824d82748e780c8fddec3a122f2762102b81e87c81ca924e1cb6b108f592e9699bc4122943dbc65a40f23c32bbd03589041ad739988590fd12859ff59d005d0cbc9f3b221b50818ba123dc671a33d525195dd895e753415fbebd3142e7fc538f9da0d34311041bef5e43b86af0bd02f0f61b7d0418d3cefbd745766a0ebf3f16ae153a4cf059f2cacb713332fb816288c30056a9b9328b5c956207e9a2ebd3399b9b6dab0408d56134fe53a683c2c2eed92421b7fd122b5130544ec4287ed361adf9060f90da227dc29bc5f8146e04d2613fb4a2c05e8134f25740a69ae8d085e9811827da3d57f56707bd7cbecd17e642e7515950cbbe02a42a013c4ba2c2c41fd99e8f9e31fcaa711c2008875c5d4eaf86c53838533fe89940d82532b64f4ddf772e6cfc516e217006f5602f53372b8cbd053558eb2a2438dbf41229acda4f786f40cfb2d4f8efd3ced4fa4be7351765db085a4851d8332d676b4ce2fe7f0da9ee39b3e030a34207745ce2e671496095bc1a5f45d016abf82ebf86dcc5efc98034a4d7f595d9f02c5e9b50f9390befa34bde926a5da188eeed4fbea6f6681de16a3bcaf4a4d5a7577d59021e834ae8d2edd7d63dddeca164cb7d8b1d713bde58f85761542ebb67bc59d50c75aeb4dd6eaeda109e1b572c2e4c8ce5f19e6c4afa16055e6bfae6bd3820252ee82759ca27c9e81d8ebc47e26af506bf81970c0f84e2c42e04dbca48ebc440c3e0018e0b645a5e4baa9ea35f6db14f7c17d1e853c67e3b2b535e638a397cbaf88b60ea7491a514a719c4ce2c657bba17318b8032c4436202b0dff199e227ecbc262937a4b263e6476c314fc3d90ab5ddd102a70085bad6dd2f5b7708e3811735843db8f101486c5440e695886f721a6537aa859fbebd81c948dc96d4736b858f1c58c984617a215a40e35c1a7a04d7813cb262d2684b1bae2c90de8b93e6a613e2a18c3eac871eb5e4fadea7a5429130513cf6d040d70f7e827515f1530211cfdea596418bec1312091b368e9855696fa7f727dc098f94128979a42a5ffe6d9550eb0845412b3ce688b68654c2f3f5a0981af6524f02bb4e305a96065fe45f3b4cff493a0d4000a2e6297bd776889bcdd40ea4c433edc841319f32fd4f65338af9b1674ee1aa5cd6cb9fa2415ed638d1f16d30507895f209685d455dff24a71f25e4db51cf0f3b73505329cff27b79262825183e5dc6552fbce43d78caeee91f4ff8c450da190028c4aeccc7e6671924fa27f3b0d8edf557958c95a647f3d72b118c2a5c896e420573fe584e695f1c8ac93cc17724b2aa86e5cda98fd0360c0549e43b58abac21318e48f04c28563acc27349dcdb5ce89a3dc873569ff4074e168f05f27465b8d17429840893f0f23b001ffff6a8160cba2dd875ce1f79e7a8819db6606cde337f7e041b353851131ea9949f31c74851d5d224f414c27fc9fc6c4a6db3b29477c36e7d83b6d89d65070f7fd6259ac114a26a6c003aefec35282283ff86d8d0b761a06e8182a7df12f43ec6fee2164b885f1b009ce72aef4736ab52d74d8e550fd4a4fb1a2c0371486aaf11d17fb283f140d4607002bb22dfa74e4879aa894fd763a293d803cb78f4bd50a89b5770fe16648a04cd8f15588ffbdf2f9c84fa15f0dd390526d0a0477a9d835db47bab61e643b02a372b440717cb99d91f002503717e7283c97d89d5b669467aa5ec2511ee8d96945fd3ba3dde9c70e5becc5ee1</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LuoguP1600 [NOIP2016]天天爱跑步</title>
    <url>/2020/03/%E9%A2%98%E8%A7%A3-LuoguP1600-NOIP2016-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1600" target="_blank" rel="noopener">题目传送门</a></p>
<h1 id="前置知识：树上差分"><a href="#前置知识：树上差分" class="headerlink" title="前置知识：树上差分"></a>前置知识：树上差分</h1><p>各位大佬们肯定知道在数组上差分是什么吧：差分数组中的值是原数组中这个位置与它左边（或右边，写法无所谓）位置的差。这个方法可以把“区间加”转化为“左端点加，右端点减”。</p>
<a id="more"></a>
<p>然后对于一个位置，它的值就是差分数组中的前缀和。</p>
<p>例如：一个数组 $[1,0,2,5,3]$。</p>
<p>它的差分数组就是 $[1,-1,2,3,-2]$ 。</p>
<p>在区间 $[2,4]$ 上 $+1$ ，就等价于在差分数组中下标为 $2$ 的地方 $+1$ ，下标为 $5$ 的地方 $-1$ 。差分数组变为 $[1,0,2,3,-3]$。</p>
<p>此时求原数组下标为 $4$ 的地方就是求差分数组的下标范围 $[1,4]$ 的和，为 $6$ 。</p>
<p>类似地，我们可以把差分这个算法转化到树上。</p>
<p>设差分数组为 $b$ ，对于树上的一个路径加 $1$ ，例如 $u\to v$ 这条路径上面所有点的权值 $+1$ ，我们可以把它转化成 $b[u]$ 加 $1$ ，$b[v]$ 加 $1$ ，$b[\operatorname{lca}(u,v)]$ 减 $1$ ， $b[fa[\operatorname{lca}(u,v)]]$ 减 $1$ 。最后对于一个点上的权值，我们求这个点的差分数组的子树和就可以了。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>《算法竞赛进阶指南》大法好！</p>
<p>首先对于每个玩家的跑步路线，我们把它拆成两段： $S_i\to \operatorname{lca}(S_i,T_i)$ 和 $\operatorname{lca}(S_i,T_i)\to T_i$（不包括 $\operatorname{lca}(S_i,T_i)$ ）。</p>
<p>然后分开考虑：</p>
<ol>
<li>若一个观察员 $x$ 处在 $S_i$ 到 $\operatorname{lca}(S_i,T_i)$ 的路径上，当且仅当 $deep[S_i]-deep[x]=w[x]$ 时，这个观察员可以观察到这个玩家 $i$ 。其中 $deep$ 数组表示节点的深度。</li>
<li>若一个观察员 $x$ 处在 $\operatorname{lca}(S_i,T_i)$ 到 $T_i$ 的路径上，当且仅当 $deep[S_i]+deep[x]-2\times deep[\operatorname{lca}(S_i,T_i)]=w[x]$ 时，这个观察员可以观察到这个玩家 $i$ 。</li>
</ol>
<p>对于情况一，把关于 $x$ 的项都移到等式右边，得到 $deep[S_i]=deep[x]+w[x]$ 时，这个玩家可以被位于点 $x$ 的观察员观察到。</p>
<p>那么这种情况就转化为：每一个玩家在 $S_i$ 到 $\operatorname{lca}(S_i,T_i)$ 的路径上放一个类型为 $deep[S_i]$ 的物品。最后求任意 $x$ 处的类型为 $deep[x]+w[x]$ 的物品有多少个。</p>
<p>看到这里，就知道可以用树上差分了！</p>
<p>“路径 $u\to v$ 上放类型为 $k$ 的物品”可以转化为：在 $u$ 处产生一个物品 $k$ ， $v$ 处也产生一个物品 $k$ ，在 $fa[\operatorname{lca}(u,v)]$ 处减去两个物品 $k$ 。然后对于一个点上拥有的物品，我们求这个点的子树中所有的物品即可。</p>
<p>情况二类似，请读者自行推导（<del>或者看《算法竞赛进阶指南》中的结果，只要你有</del>）。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> grep(u) for(int ptr=last[u];ptr;ptr=pre[ptr])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">5</span>,LOGMAX=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s[N],t[N],w[N];</span><br><span class="line"><span class="keyword">int</span> target[<span class="number">2</span>*N],pre[<span class="number">2</span>*N],last[N],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deep[N],bel[N][LOGMAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    deep[u]=deep[fa]+<span class="number">1</span>;</span><br><span class="line">    bel[u][<span class="number">0</span>]=fa;</span><br><span class="line">    rep(i,<span class="number">1</span>,LOGMAX<span class="number">-1</span>) &#123;</span><br><span class="line">        bel[u][i]=bel[bel[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    grep(u) <span class="keyword">if</span>(target[ptr]!=fa) dfs(target[ptr],u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bok1[N],bok2[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[u]&lt;deep[v]) swap(u,v);</span><br><span class="line">    per(i,LOGMAX<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(deep[bel[u][i]]&gt;=deep[v]) u=bel[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line">    per(i,LOGMAX<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(bel[u][i]!=bel[v][i]) u=bel[u][i],v=bel[v][i];</span><br><span class="line">    <span class="keyword">return</span> bel[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c[N*<span class="number">2</span>],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=c[w[u]+deep[u]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok1[u].begin();ii!=bok1[u].end();++ii) ++c[*ii];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok2[u].begin();ii!=bok2[u].end();++ii) --c[*ii];</span><br><span class="line">    grep(u) <span class="keyword">if</span>(target[ptr]!=fa) dfs1(target[ptr],u);</span><br><span class="line">    <span class="keyword">int</span> ans=c[w[u]+deep[u]]-now;</span><br><span class="line">    sum[u]+=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=c[w[u]-deep[u]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok1[u].begin();ii!=bok1[u].end();++ii) ++c[*ii];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok2[u].begin();ii!=bok2[u].end();++ii) --c[*ii];</span><br><span class="line">    grep(u) <span class="keyword">if</span>(target[ptr]!=fa) dfs2(target[ptr],u);</span><br><span class="line">    <span class="keyword">int</span> ans=c[w[u]-deep[u]]-now;</span><br><span class="line">    sum[u]+=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s[i],&amp;t[i]);</span><br><span class="line">        <span class="keyword">int</span> lca=query(s[i],t[i]);</span><br><span class="line">        bok1[s[i]].push_back(deep[s[i]]);</span><br><span class="line">        bok2[bel[lca][<span class="number">0</span>]].push_back(deep[s[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    rep(i,<span class="number">1</span>,n) bok1[i].clear(),bok2[i].clear();</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> lca=query(s[i],t[i]);</span><br><span class="line">        bok1[t[i]].push_back(deep[s[i]]<span class="number">-2</span>*deep[lca]);</span><br><span class="line">        bok2[lca].push_back(deep[s[i]]<span class="number">-2</span>*deep[lca]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%d "</span>,sum[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ZR2020春季NOIP模拟赛day3总结</title>
    <url>/2020/03/ZR2020%E6%98%A5%E5%AD%A3NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9Bday3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="b24e8cda58b901643ba832c5a81be566451b2c318c7e79211237f7bdd70a09af">2610e6f9332f0e99dc1d9430e23048d6cf0ef08c8ac1e07d3300ae0f9e4dc84914bb775af9d74637b7ea2d72de7c0093e2d8fc336dfd2107a359a9d1633b3309492529a2fbba8e671ae28303f0c36f92ca6a83f9923a00816c057fe1b0fffb40127d0d0c09b2cbec5b933908e4c20840c94faf172bdef113d421d29633cb0e3ff427ddb92b41095869bd43c077622e7302968bc7a0e23a762c0a238b59c9000b49e47699b55cbc4d102d4c8c0d590dcea52cf35681205b87dddff65f412efe65b4d9fcd3db54231be0a986ea67b3d29ae39aaf05bac7a2d9849f246953404e60474516143ad0f851b12a58eff36ea7c399022e3113dd2a075aae99c686f8896d4b0ee93c1c0a245d9385e81a5a69dd459caacea6cd8e800c8abe47bbf98f822269a0b5e55aa88b2c2623cb695c161c31be360aed4041357ba8de0f8afe729d4a942869c517f1be2f91b291a60f17c96730bc7ce8a806de55916b85011aa3cdc638cb7643971bcdeb1ef4d6114d057fe33494c5516d20c406d97a357fe6b7dd8854e0bbfe7133e165f4b04d8e28a6bd4bd7c4776cd1443e641e4cf35c8a510571c8c8f5df82678cf240f9079babbd066b4c938a91d0720fe6ae18e5185e5ac2f6dba38d73dbb823f74391a729aacec44a409dd9593d35a80cd81aaf613e854527488b0e56a1954e81897e9a16e69fc43d23af136f8f0619d66447bd3bebd0aa92291ba1a2dc56d0b2f24987a0431204f755c36113a03d5f95328df135f04d2477c1d35fdfe2d58ebb76d820cca948655731e5b6c640a1c0e100ab6fb30a3678a948b5ea67100e2b9eead25523a422a205a7bc79abf48b9ba05a6a6bf33a0d6a6bf18193d7f07560b615bcb9af1ce5c07f7e997096ee5fc73b55fdd7cb48546e0c2846820a1149e0390bdcd003dc0b0617b47984a4766ebbfccccca4edbc8e877bc45e8e8b12d023ccc5ca9e49f09c7c3fdd1806644d05074015690454777646afba4601ebf4cdbeee2f88f246d949c6b9af708ca12e1631c02b2324e3b2b511d73af600b6163bdb42cba841d1691e53e7a994f554a15d03f7bd58cd809d190b3240539901cce89a6a7c94b233638af9f9212948e0df07b4fb287f04d0370ffa0ba8a631dc65c74100ed1da06e6e56a7474e520b4ddb6f82226cdbba2ebfc43788b6f02df9b6bc17491a3310b52633aba46dffe621694b25f8ed1d0d047b7abc9f48ed4aaa78ae91a4869101c65c5d8e10a0135d59b11bbd7e3f12ab6fa40689a6084c209b5de60e5e6d7461590034decf15b9ae3bc2bb926a88a45bb0dcff3efa8dda47ed8c6fbd7dfc42583e03a5227ec2dac767783ba52c5b90f969ac8a2629b5c854fe8383293994563a408a634accea1054add2353f2d24d1bc9d958f2a5a3b0165960591b8541b4ad08e7a48fa5362d6a49ad3b3e9a423a97437735b11af021c5eb97441aceabc51ab7d00553e3a0238a9b7688f6fb7d77a27d7ab1d40c39c84d23fe16efb0cdd8fa508ab76572e12cbb94fa0248e5f5b27ae8a2faad76039a75bbcef28c6ff28560f3d2da5eccb4dc3c660bb79abdc67021d05cb0cc1cb475660fea10db6bb84bef819e19e87872f65ec31cdf4e4b50be64ff49a3df92e6372a4ecb8f17fa3bd598420684c18e966b03e041d38a407eb7438924ccbd4fcd3f05cffcca25232049568fb2b78451d069712fda62ae978d9b68904e393a7f17a9fc33c36660d9cfd0af38165de075dc5554fb9c98975e2bab1467c1b86c01529638273c8b9fe7d70cde6840337a8e7f5a852ab546f840f2984791f9c67a74313801fc6fe59b46b1e438a4ace59c17606599b6142c6c00abe455f7ed4f0d95b0ac885fe80b3afb0094a038ea864f519561685c05b94078c7916bba2c39113b81c0586fab8c945f786bc9bf8ac4868fc1bb7edd3332326b3ca8a3cc4e24df52cb0ff96bd89268bf78f15a7de1e8a9b172cbf4004bbc2c057322b91b3fe584943f679fe3a79a4cc4bc41f9cc130f0e34d14c276440ca60efdaf340118085eed4b8f9210b2779ad3699e68d5f88ca0e9172ac1f45a7f9f5133a2f8c79d99e8e88d68b67d3842a07e20e1b40ffa91e1dcc3189e5b33deba0ee60b7e7d6fa2ecd5795dd11cd9a513ee1b27e2342bb6d0dd9275ed714495ccfef3298b9462a4e91c32</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LuoguP2602 [ZJOI2010]数字计数</title>
    <url>/2020/03/%E9%A2%98%E8%A7%A3-LuoguP2602-ZJOI2010-%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2602" target="_blank" rel="noopener">题目传送门</a></p>
<p>题意：给定两个正整数 $a$ 和 $b$ ，求在 $[a,b]$ 中的所有整数中，每个数码各出现了多少次。</p>
<p>数据范围：$a\le b\le 10^{12}$</p>
<p>首先，这道题显然是数位 DP 的套路题（统计某个区间内满足某个性质的数有多少之类的题基本都是数位DP）。</p>
<a id="more"></a>
<p>设状态 $f[i][sum]$ 表示已经考虑到了前 $i$ 位，目前的某个数码 $d$ 的个数为 $sum$ 。</p>
<p>我们可以转移：$f[i][sum]=\sum f[i-1][sum-(now==d)]$ ，其中 $now$ 表示考虑的第 $i$ 位上的数码。</p>
<p>采用记忆化搜索进行转移处理数位 DP 是很方便的，具体实现见代码（有注释）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">15</span>][<span class="number">15</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,num[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> sum,<span class="keyword">int</span> d,<span class="keyword">bool</span> lim,<span class="keyword">bool</span> zer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    x表示当前到了第几位，sum表示当前答案，d表示需要处理个数的数码，</span></span><br><span class="line"><span class="comment">    lim表示是否在上界，zer表示是否为前导0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="comment">//递归到终点了，返回答案</span></span><br><span class="line">    <span class="keyword">if</span>(~f[x][sum][lim][zer]) <span class="keyword">return</span> f[x][sum][lim][zer];</span><br><span class="line">    <span class="comment">//给f数组加入了lim和zer两个0/1量来保证返回的数据是符合当前条件的。</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,lim?num[x]:<span class="number">9</span>) &#123;</span><br><span class="line">        <span class="comment">//这里判断lim是为了处理在上界时只能for到b的那一位的情况。</span></span><br><span class="line">        <span class="keyword">if</span>(zer&amp;&amp;i==<span class="number">0</span>) ans+=dp(x<span class="number">-1</span>,sum,d,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//前导的0不计入答案。</span></span><br><span class="line">        <span class="keyword">else</span> ans+=dp(x<span class="number">-1</span>,sum+(i==d),d,lim&amp;&amp;(i==num[x]),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][sum][lim][zer]=ans; <span class="comment">//赋值用于记忆化。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) num[++tot]=x%<span class="number">10</span>,x/=<span class="number">10</span>; <span class="comment">//拆位。</span></span><br><span class="line">    <span class="keyword">return</span> dp(tot,<span class="number">0</span>,d,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%llu%llu"</span>,&amp;a,&amp;b);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">9</span>) <span class="built_in">printf</span>(<span class="string">"%llu "</span>,sol(i,b)-sol(i,a<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ZR2020春季NOIP模拟赛day2总结</title>
    <url>/2020/03/ZR2020%E6%98%A5%E5%AD%A3NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9Bday2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="a711f5d457d0605b8b01f279dae50879650e37eb9d9f8d113735581bab1b1534">fc64cbd0556ec1bf561d9ef649835821ef2e62a9e0abb9292ff81767627d374e5d09c68ea842cc6d931e510ca79fd058df85115dcb8a64175493c45adaeb56ef51462976fc1850a9c5f5d33ad4c0cdc1c2c2d9158965281e9aec01905254cdcfc5c7a6a5409458e369630e3696222b25c6461ff5b804babd3f15968222c414b35d840b6734cd4034b0d60e03436c7c875ac150c48bc8bf2ff670c7674a2d668665adbf0ebf28eae3fa72d548298c70b893a1f7dd938faf0d084b9f6e6415c09771c7d684b20cdf6c3e70f9fef0431f5fe3cf9e48c57a1caf93ea1c8eae86f7ba9f97ce5a01331a58ace09675237d795e640959e01b6bf5601a5e05cd8e3971c9661895cfd40adcc14d3fc7c5cd353ddc92c7f452d45870d5920bc670074fa7d863581e9bc7008e98135f91b45892ad45aa62af6f3c9d31bd0b318cb42c69133835bf6d483f399fad4af89093a32f53753609c2c00519d7e83df9afcb81697e168e9f19dd37d3f71759a4e08286a04507fe310aee2c0c18e3fc6832240f31e0b04da32b67eb79ff26d589b40f7f780ce0c4f3586880bc56f4b5df8edbe4cb3b618b66a6480816c26cd2a324792e87f54be2dbfd6e377ef179c98175ae4ec39d415bdb408fd16040b10f0e7fb6361c17989d971d0ad9361926f71aaabb70c6c9a73792ebdf670e08b544aff740196a6e2aa558c60a45a3077aeb10fd6306e651e4a498c84b3951cc4855553e29fa02397905f54215d28c195bcbe63ab77be3bd3384701960b7fdeddea6ab50cf74a50bdd0d3f3a6f14a7c1a8d993441d43e6af6ff70935a98b363ff68f2d51764d72c2bc96924b4200bcf1f99cff812aa0595733d4e9b2f0687d28f2d8d8cdc986fd0f85a821cc7b3d0b9a6412e13773bf926036458579e2a995337d8a5542096e1081db6fe66a22af3c9cce8b358488a2e9658bd434514b2e310c19b7a8f4c86253617b040b6988e61845daf7dba87e950ed61f600cacee5c9c1e2819070e54f827672baffa31729309f195d4fafa88a372d5f5c5bbbd77efa498a7cb00642792cced7c8e2172fd47befec5aa260ee2d17663c1374e9930410ab8e73afe3e4be4a020e86e2a0e4e1641ff229b5c8a68fdefe5b487955c4e60dc5131d7829d76332ded246669683e76744d88f7f1c93121224aef4a6e53b31c6e93f017f269a15d0afbd24ccc7fcdadd55e75895f98df6194e1a5fb448ab76c01f86ac8a996651e4834e25303f34c2af5635ede5f00795e8d7440a62ace7409903cd44aaf7a2bf19c142bb8fdb676a35003a016af7376fae7094db8c20e8deda3d6d9d098c9f3d93e37ea547de865c98869a9464c311f1fedc66719469e6bd6e8f9298db2bc54c4c58a1ae5a4c96a67f4139b6bac4a26314594668238f3d2a0759d4d222b2e1dafa5c1fbaf784101af22e3a69b4383470f5bc11b08dc413776664a724982c6f7770014d50654b3a3b97c782287e314f57eceb85a9d91d2e9869fdb3ca7fc9161a31efb67f37fea6d9f5acd95e8cdbe680eea02537f51cb28411d0f101465d7c1166192631d8fd06e660528a4c5cb1cb21059827b34abe297bf577f6fb6a578998a269ba0afbbfcc6353008441ad82d774824391f8ab1d6fe780ac70ffefa540aa3d703b88b449fc15af0320d35f25b0eb39cb8ab3ba52b0dd8f6b98b1dab686b648e70f405aab7c34ecf3a8b3875834e4bb5cabd3f1d3c3ea4512f4772ce1b515008f4256d1b149e09c86956c5a396654e5f259c7024385d088377d1487ee2c0a3fd03cdeeb20c4d77284187eb54bb11df60a96191f28459503b92faeee26a114d37c7560f04f43c8cfd88971071c73154c2fdd2d01f49f36b3849b145eaa9b0ce9013ef6a4288709690282fded40e5c1e7f4d3959d517ea92032b079eac518d81043b1d0133951859a4927ebe9ca62abf3faa5df0922097ab2d159027a00f2efc005cf90512efe33e61e833298a41e2cb1c586d54609d4bdeb2377de20831ff71f7a46dfa19307eea2c3a0ab5c8a9806b09e9458ac5a176b404feaf7a57762ab9d9ed1e8253f89909d4c80caefc3e0123592637e866fd4e3d902fcf8982127983c9a3808121ec980a2e5f14a4bd8b020b07e46a52f6689759c0cb12659f6b80f438af5701954166044798e84e28d6f0d990d46a8ecfe7e17741f3b3345f0b495338e1d1276236bced4118fbb52d02fbdd46faae207161ac593e40a8a0c5434961fe71a91ae27e2c940a450b112fc1540186dd329bb13b907eba2f9d5296017b5669235b6393fd12f184f2b351575f331cab32f576d1f9fef617e4b36853660991419d75f447383c234b13a0d1ed13cfe844b45c1da241e5c1b76dedf7d26bed902e31ebf50f90f621e07595ede313d41b6b9bed8bbbfdff0f6f46daf7c53b2d5b52ab402512dc9e5bdd906ccd73103d6957109067064e77928f0339d93c1be532f313919e86ebb8e93dfd61943524ec7e89503dff3509be149eb4ab34acc0e2378a0b8c6c6da5fd6617de9fc5896a6864c906b20c5ee69bebafd6e8a425bac4384c983668e2b1ed1cc7c9af594a6c32e52ae06c10a78af37b399e74b2f67d71abaccf8b5a6937b5e7a42050a2dbc26cb385a44d811d609377ff8e7c32580d3027e83a8b4a5753326a150207ed92dad56aee7f2e1a2fec96207972e8a7aa02c149d5af5c2c314b68513dab8f4fbfc696a8c4be8138cdcdc7b56a534f46a729b357eb327beb0ce2aa100cc14ac64cbbebaaf5de7b406773415896cdd7e01001207fe03dccf27e8e425d437042afa6692dfd921930666cb9b77aee1d0fde2f68f7c2bcfea5df33e2430b27291b7adc5812a0a5e0aa</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LuoguP3469 [POI2008]BLO-Blockade</title>
    <url>/2020/02/%E9%A2%98%E8%A7%A3-LuoguP3469-POI2008-BLO-Blockade/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3469" target="_blank" rel="noopener">题目传送门</a></p>
<p>题意：有$n$个点、$m$条边的无向图，对任意$1\le i\le n$，求出将第$i$个点和与其关联的边删去时，有多少个有序点对$(u,v)$满足$u$和$v$不连通。</p>
<p>显然，这道题需要用到割点。</p>
<a id="more"></a>
<p>先考虑$i$不是割点的情况。因为$i$不是割点，所以把$i$和与其相关联的边去掉时，其他$n-1$个点依然是连通的。因此答案为$2(n-1)$。（注意题目中说的是<strong>有序点对</strong>）</p>
<p>然后来考虑$i$是割点的情况。</p>
<p>很显然，若$i$是割点，删去$i$和与其相关联的边后，原图会变成若干个连通块。那怎么求这些连通块的大小呢？</p>
<p>我们思考一下：tarjan算法是如何判定割点的？</p>
<p>答案是：在搜索树上，如果$i$不是根节点，则如果有任意$son_i$满足$dfn[i]\le low[son_i]$，$i$即为割点。当$dfn[i]\le low[son_i]$时，$son_i$除了往上走树边到达$i$以外不能到达$i$子树外的地方，也就是说删除$(i,son_i)$这条边后，图会分为$son_i$的子树与其它这两个部分。所以$i$就是割点。</p>
<p>所以这道题的答案就很显而易见了：对任意满足割点判定式$dfn[i]\le low[son_i]$的儿子$son_i$，在删去$i$和与其相关联的边后，$son_i$的子树会变成图中的一个单独的连通块。因此我们只需要在tarjan找割点的同时统计一下这些子树的大小加进答案里即可。</p>
<p>别忘了还有一个连通块是除了$i$子树以外的所有点。</p>
<p>Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,M=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> target[M],last[N],pre[M],tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],sz[N],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u]=<span class="number">1</span>;</span><br><span class="line">    dfn[u]=low[u]=++cnt;</span><br><span class="line">    <span class="keyword">int</span> flg=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> iscut=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=target[ptr];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            sz[u]+=tarjan(v);</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;=dfn[u]) &#123;</span><br><span class="line">                ++flg;</span><br><span class="line">                ans[u]+=sz[v]*(n-sz[v]);</span><br><span class="line">                sum+=sz[v];</span><br><span class="line">                <span class="keyword">if</span>(u!=<span class="number">1</span>||flg&gt;<span class="number">1</span>) iscut=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> low[u]=min(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iscut) ans[u]+=(sum+<span class="number">1</span>)*(n-sum<span class="number">-1</span>)+(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> ans[u]=<span class="number">2</span>*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> sz[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    tarjan(<span class="number">1</span>);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>题解UVa1220 Hali-Bula的晚会</title>
    <url>/2020/02/%E9%A2%98%E8%A7%A3UVa1220-Hali-Bula%E7%9A%84%E6%99%9A%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="刘汝佳大法好！"><a href="#刘汝佳大法好！" class="headerlink" title="刘汝佳大法好！"></a>刘汝佳大法好！</h1><p>是不是感觉看到这题很熟悉？好像很像<a href="https://www.luogu.com.cn/problem/P1352" target="_blank" rel="noopener">没有上司的舞会</a>这题诶！</p>
<p>可是我们发现，这里还新加了一个“判断唯一性”的任务。</p>
<a id="more"></a>
<p>我们定义：</p>
<p>$d(u,0)$表示不选$u$的$u$的子树的最大独立集的节点个数</p>
<p>$d(u,1)$表示选$u$的$u$的子树的最大独立集的节点个数</p>
<p>$f(u,0)$表示不选$u$的$u$的子树的最大独立集的唯一性（$0$不唯一，$1$唯一）</p>
<p>$f(u,1)$表示选$u$的$u$的子树的最大独立集的唯一性（$0$不唯一，$1$唯一）</p>
<p>则</p>
<script type="math/tex; mode=display">d(u,1)=1+\sum_{(u,v)\in E}d(v,0)</script><script type="math/tex; mode=display">d(u,0)=\sum_{(u,v)\in E}\max\{d(v,0),d(v,1)\}</script><p>以上两个就是求最大独立集的转移方程。</p>
<p>然后考虑怎么判断唯一性。</p>
<p>对于$f(u,1)$的情况：如果$u$的任意一个儿子$v$的$f(v,0)=0$，那么$f(u,1)$就等于$0$。</p>
<p>对于$f(u,0)$的情况：设$v$为$u$的任意一个儿子</p>
<ul>
<li>若$d(v,0)=d(v,1)$，则$f(u,0)=0$。</li>
<li>若$d(v,0)&gt;d(v,1)$且$f(v,0)=0$，则$f(u,0)=0$。</li>
<li>反之亦然。</li>
</ul>
<p>以下为代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot=<span class="number">0</span>,target[N],pre[N],last[N];</span><br><span class="line"><span class="keyword">int</span> d[N][<span class="number">2</span>],f[N][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!last[u]) &#123;</span><br><span class="line">        d[u][<span class="number">0</span>]=<span class="number">0</span>;f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        d[u][<span class="number">1</span>]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][<span class="number">1</span>]=<span class="number">1</span>;f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    d[u][<span class="number">0</span>]=<span class="number">0</span>;d[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        dfs(target[ptr]);</span><br><span class="line">        <span class="keyword">if</span>(f[target[ptr]][<span class="number">0</span>]==<span class="number">0</span>) f[u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        d[u][<span class="number">1</span>]+=d[target[ptr]][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v=target[ptr];</span><br><span class="line">        <span class="keyword">if</span>(d[v][<span class="number">0</span>]==d[v][<span class="number">1</span>]) f[u][<span class="number">0</span>]=<span class="number">0</span>,d[u][<span class="number">0</span>]+=d[v][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[v][<span class="number">0</span>]&gt;d[v][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[v][<span class="number">0</span>])f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            d[u][<span class="number">0</span>]+=d[v][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[v][<span class="number">0</span>]&lt;d[v][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[v][<span class="number">1</span>])f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            d[u][<span class="number">0</span>]+=d[v][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">string</span> x,y;</span><br><span class="line">        mp.clear();</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        mp[x]=++cnt;</span><br><span class="line">        rep(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(!mp.count(x)) mp[x]=++cnt;</span><br><span class="line">            <span class="keyword">if</span>(!mp.count(y)) mp[y]=++cnt;</span><br><span class="line">            add(mp[y],mp[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">1</span>][<span class="number">0</span>]==d[<span class="number">1</span>][<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">"%d No\n"</span>,d[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[<span class="number">1</span>][<span class="number">0</span>]&gt;d[<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!f[<span class="number">1</span>][<span class="number">0</span>]) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[<span class="number">1</span>][<span class="number">0</span>]&lt;d[<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!f[<span class="number">1</span>][<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>题解UVa12186 工人的请愿书</title>
    <url>/2020/02/%E9%A2%98%E8%A7%A3UVa12186-%E5%B7%A5%E4%BA%BA%E7%9A%84%E8%AF%B7%E6%84%BF%E4%B9%A6/</url>
    <content><![CDATA[<h2 id="刘汝佳大法好！"><a href="#刘汝佳大法好！" class="headerlink" title="刘汝佳大法好！"></a>刘汝佳大法好！</h2><p>设$dp(u)$表示让$u$号员工给上级发信至少需要多少个工人。</p>
<p>那么假设$u$的子节点个数为$k$个，则至少需要$c=(kT-1)/100+1$个直接下属发信才可以让$u$号员工给上级发信（注意以上公式括号内的$-1$是为了防止$kT$为$100$的倍数而减一的）。</p>
<a id="more"></a>
<p>则我们更新$dp(u)$的方法是：将$u$的$k$个下属中$dp$值最小的$c$个做和，即可保证$dp(u)$是最小的。</p>
<p>最后答案就是$dp(0)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="keyword">int</span> target[N],pre[N],last[N],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot] = v;</span><br><span class="line">    pre[tot] = last[u];</span><br><span class="line">    last[u] =  tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!last[u]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp[N],cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        tmp[++cnt]=dfs(target[ptr]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ned = (cnt*t<span class="number">-1</span>)/<span class="number">100</span>+<span class="number">1</span>,dp=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,ned) dp+=tmp[i]; <span class="comment">//取最小的c个dp值</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;t)&amp;&amp;n&amp;&amp;t) &#123;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            add(x+<span class="number">1</span>,i+<span class="number">1</span>); <span class="comment">//这里我把点的编号加一了，从0~n变成了1~n+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dfs(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-J/S 2019游记</title>
    <url>/2020/02/CSP-J-S-2019%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>日常肝作业+复习到12点.jpg</p>
<p>瞎背了背板子，在背匈牙利的时候被rui_er大佬喷了：</p>
<blockquote>
<p>rui_er: “匈牙利多简单~”</p>
</blockquote>
<p>dijkstra这么zz的算法都经常背错，我也是自闭了…</p>
<p>爆0预定</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>昨天没睡好.jpg</p>
<p>忍着眼皮子想要打架的欲望起了床。。。</p>
<p>开始一天的旅程</p>
<p>首先临阵擦枪，在车上背了背LCA板子，又复习了一下dijkstra <del>（尽管这两天都没用到）</del></p>
<p>迷迷糊糊走进了考场</p>
<h2 id="Senior-Day-1"><a href="#Senior-Day-1" class="headerlink" title="Senior Day 1"></a>Senior Day 1</h2><p>三样密码都没猜对</p>
<p>看T1</p>
<p>诶诶诶T1这不是道**题吗？</p>
<p>赶快A掉，看T2</p>
<p>我先花了半个多小时好不容易YY出了一条链情况的$O(n)$算法</p>
<p>又花了十几分钟打了一下。本来冲着100分去的，但是由于我太菜，代码能力有点弱，70跑路（100看脸，能被半链半菊花卡死）</p>
<p>T3是什么？能吃么？10分走人</p>
<p>回去检查T1T2</p>
<p>文件名都没问题</p>
<p>看看数据范围</p>
<p>诶诶诶T1我$n=63$怎么炸了？</p>
<p>赶快<code>unsigned long long</code>。。。</p>
<p>诶诶诶$n=64$怎么又炸了？</p>
<p>改成<code>(1&lt;&lt;(n-1))-1+(1&lt;&lt;(n-1))</code>。。。</p>
<p>总算好了，虚惊一场</p>
<p>20分差点没了</p>
<p>今年真**难</p>
<p>希望是Day1 Day2 难度互换了</p>
<p>估分：100+70+10=180</p>
<h2 id="Junior"><a href="#Junior" class="headerlink" title="Junior"></a>Junior</h2><p>普及没什么压力</p>
<p>T1：zz题，50秒AC</p>
<p>T2：暴力模拟即可，常数45，听说有人被大样例卡常了？！</p>
<p>T3：看起来是原题，可我还是不会。打了个部分分和假贪心，大概40分</p>
<p>T4：一眼题。打完发现大样例RE了。。。可只剩下十分钟不到了没时间调试了，40分跑路</p>
<p>总结：今天T4太可惜了，丢了60分。。。</p>
<p>T3完全背包没看出来.jpg</p>
<p>我连每天全卖光都想到了，然后呢，就去想假贪心了。。。</p>
<p>估分100+100+40+40=280，可惜没上300</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>昨晚肝作业++</p>
<h2 id="Senior-Day-2"><a href="#Senior-Day-2" class="headerlink" title="Senior Day 2"></a>Senior Day 2</h2><p>密码还是没猜对</p>
<p>打开题目，一惊：凉了！</p>
<p>原来Day1 Day2难度并没有互换。。。</p>
<p>T1第一眼不会，T2第一眼不会</p>
<p>跑去打T1部分分。</p>
<p>匆匆忙忙打了个12分的$m=2,a_{i,j}&lt;2$的部分分走了</p>
<p>T2呢？暴力+假贪心12+rand()分跑路。</p>
<p>过去看T3</p>
<p>我*！T3好像部分分很足的样子！</p>
<p>一言不合就40分暴力，$O(m)$枚举删边，$O(n)$找重心。</p>
<p>再来个15分的一条链，获得55分。</p>
<p>估分12+12+55=79</p>
<p>于是TG总估分就出来了。100+70+10+12+12+55=259。</p>
<p>事实证明，之前背的板子都没用上。。。</p>
<h1 id="Day-4（2019-11-19）"><a href="#Day-4（2019-11-19）" class="headerlink" title="Day 4（2019.11.19）"></a>Day 4（2019.11.19）</h1><p>于是BJ的选手代码出来了。</p>
<p>跑洛谷上去测民间数据，100+70+10+8+12+55=255。D2T1好像挂了？</p>
<p>跑icode上去查估分，95+70+10+4+0+55=234。额更玄学了，T1我明明好好检查了呀？D2T1和T2可能真的挂了。。。</p>
<p>然而这样icode估分好像还是我们弱校rk1？不可能吧.jpg</p>
<p>深深感到自己的渺小</p>
<h1 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h1><p>于是发分了</p>
<p>PJ炸了，100+100+30+35=265。不过一等还在。</p>
<p><del>PJ不上300还比TG考的低太没面子了</del></p>
<p>TG D1T2数据水，70-&gt;100，但D2T1果然挂了，0分。</p>
<p>于是TG 100+100+10+0+12+55=277拿了个省一qwq</p>
<p><del>看来以后不要相信icode</del></p>
<p><del>以下是吐槽：</del></p>
<p><del>一个奖状要100！CCF NB！</del></p>
]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>CSP</tag>
        <tag>2019</tag>
      </tags>
  </entry>
</search>
