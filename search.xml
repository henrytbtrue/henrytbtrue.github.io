<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021 年 8 月水题选做</title>
    <url>/2021/08/2021-%E5%B9%B4-8-%E6%9C%88%E6%B0%B4%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<p>决定重新开坑这个系列。</p>
<p>然而马上就初三了估计只有 8 月份的了。</p>
<a id="more"></a>
<h1 id="8-11"><a href="#8-11" class="headerlink" title="8/11"></a>8/11</h1><p><a href="https://www.luogu.com.cn/problem/AT4512" target="_blank" rel="noopener">$\color{green}{\text{AT4512}}$</a></p>
<p>好神仙的构造题…</p>
<p>首先有一种 naive 解是第 $i$ 行全都填 $i$。</p>
<p>但是这样只能做 $k\le 500$ 的情况。</p>
<p>考虑换一种新解。</p>
<script type="math/tex; mode=display">
\begin{matrix}
1&2&3&4&5\\
2&3&4&5&1\\
3&4&5&1&2\\
4&5&1&2&3\\
5&1&2&3&4\\
\end{matrix}</script><p>看起来还是只能做 $k\le 500$ 的情况。但是这个解法可以拓展。</p>
<p>观察到对于每一个数，其周围一定是两个 $a$ 和两个 $b$，而且这两个 $a$ 的行奇偶性一定不一样，这两个 $b$ 的行奇偶性也不一样。</p>
<p>那么就可以把这种解的其中一个数的奇数行的位置都换成一个新数。</p>
<p>换任意个数都可以。</p>
<p>例如</p>
<script type="math/tex; mode=display">
\begin{matrix}
6&7&8&9&10\\
2&3&4&5&1\\
8&9&10&6&7\\
4&5&1&2&3\\
10&6&7&8&9\\
\end{matrix}</script><p>这样的话就可以做 $k\le 1000$ 的情况了。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1364D" target="_blank" rel="noopener">$\color{green}{\text{CF1364D}}$</a></p>
<p>首先考虑一棵树的情况。显然树上不存在环，然后我们可以将树按照深度奇偶性染色，每一种颜色的构成一个独立集。从大的里面选 $\left\lceil\frac{k}{2}\right\rceil$ 个就可以了。</p>
<p>变成了一个图，我们可以类似地先搜出一个生成树。如果存在一条非树边连接的两个点深度之差 $&lt;k$ 的话那么显然可以找出一个大小不超过 $k$ 的环。</p>
<p>否则，在树上有非树边连接的两点之间在树上的距离一定是 $\ge k$ 的。那么我们从任意一个深度 $&gt;k$ 的点出发，往上跳，隔一个选一个，选出一个大小为 $\left\lceil\frac{k}{2}\right\rceil$ 的独立集即可。这样可以保证选出的点中一定没有非树边连接。</p>
<h1 id="8-13"><a href="#8-13" class="headerlink" title="8/13"></a>8/13</h1><p><a href="https://www.luogu.com.cn/problem/P1935" target="_blank" rel="noopener">$\color{green}{\text{P1935}}$</a></p>
<p>发现这道题是与周围类型不同的时候有额外收益。如果是相同的话那就很好办，不同怎么做呢？</p>
<p>将格子黑白染色，黑格子反着连边，这样就可以转化为相同了。</p>
<h1 id="8-14"><a href="#8-14" class="headerlink" title="8/14"></a>8/14</h1><p><a href="https://www.luogu.com.cn/problem/P3195" target="_blank" rel="noopener">$\color{green}{\text{P3195}}$</a></p>
<p>决策单调性优化 dp 的经典板子题，二分+队列维护即可。</p>
<h1 id="8-15"><a href="#8-15" class="headerlink" title="8/15"></a>8/15</h1><p><a href="https://www.luogu.com.cn/problem/P3809" target="_blank" rel="noopener">$\color{green}{\text{P3809}}$</a></p>
<p>终于学会 SA 了。。。</p>
<p>之前一直不懂板子的代码，现在算是搞懂了（但是难背死了）。</p>
<p><a href="https://www.luogu.com.cn/problem/P2408" target="_blank" rel="noopener">$\color{green}{\text{P2408}}$</a></p>
<p>SA 最简单的应用之一。使用 height 数组直接求解即可。</p>
<p><a href="https://www.luogu.com.cn/problem/P4555" target="_blank" rel="noopener">$\color{green}{\text{P4555}}$</a></p>
<p>manacher 的简单应用。对于每个 <code>#</code> 存一下它向左的最长回文串和向右的最长回文串。</p>
<p>具体来说，先用 manacher 处理出每个 <code>#</code> 能扩展的最长的极大回文子串，然后扫一遍更新即可。</p>
<h1 id="8-16"><a href="#8-16" class="headerlink" title="8/16"></a>8/16</h1><p><a href="https://www.luogu.com.cn/problem/P5495" target="_blank" rel="noopener">$\color{green}{\text{P5495}}$</a></p>
<p>莫反前置知识。从枚举约数优化到枚举素数，然后做高维前缀和。</p>
<h1 id="8-17"><a href="#8-17" class="headerlink" title="8/17"></a>8/17</h1><p><del>今天是虵滴生日</del></p>
<p><a href="https://www.luogu.com.cn/problem/P3803" target="_blank" rel="noopener">$\color{green}{\text{P3803}}$</a></p>
<p>学了一发 FFT。</p>
<p><a href="https://www.luogu.com.cn/problem/P3701" target="_blank" rel="noopener">$\color{green}{\text{P3701}}$</a></p>
<p>由于某些原因，在今天（8.17，蛏蜒节）写这道题。</p>
<p>这道题显然是一道最大流，考虑如何建图。</p>
<p>观察到寿命即为一个人可以用的次数，于是我们从 s 向 byx 的人连他们寿命的边，注意长者需要 +1s，于是需要把膜法师的人数续进命里。类似地从诗乃的人向 t 连类似的边。</p>
<p>然后考虑两边人之间比赛的连边情况，可以枚举一波然后如果 byx 的这个人可以赢诗乃的这个人，从 byx 的人向诗乃的人连 1 边，表示这个人可以用 1 个寿命获得一个赢的次数。</p>
<p>然后跑最大流就完了。注意只有 $m$ 场比赛，所以要特判一下答案 $&gt;m$ 的情况。</p>
<p>代码：<a href="https://paste.ubuntu.com/p/mCV5rkhxj2/" target="_blank" rel="noopener">戳我</a></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>atcoder</tag>
        <tag>luogu</tag>
        <tag>题解</tag>
        <tag>水题选做</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1174E Ehab and the Expected GCD Problem</title>
    <url>/2021/06/%E9%A2%98%E8%A7%A3-CF1174E-Ehab-and-the-Expected-GCD-Problem/</url>
    <content><![CDATA[<p>毒瘤 dp 题。</p>
<p>首先显然可以莽一波结论。</p>
<a id="more"></a>
<p>可以发现，当排列的第一个数 $a_1=\prod p_i^{c_i},p_i\ \text{is prime}$ 时，题目中所求排列的权值最大值为 $\sum c_i$。</p>
<p>这是因为在第二个数及以后，前缀 $\gcd$ 只会减小，不会增加，而且最好的情况是每次减小一个质因子。可以证明只要有一个确定的第一个数，该最好情况一定可以实现。</p>
<p>那么我们可以考虑找出使 $\sum c_i$ 最大的一个数 $a_1$。</p>
<p>再来猜一波：这个 $a_1$ 的可能性不会太多，它的质因子得小。因为如果有比较大的质因子的话，它的指数 $c_i$ 就会被压榨，会比质因子更小的情况劣。</p>
<p>那么质因子得有多小呢？我们先猜：这个 $a_1=2^x$。</p>
<p>这种情况确实很优，但不久后我们还会发现，$2^x\cdot 3^y$ 似乎也很可以。</p>
<p>但是到 $2^x\cdot 3^2$ 之后就爆炸了，因为有一个比它小但质因数分解后的指数和比它大的数 $2^{x+3}$。</p>
<p>因此，质因子 $3$ 的次数不能大于 $1$。</p>
<p>那么能不能有比 $3$ 大的质因子呢？显然不能。因为 $5&gt;2^2$，用了 $5$ 及以上的不如用一堆 $2$ 来代替。</p>
<p>那么我们可以得出结论：$a_1$ 只能等于 $2$ 的若干次方，或者 $2$ 的若干次方乘上 $3$。</p>
<p>那么就可以愉快设 dp 状态了：令 $f_{i,j,k}$ 表示到了该排列的第 $i$ 个数，当前前缀 $\gcd=2^j\cdot 3^k$ 时，有多少种情况。</p>
<p>转移可以分三类讨论：</p>
<ul>
<li>若加入一个数后 $\gcd$ 不变，那么 $f_{i+1,j,k}$ 需要加上 $f_{i,j,k}\cdot\left(\left\lfloor\frac{n}{2^j\cdot 3^k}\right\rfloor-i\right)$。因为 $\gcd$ 不变，那么加入的数一定是当前 $\gcd$ 的倍数，需要注意前面的所有数一定都是当前 $\gcd$ 的倍数，不可以选已经选过的数，于是情况数需要 $-i$。</li>
<li>若加入一个数后 $\gcd$ 变少了 $2$ 倍，那么 $f_{i+1,j-1,k}$ 需要加上 $f_{i,j,k}\cdot\left(\left\lfloor\frac{n}{2^{j-1}\cdot 3^k}\right\rfloor-\left\lfloor\frac{n}{2^{j}\cdot 3^k}\right\rfloor\right)$。由于 $\gcd$ 变少两倍，那么新加入的数一定得是 $\frac{\gcd}{2}$ 的倍数，但它不能是 $\gcd$ 本身的倍数，因为这样的话 $\gcd$ 就不会改变了。而在 $\frac{\gcd}{2}$ 的倍数和 $\gcd$ 本身的倍数中，都考虑了一遍已经加入过的数，抵消掉了，因此不会加入重复的数。</li>
<li>若加入一个数后 $\gcd$ 变少 $3$ 被，那么 $f_{i+1,j,k-1}$ 需要加上 $f_{i,j,k}\cdot\left(\left\lfloor\frac{n}{2^{j}\cdot 3^{k-1}}\right\rfloor-\left\lfloor\frac{n}{2^{j}\cdot 3^k}\right\rfloor\right)$。由于 $\gcd$ 变少两倍，那么新加入的数一定得是 $\frac{\gcd}{3}$ 的倍数，但它不能是 $\gcd$ 本身的倍数。类似地，在 $\frac{\gcd}{3}$ 的倍数和 $\gcd$ 本身的倍数中，也抵消掉了重复的数。因此这么干是对的。</li>
</ul>
<p>代码实现上因为 $3$ 只有可能是 $0$ 次方或 $1$ 次方，可以用三目运算符判断更加方便。</p>
<p>PS：这题十分卡常，还卡 <code>long long</code> 数组（如果 <code>dp</code> 数组用 <code>long long</code> 的话会炸）的空间。我是用火车头 $+$ C++17 才过的（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码就不放火车头了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1000005</span>][<span class="number">21</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qaq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;x)*(y?<span class="number">3</span>:<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> hav3=log2(n/<span class="number">3</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nhav3=log2(n);</span><br><span class="line">    dp[<span class="number">1</span>][nhav3][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(hav3==nhav3) dp[<span class="number">1</span>][nhav3<span class="number">-1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">        rep(j,<span class="number">0</span>,nhav3) &#123;</span><br><span class="line">            rep(k,<span class="number">0</span>,<span class="number">1</span>) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j][k]=<span class="number">1l</span>l*(<span class="number">1l</span>l*dp[i+<span class="number">1</span>][j][k]+dp[i][j][k]*(<span class="number">1l</span>l*n/qaq(j,k)%mod-i+mod)%mod+mod)%mod;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>) dp[i+<span class="number">1</span>][j<span class="number">-1</span>][k]=<span class="number">1l</span>l*(<span class="number">1l</span>l*dp[i+<span class="number">1</span>][j<span class="number">-1</span>][k]+dp[i][j][k]*(<span class="number">1l</span>l*n/qaq(j<span class="number">-1</span>,k)%mod-n/qaq(j,k)%mod)%mod+mod)%mod;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;<span class="number">0</span>) dp[i+<span class="number">1</span>][j][k<span class="number">-1</span>]=<span class="number">1l</span>l*(<span class="number">1l</span>l*dp[i+<span class="number">1</span>][j][k<span class="number">-1</span>]+dp[i][j][k]*(<span class="number">1l</span>l*n/qaq(j,k<span class="number">-1</span>)%mod-n/qaq(j,k)%mod)%mod+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈整除分块</title>
    <url>/2021/06/%E6%B5%85%E8%B0%88%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>今天研究了下这玩意，查了几篇 blog，感觉脑子里乱七八糟的，于是自己写篇 blog 尝试总结一下。</p>
<p>前面的几个例子摘自<a href="https://blog.csdn.net/weixin_43627118/article/details/104024380" target="_blank" rel="noopener">这里</a>，但是式子是自己手推的。</p>
<a id="more"></a>
<h1 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h1><h2 id="整除分块能干啥？"><a href="#整除分块能干啥？" class="headerlink" title="整除分块能干啥？"></a>整除分块能干啥？</h2><p>考虑形如 $\sum_{i=1}^{n} \left\lfloor\frac{n}{i}\right\rfloor$ 这样的式子。</p>
<ul>
<li>我会 $O(n)$！</li>
</ul>
<p>但是，使用整除分块能让计算这个东西的速度提升至 $O(\sqrt{n})$。</p>
<p>考虑 $n=10$ 的情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$i$</th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
<th style="text-align:center">$9$</th>
<th style="text-align:center">$10$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\left\lfloor\frac{n}{i}\right\rfloor$</td>
<td style="text-align:center">$10$</td>
<td style="text-align:center">$5$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
</tbody>
</table>
</div>
<p>诶，怎么有这么多重复的 $\left\lfloor\frac{n}{i}\right\rfloor$？</p>
<p>事实上，随着 $i$ 的增长，这种重复项会越来越多。</p>
<p>于是我们只需要快速统计每种项出现了几次即可。</p>
<p>我们对于每个 $\left\lfloor\frac{n}{i}\right\rfloor$ 重复的段分开考虑。</p>
<p>$n=10$ 的情况中，这些段分别是 $[1,1],[2,2],[3,3],[4,5],[6,10]$。</p>
<p>我们可以扫一遍这个段的左端点，然后通过某种神奇方式快速知道这个段的右端点，扫下一个段的时候直接将左端点赋值为这个段的右端点 $+1$ 即可。</p>
<p>那么怎么知道左端点为 $l$ 的区间的右端点 $r$ 是什么呢？</p>
<p>根据我们定义的这种区间的性质：</p>
<script type="math/tex; mode=display">\forall i\in[l,r],\left\lfloor\frac{n}{i}\right\rfloor=\left\lfloor\frac{n}{l}\right\rfloor</script><p>也就是说，$r$ 是最大的使 $\left\lfloor\frac{n}{i}\right\rfloor=\left\lfloor\frac{n}{l}\right\rfloor$ 的数 $i$，即</p>
<script type="math/tex; mode=display">r=\max\left\{i,\left\lfloor\frac{n}{i}\right\rfloor=\left\lfloor\frac{n}{l}\right\rfloor\right\}</script><p>因此</p>
<script type="math/tex; mode=display">r=\left\lfloor\frac{n}{\left\lfloor\frac{n}{l}\right\rfloor}\right\rfloor</script><p>（这个可以手玩几组样例试试）</p>
<p>也就是说，我们知道 $l$ 之后就能快速知道对应的 $r$ 进行求解。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    ans+=(r-l+<span class="number">1</span>)*(n/l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们考虑更加一般性的问题，例如求</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}\left\lfloor\frac{n}{ai+b}\right\rfloor</script><p>其中 $n,a,b$ 为给定常数。</p>
<p>我们还是按照老套路，考虑枚举一个 $l$，快速求解满足 $\left\lfloor\frac{n}{ai+b}\right\rfloor=\left\lfloor\frac{n}{al+b}\right\rfloor$ 的最大的 $i$，即为 $r$。</p>
<p>这个 $r$ 怎么求呢？</p>
<p>根据上一个例子，我们有</p>
<script type="math/tex; mode=display">ar+b=\left\lfloor\frac{n}{\left\lfloor\frac{n}{al+b}\right\rfloor}\right\rfloor</script><p>因此</p>
<script type="math/tex; mode=display">r=\left\lfloor\frac{\left\lfloor\frac{n}{\left\lfloor\frac{n}{al+b}\right\rfloor}\right\rfloor-b}{a}\right\rfloor</script><p>再考虑一个问题，求</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}\left\lfloor\frac{n}{i^2}\right\rfloor</script><p>那么知道 $l$ 的情况下，可以得出</p>
<script type="math/tex; mode=display">r^2=\left\lfloor\frac{n}{\left\lfloor\frac{n}{l^2}\right\rfloor}\right\rfloor</script><p>因此，</p>
<script type="math/tex; mode=display">r=\left\lfloor\sqrt{\left\lfloor\frac{n}{\left\lfloor\frac{n}{l^2}\right\rfloor}\right\rfloor}\right\rfloor</script><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="CQOI2007-余数求和"><a href="#CQOI2007-余数求和" class="headerlink" title="[CQOI2007] 余数求和"></a>[CQOI2007] 余数求和</h3><p>先放一个 <a href="https://www.luogu.com.cn/problem/P2261" target="_blank" rel="noopener">link</a>。</p>
<script type="math/tex; mode=display">
\begin{aligned}
  G(n,k) &=\sum_{i=1}^{n}k\bmod i \\
    &= \sum_{i=1}^{n}(k-i\left\lfloor\frac{k}{i}\right\rfloor)\\
    &= nk-\sum_{i=1}^{n}i\left\lfloor\frac{k}{i}\right\rfloor
\end{aligned}</script><p>因此，我们只需求</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}i\left\lfloor\frac{k}{i}\right\rfloor</script><p>简单推一推，对于区间 $[l,r]$，答案是</p>
<script type="math/tex; mode=display">\left\lfloor\frac{k}{l}\right\rfloor\cdot \frac{(l+r)(r-l+1)}{2}</script><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=n*k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k/l) r=min(k/(k/l),n);</span><br><span class="line">    <span class="keyword">else</span> r=n;</span><br><span class="line">    ans-=(l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>*(k/l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，需要注意的细节有</p>
<ul>
<li>$k$ 值可能 $&lt;n$，故可能存在有一个区间答案为 $0$ 的情况。</li>
<li>计算出的 $r$ 值可能 $&gt;n$，故需要与 $n$ 取 $\min$。</li>
</ul>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>5月20日校内模拟赛题解</title>
    <url>/2021/05/5%E6%9C%8820%E6%97%A5%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="8140dd6ca20fd15b41b83ba0ea3e97cb6aa06f0992ecba71ff2268bbe293528c">391410d5f1b582dbf2b6303298a6cd372863f6851327fd4b3880f1614c568258f3cb5ac72dec97e8c31abbdc5e4948d29bdf37f265f9b73434e4dbf74c9800085a364227012ad8a119c021a1eed2efecb53d321874ad970d6e907de0e6caf9374918d4ee1dcc3ca2f71f6edb00df692aee16ffdbd3df7cfc716cfbf814f41de3203558f0bdbf5e2062846ea3db99a42333de86b3f86d182a1e6521fd8392852e0956e7c77cdc77b9bd99144221bca71bd459b9a8088241a2dc9b13bd54d6695c21bc555f266f9f3721cac8727aa5f4ccb6afaa03669245d4cf3c62bcc14587018f2566669963e624bb1d9a3b4a06498c4267298113ae31317754df86aab4d123a7eb04038ca595b7a90238f171e575e35e67790da9d602532ec84ce769f6066583f7a2b3c31aca81faa23b40a747b458a8252514d2e75d16daeed9d1f1c97d9a599f9c28500e572ff7c629d130ba90ced17087ca093ea7433392288d32e29e4f1d96303050799a5e5a6c772f27403c6b3f9328306433a494e433adf9477a7c4a5b20b54f61989c444ce50c3a46bd1bcca88013f32d502162d0cf214ccd3f116980d7bb2b713b4b19156b238a601619218b6b37c49c3299847aa2e894d83d74c625902462602b01bbc1e81a510db6073e46ae0062c403f7215ef46343530602e8af21efb2e5510d0d6803b1b189694ad3c94d8e65b697be2499f0fe20e676ed3aeb48a94043ace6cead3cabfe574275b3c9826e0d48687e5f093599e04a91262160863cbad8ead91462512fdc3af79e45692e47cd30d4c9426e38cb1798e94201d3e988ad1aa1b5af927b9433de5cae16a84339b4ca2d952523a0e7262cf385e5acc5dab6132e66a0d954c9fcb06a23e378104d214a8989f7ace13257671d65d9ce62238b82c338d619b9c7bd555083a5f1a93813aafec9b6e41901305e6274f25c6d9a1959097079115d3c60a8fbc1ed7502170fc170882ac4d0508dfa6b08f2e28d51469c65856945fc868087f315237e7b8aa5a1edd7b9c04be1a23c5c7adef4474fece7323842d11e7f8bce932a2313d095bf4fcd0cb08d024e7c94a6e2f957175c94ec73f995a4f8c0dd814088a461748423cce162f808e0de85e0bf48b05f6e1c2b55818e0a7566cda501d7aa94130ce1242050af7ce53bdd0a8d3acfde612ca9ce52027c269b206d1e1019c556c8df71d0ed5a57002e9338463cfb5f2343bee3f46554f3ed99429b6e960a8a60534c2a401424a5f366e56fbb6652c437b11215b69e8f9c602d8d68edc6301e87450ed11197bb25374c87a225cdda6041380b747f3e6b418163ac7a57704e4df60773042dedfdfdc99af0e241b13d19a4b26fa7cb143cc8d467216c1cfa816b9d4ce1a9f8a2fe83c89733e6f602ad428ae432939de8bd7f56ae969767701aed371edb1b481ebebff30f331ffb97ade3a0ca32e0f81b68379c5276d290b6b1af402cf005d1e2a591804f71240e258034661250961449430ae83eaa3a0b4866ae066d94611aaf35b6d7f5f6eb2c9448978091d8dbf4e5025bedb3813fa06a5d0cbf3f27555dff0bbab800f8890a5c5d9beea3cbda89f0050e371e2afd0f4c159bfa126675ab23ebf9b093f22911b37ef98919cfe9a0d5be04b3c11fe5566a536cf1de9b7b8b6fb0864f3fcb869b42498ba118b0eb3eb200735df4ff28237aecab543274f3c62666e3fa4f69cd7bafa5753d56cfd21789d9f334497d5e374ba1c366feacda5cd8fdc438ce0dd1c438ec3b9935781f1e8bd759e65dc49d11f40b0f43e2720ba67cbeaac1a4295f8d67f85a2d18b6e810a827352c1aed6091da6e198a32279bdf8bade254231aee76168324c7930e6bf46930b89c157e945701b16aec9dfbd953ae95bba6d53add01f255f4dab9fd6001eeab7ea932e044efc7cfbe4a14bba5ac45a40840a8097e5333486acb8ac2277774e0f7f05dd272cd5d60fc29b93011e7e119b101bb74929b686c11776c19463857efeb90dfe5b21aa3c8258bd96692ffc1669a69cc01b9e9a46a3d136858c3c55ceb697b7f1eb2be757a06949a501fb9ce5c8c3b6205188524a3ecbbc07496b2a24739a4ad03f6b74d2ba132c59581a6acac739819e35fd2fd04ba3b2b11aab97a9d79f445d28c96e196eb02d427056b29a875283d358a48a82de977dc10b04ac5f107ba693af7d18c1b429ea7811cc279cc62230fdd4e3cf741cf1b962c138d3686048144409192d2ba38480a5423feecbd22598ef154b74077a36eb5635ab4be3d70d2588973004b93b5f73f237628c034cf5b6727fe30f75aea24faa22db3c3fd6230bc46b3936c7b49250f796a77347658739e3723a691e063e7a9e6e52331704c1d96eed053ba02deb081ca2e4c36405d6963565ee464d0e60129342cf7f59ed4130ee5dc62d05b84283719caaa4e74bd1c87cf486a94786f1cf12c100ae9998b152aba0d512ac27ad6ab05bf2e6d4fe7a91a2d4573e3d6a2b2baf8c96f9df9bf61be8e9471cdf768fc0b90ef134ce41d0947f99db9c9ef9abdd51dbcccfa8c78d1b2224efc12710e16d83e140c36bae4de9b01f22051a4851cfb10ff32b264b0076cd03804c8a244794951fbc4b17a8302dbb400ff8b49a2ef5f1c8badfc903bd2a5fe9b2a479c9a3cce0214b38741aed5efd534844f02c4589f40600ccdba20d26baff7cadc5adee08b7cc0a456d054694109022e4cdf05861184475ff13ed9108c2997a3c2bc50ac790e12e341db1589f9e9d1376568d827e426a44b2e20e93369d4079b32b1d8216d05530c6cc92307e5fee3e049287b4548b178a7c338c3e05460eac002cdb02ee86913aed07c465dfb59afe89e18eb810d4d7def312c411efe0c5399f9b3b57a01310f9e76440f7ec2c1041312be53c0a6c3a8c847c22562781cab0debb51b91e7db74458ddd305bd8d39e22298d20109625cc371d0a57f0e1a12b420af7c03d0b92db767bc56147ecf57612a2e38c64306f8bcc2db4d9de5e2bfb84ebef4da6d1e0e90fafcb862923374c49af6cee575e28a0acea09e5e5a2e5b52b1b8d5797ba4684e24b6525ffc0eb6a36f69b70c4127853e54785fa65887933373ea53cd806cc3eedfa1e644ca84964bc85ed71751513b0beb286c6315ebc0091c46970829383c6945dea64f914791fbe56dcaa5849cafe43b39c88b5e932476611361cd79c08f157e13d4f9a18f397297bd2915a1dcdb0f82e09f5351f507888576afd032398da911b8bdd40265c0245c2bf768f151ca4d5f8b9fa3d4fe41b70da71abf5b7e27fa7f2b2430ffaa710ea070ab1b6697a87e0c055ff7dfac8a7aebc6294e2ed14971dd7406f3fe57f8e97f8a1d80c7bd6b097283ed8a6e7a810b13313fed4dbd02d1893872d4589def04753a6a5527ebcacf9c7887d8ae08b5879fb7a113a16710b2a20feb72c7c636ab8c79b61c283284438f3546ff16f764c642181a32687f9b1d93c5273e38bf53ae11925120d75749df9aeebf3accb0544a82e42cfc101e38e1f5b25c61d2c437f381c133f07f3efc89a1b21e78b351762cabef0e3bd48018a5ee2780b0f6b05d1c958949d704388a61b3e3eae0ae5d44c1ac8eebf24a902bbef2cf9234d5c2c2d2564903988963436f61377aa684a613ceb88663892fac7b501a06fa5f62895797aef644348933e021a5addab6e4f29027894fac30f7546a1ead29224cb3a09fc6b6338b42264bc2fc3ed14a5d56f3df582ed662f3e7c9310631bc54fbd804fef9254b502ad01cbc59f9a2aa9b38bb59c460e80af57c2c7444dee298ba8a550eaddea82a1a97f8ef7f9a024839434ab63ca561b1185d8bda66dd454e2791446b3d51e7f6b3607bcb438913e40352f28e7f4c79594628b23d889faed94b84a1d7cb742c6917915da4f38b2c6c8f15b849782bf897823d71b8f31df70e2fc64db3a5ec4f294d3a946791925c92625b75cc58e0ca8422fc68093931720dd64262008228e1926af6fde29fe29b451fe02df9df8d1034613ed37027fc00d4ebe2ed782a0cb0bf5e2d07df45226ffdc0632072a73bd3b1edb7ae7b6ca8b3ef74283eb9409f66fd77dad5b72536a4e4acff2f5b9eec588265c84aba9be9b8000e4ac53ced38b573cf86bf26505b4bdd519755532a371b391ff518d69a297a0ae87c7f705b6392edb01bfcbc52e57a6a6bb379c8fb2f04d036bf5d9697d41458ec4d77ed9bc3f9eb856e72f770ca0fd17c19df97dba3b76c16f771096ebd883525f61d45d73cea22ee19dcff0fd62633dfcd5889a4e48ff5775aa9b49ab12c7678f05055eab29dd0917be214b165acc36aff247a2f565b847e7380cb9ccc45f2048f6b9f1caceb6e14c0d96ea92da5b68571a2c29a8c1f976fc03b6ec77d235c5f58e6ff261b47423ec6172f362bb5a46760e1d538de1ec9975862340dc13bfd3d991858eb806eeb44df6d04f75ac5288b3eaf57af2f924e98c20ead009303bfe78277f219da62ca9f02ed94c2f235852ac724dfd5454ed0076b473a5d03b2edfe20bf0dc3a956f168538832189d2de47b508dfd43df9f10971c147910459c70d961be8e9a9c375769d1bdc21b7fc1641a66975d31ddcb53042dd80e354830893eeed6bc6eaca8521283e8889aae198a2e6c262e4c46588b789d36b4ab0d20216f6c9a2a83635dc28238696ce68aad0893fa3290e551093b673ec3b585c78e5baf2456284c8ac207c654eea108da8e4230dc57db7d5d08a5e93815fc7662a7f87f8a6f0595a22f0786ffca1f164dd3f91b8060d133626ed9b22e6370ebbf3ec1d8cd2774876832b85084d9439198cf30a644deb0aee7c073678281d07515dba233459adbe35bbef7fe72af3f01c57aeb1a4485120f9d50982a1b7ea6f7466df1f9ec722fd417ff9ccefe312416ccc654b4cdd98571eba6d1f892dcf2008b4f7f820d311c7f9c692a223bf1b94728e0d15932315f74449aca05a3183ab0148176ea443d55e33224a9eceeac698962e1d34878ae9cbc8edf3345f0a4714ebf2d3036f3a2ae7955767f3888b1709224e000efa3771a4a097ba7f1eec134c728a5cc2fccac658388ce2073a4dd14b7e729b10b730b09ad72eba1021133b93e4bc53a327391f25831d663375316ee6fe011774d0d492183a24abf2fd61a709c2b43af96bd3d392b0afac7dd1a74688b6b8b1b282c190206474b44139d2a3d0a9ee44b3c482f3822168adb4900dbb4387b49fb481fc550a073cfa20fceb605ebdc58612365f2fc3da67492cc5fb14e850ada7d5fe1fe15135e8b0fc111bced4916feeffa1548a3f34aa5cf3c0aa2224720d88122b59fbb5eaee3ebf25c22a9ca6cafac7d07c8dee1128b1bbaedcb614335ae65b320087adfb96d1f41e01be7f67a7416d760529a14a052f5671eb0b105d65d40c723395e70a25fa01d90816939fd48aea3e56fe0503418808e65f4dc7e2481598339c5ff6090840d954287d751db1b7984c84a92ae458da2bc54fe3969c05eb0fea08939dc240a5de73a1ba687c7d48047c945930aeadebe5d436cf1a268b7f302960af66e633d81a418257e0d0e964d121fe76e01ee228bcf0aa304ca4c06b1d147c4e1858ad522673f6841f170f65b796f5ef2a0123f2fc27f98dc6181bbfabd8cfa1ca2f798d998a865bc5de7b0d4597ba8b6c803e4397c4870326fd5d98ed1b3c2695baa7b6477de327ad016c5500c082b55ef6250d89c8586135df11a4d8b6a03f417769a4e42279225c4b3a1be0df37c6e791ddeb93ad015b27291a791276b11e81f3dbed56f293c3691549404add7127c6a1b811277d2a35e7c48b7642cf76271456215f553aacebe93b16eeab77f9255ad32ce0165414109a0e14c50892fd5e78438eb9631c861c2381df0b4fbf40f8a48c501e29312832624f912994c9961973de7e641d5eccab5522d7e79f4aa6144a666c1e6279975e0a7b6edc02d556e25618af4d93355b78a418afe416d62ea0b44f69fd9a3e69207811b93accd34b951d08455b4714efc29a13168857054fefff016aa59e413030fbdad8af8039123fcf88830a512a8e50c3a674ec8396ae603d1819f851f0bcbd6cdbaa19158a6e76ec212ee7d3880c3f6a55226822d79559f96633201c7df35217b86088f4590481df5123c676e7ce06fa426b0bc440d67efa4a980496da8e10ff71a2715ef5ad6bc3af870b2d75364b75fd2e24b245f51a7e9d81bb65371ccefee24bcb79171d4390220600b3c052db21f805da1c7c1678cf294e18c16b87a5cc8d43b5cb5f267cc79f2332c61b54e4938c04ba532151e0ce645e1f41c7efe4e61a0b50c8ead21799ca4f5095385391073555a512cceef4dbf49a8b615f32e13564b560140b7354355775214f057c0edc41042da9b29767d0b26d8c9178b8cd20c1200da88055e0f09fc56c271d453bfc26909d8a6f5bc16e0460d10829e44e07979202ce622acf58d048fae00cf9b91dadfe2dd3cf5749d8dec9fa91623c8fc02f10c574dbafc7167a82d29613b7b28d9afcedb714208fe1b3f3be66c7c68d65f49c5c94af8fab338dc772bdc13ca45657b8c4f47842eb7e6abadf58a564398bca8d2316791a32fe22d0b7dae788032e5cdc1468953f262660c34d34f068f0bc1aae2db4494d4d4f90e37e64f7d01b4763dde9bd5ee9abbd0dac670df1eeea6336e88301477e8165cf32c8e93bb0d7fd3e83a56519d7d4f49d15cdea5bc25d6ea0cc611556ac55d734490a296167cfb229c288916fcb8d905ea5da9743a38248955b9730439ef60f7af6a8acd9a9451b44fef5330465d6de0bf7eb28b05e0a47e33d7a2bb0d16c6ba3149022fd562fb7c68b665913820790f55ac90f40425643b032dfe3798b4a61e87d7676d908f2454f0e1f5016f816a53c45e4b7c7a0d572a95e8e7f08c35b07acc40eb5226c2ceed7fc14320094cfe4f836c9d626ed68a7c9dbe77a678d2b1888a88b2e2b36cffa5d2b6f624183276fc13d77f6f2c3e9d5ea450c65e7c5032e350d48740dbf68b8bfca35f2389bb17a33afcaaa84fcb760cc17bf323d3df0620a7874ca0feee3af50e639f08c763e446b7e6942d0e7955ec60cbc551efd9559d49f74289e1e87720b59b798c9b8f57c975aebff0b32cbd3e01601a21f56237d070ee9d2591fb9d783e8276682c6c05ead02ef09d70379cba2b4b714a3f48f055b6ff04711324f153a33d600b754803afe6b2b4c13db3f8053093862109e0177337fbe4c9d05ecbd01b500d0e657c08070d921712e794d1536f6317bbf5759a4de8b0b9f391085e413d9165b053bdb72c0eeda909f81e392f9008c496814b829aed55b8b428f1bdc0c6d7a31e67b17eba3c45c934579a2b6ba678ffe075d84d3180d41a4009e1a2cebff96008ea778751bfbc49a528fed46542e5e3e39318dc3996a76b631ea9fcbe1a6a0a223f194c409cc908da3423e399e3b4098cfb384664714f4d2d13efadbc9536a10918350fc404604bd0bfd29c032bdbbd8c5705063f8dde4a09338d65a61edc37706a19799aac59f0347c0fefeaf0fe1566b55b3f7f9306e1eab9e006600b7deaaec4d7a66aa5ad332f0a4d09836598c5202faaf3209bc1f9101adcfa509e0d2f7dfdc87dbe431f15bd9b7069b277d62ece5a498bb3d5b6ee12ee085dafa2b58ad63d195175d3495e23bfc5f732c94ed05fc5a4fff24971aed21901df35c5db086abe478277f23df209c4c247f05507f08d0c533619a4c68b441f6013596f74ea8ae2f0703a37c37245e3e4944a4b2bbdfbdd104b4f15f7d027eb9d04210f21f284857ed6a485af5322519651451ff50fc7dd34900fe41eb8bf64b75d71747cebd302427a7f5806df5a5b6b70f3adc7fb2391463c3eddda27f5b35dc1b6d94fc31401a5b52363aa46aaea7e7991b6cfa68f575d40a0c7e11cd5425dcab52ba07a2d326ccde5cf6bdcd3679da00257d3556c901d35504b57edd5ac4a6dc55b6512a4113ee30d41965819ae615affa92c06f131af61aae6349d9ca5cfb2d96a6e92a33dbad8a0e73c2defba40b8a5248776bb81c2a6c582e94bda8c89b7a2f0af9cfc374de12487a75690b0384bbf2a4ecbb6e45c60fdb85ed4cb3c4b62a4701d854fb4d308a94052de4b90cc5a5faf247b05687d968b2c4dfb9a85af5eef515c454c5e8d2fa44edb06bfc1663b580cb90b4cf53132923a5eb9f27a6f6fb03c31a0e0135fe74fcd7d4936a3f653394e878617a3ae539bc4a34e83c3712b21ed9f82bc3b878eeff356d1d588545857c8b1745a697e4e6925370e4c2afec145d6e542280409ae5323ea558256b4a24ce142f30b9ba28fc8659f0be2797ad5f90f440cd658f4d6d056261f5c7e1307ebfacd6c8aeace9a59af434a841a9b27b791481398d2d7674a745bc6a0efecf24b8e2a7fd31657cddaa88d6ad0bfebb5f31031d3ec77dd2d71013df69433ebb65af7c4f3f5c52e7d5223c4afeac8ed6dd3a4292dfd06aef1f6fbc7f7a59e10fec2fe4983112612faeb31549b3e89cf6fc4d6ec2b1389a9158214157f20b75083986df725ce63bd0ee79ca56cb58d730566be44bb41de8ee4626303698764972d15ed9a6329b58ca820a478ebb50c195a832bb613e2f475d7342d9b4b66a363a2292812a137a65cc9346b78af82b6ee8aecb33f00621dbbdfa28334f69a4da0eee7eed4e34afe5f552d4cede40b6954e1f5d53f43a4ec2107567cf9dfaba2ccbd16af1d4243e92d7c7b45aa92e595f832bb34473f33de89cea25025e888a665bd07e5a73d4d736ba664d02c9c9cb64396863862d7c8dc41200d211871a80f95ba2f9124676825ead2ad4e8a550841244dfaa6503a883fa15559e22dd88ef65e23454b209f33006661eaa615724be35fff9e72edd99cb2ad568bf732d9f2e239974d3540cfb9f974184f23766b434052a4b9fdb573fc62b2dbf35ed2f82dd6f8d2c0e3919bfa0285adf2d717381b393d0809fcac8c7b772abe2ccf0662775da654a35943177d7383572f0b645681f3fd005b45d470c966924c030edac4f906754a28f3b325e6ffac8fefb5257a4eeb7a72e01b90cb05b90579c316b65ae9636e17089e7e50cb7d1d2e7ece39ccb7d516563ec6e4cccc27c915b59332b957f8de2f4b8c3ca34522483485891618478e099cc1e68a9a7983f21112f0f911354896396a1f7e97d6c36ea390936f0030dc5d906cf3ef1d576b7a2a8ce1a38259cc5998dbc75d2199fa6429e550ccaab3ea9079ae40900aa504e169c8840f02266b70a9234576030d9215a78f2c7fd8c5b406f8e17c450aab03916348e6fe44f64725aa0207c5b15d3a6abc7c0018b37fc6b43217c65ca33f89a7cdead7552e60c7c911301e8de740f1bf581c353cd9569be3944a3c2099571937b082a257382c961e014ff3a2436bf95c8f9934a55432db7a852e4fc1375b127141a00f513fe44056e871d8b0fbbd6d5b26258ed907a3634047af96b0feddc479d7e1385dea6b19f8165402144ce7ad970e12b1527ff63beda1e191dc43ddcebbd05f505b10d0a7fd80802487d3cef1b2eaa11aa18a0b661be4924ab452c9a9ec8c0c07cf2a08740eb4fcffb73b4c2c9c46af77293068053441b22580c1ced4164e8527ba6da35f27f16602a863c7a353a7e31b40c8bdc24bfacaf9442426e55083f1f195dc2e4f373fc3b04fc65a6605c6ba8aaec4f4803fdd596b540a23d7b5a7c24faa75255f4c4b61d4a3a06bbfabda0040e2ba5aa5d2faa7c5f0203afde1c5e0e6c418d58049c6825ddbdf984e043c3618021303ce2ccbcfa06de3ad008d3cd4f5ea87d963d68cb0c19953ae21290f736ad9147beae91c0474aa829d5b98188a03c47818893ede109caea6fd69bdce97cab0619b02a4f6ee8f6bfa8e62b36b36edd26d5e3f2115caf4ab2766865cdcc1006d44f125a34a91fc22750d1f0e33d62f21f62feca5498c57f482c7e51df02bc8a6278dc8343399ae103c68be56c9290ffe6d1712ef36088c5993686a7a7a57e377803554c69f4c2475cf99b778e3b3f6b11bbf7947380762b9bd93268f2540ec5d0f46675b808f5d8bcb6d91a5b338ec015ce9eb3f92a794ee9ebf03b0cf2902f30dce13a1d7baa6a8505fabdc7a1c9e20ec6a2c83f74aea4a4fe602aed272fa0d3c6f557607fb6ece2d32e8deea04f9a2326ae3b33a399583f3f76ebdab982194d956483144346394a8d0f8518c8d89b8c93cbee74f9cafd5fe718a7debbcdc936ca4011cd11b5f6f436f1c7fc6940fc0c1ec8b4295a523753ebcb94c365c1121fbde741b6a0ebaea6840da5d900a88a27a76445d15b24706186fa730195da5dbe0c7a2594c6aeb995675e5b3ac8ea903cefea6d46abb156c6b839111e4f7fd78d0860a2428cb7a1ce491beccfb2a248567ffea98c87f2845acd0f58bc83dfafb50d6097f882df507fb651335ac09f820fa7bb7a800734719ac947e44d9c39f28867a492854863d57e9f22bf6780504227a29c811c349e0290ff6cd327008a94e17949aa416a8cc518d576a82a971f0c631b9e0c1400f8a1546a66d7448ec7d5e7111b4468dbdf1e415602cf7d75009dc90ef3d4571b7ca8a5b81a7f416fb6b987991d0d6b5fc70e4425c3f1a96aaf454cebff82d9dc662f155b0924e16a4e4ed10e596f6bf23b39df2bd8c23a9a01b4b93fd4624b7ff3d1c2bae24436ff3b7ef31ce2bd4b2415403ca03e46554dee1ff6159804ca5a2e1e3c0ff63c52de2b511a343f10ffe7f6bfa3ffbd0ab1246a98b9dc8d50d8019b1cf00b8f6eec4528f3881d96b64be718bba6373633a5e4bdc5022acf319c7c95ad01f6700b49eee793c34b99e3b853bf7a0f75c22d02f73106b944c776d21c3685be4280fa099ec20fbefff571f0e8e863a0bc389106e63f75bded50361a63b5ec6bb8db0d8d2854c303f3da5e50c47ce0ff9fbc939a3ea440b01bab926d99484a0d6f1eee51eca5009c037f8defdd703eb3dde524c755e92ae7996bc54dcd3787c9633b6ec500ea43486ce39d886622c8b53960bd4914790cebf41e82e370ec19155aaefc0876c64de1a71177dedba2e298cf3ebc4a8b50a3f25dab98bf5104669a574bf73211ca846c31e17f947fd87a01d412c4ecb82ed48c66482b48cc652b9fcf6e93c77b4b0229b423500d59c47acf09696578454dac79d2d519549545379ec71ee954992b359cbe8eee6b5ad602ac16896103b161a31ad1683798e919b0e8bdda5b840de671280c2d111b8245fe967ef4c2035de845e4908892cd9cbfb575ad87f06b13738ad5e13b39bdacaa0c6230aa0b81c7fa05884edb72f5cd0046901133244f157bb3e1f454ed2a44dc1e2a8489c7de462e98344d76b934db99050680ff7dbc7eaf93717f72f85f19792d3cc0b702afc52cac611091175fd34c30c342bcd3c056b8da26c4932023cdb6fa0ca2aa93a953e80cfcea80640fa7673e117e2398d58c4d2369fea851f5ce8827da7705e6858faed6b0499d7066a713fd7eda45b7894981ff1c6bc13f1517426b9cb5eeee0c5193a04258ee29d22435e23f0be7fac9fc0d36047f1f8cc282cd2566b71ccabf97f652f8b138</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>BJOI2021 游记</title>
    <url>/2021/03/BJOI2021-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>人还是很菜的，就是来打打酱油。</p>
<p>NOIp 成绩卡线进了 BJOI，那就来看看吧。。</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>看了看通知，貌似是 3.20，3.21，3.27，3.28 四天有模拟赛，然后 4 月份正式考试。</p>
<h1 id="Day-1-3-20"><a href="#Day-1-3-20" class="headerlink" title="Day 1 (3.20)"></a>Day 1 (3.20)</h1><p>上午模拟赛。9:00~12:30。</p>
<p>T1 一眼看出来了，十几分钟敲完了。</p>
<p>T2 感觉不太会，先去码 T3。</p>
<p>T3 直接大力上 DS，写了一棵平衡树和一棵动态开点线段树，感觉能有 $80$ pts。</p>
<p>然后去看 T2，感觉这 $80$ 分是一个很傻的 dp。</p>
<p>写了写，自己手玩了几下，感觉没啥问题。</p>
<p>这时是 11:30，很幸运 DS 没怎么调试就过了样例和手玩的一些点。</p>
<p>然后小恐龙了一下，不小心忘关声音了引发全机房的笑声。。。</p>
<p>想了想觉得要写个对拍，于是开始写。</p>
<p>先写 T3 的：我用平衡树和动态开点线段树互相拍，拍了几百组没错，那应该没事了。</p>
<p>然后拍 T1：诶诶诶怎么错了？？？</p>
<p>我不停地缩小 gen 的数据范围，然后开始手玩。</p>
<p>诶为什么我暴力写挂了？？？</p>
<p>改了一下暴力，拍了几百组没出错，感觉没问题了。</p>
<p>估分 $100+80+80=260$。</p>
<p>然后去小恐龙，拿到了我自己的历史最高分：</p>
<p><img src="https://i.loli.net/2021/03/20/T6cjuy95NAmGptE.png" alt=""></p>
<hr>
<p>中午吃了个饭，感觉味道还不错。</p>
<hr>
<p>下午发榜，讲题。</p>
<p>我 T3 怎么挂成 $50$ 了？？</p>
<p>但这样怎么还有全场并列 rk8，我校 rk1？？？</p>
<p>就离谱，看起来这次考简单了，大家都会 $260$ 的样子，但是就是比谁挂分挂的少。</p>
<p>如果考难了我直接暴毙，毕竟还有好多省选的知识点没学。。。</p>
<p>而且感觉这次有些神仙在演戏。。</p>
<p><img src="https://i.loli.net/2021/03/20/yRo5XGPNlFMwf8n.png" alt=""></p>
<p>（图片里的 rk1 是 std）</p>
<p>讲题时：</p>
<p>第一题</p>
<p>老师：这位同学你来讲讲这个部分分是怎么写的</p>
<p>同学：老师我是挂成这个部分分的</p>
<p>第二题</p>
<p>老师：这位同学你来讲讲这个部分分是怎么写的</p>
<p>同学：老师我是挂成这个部分分的</p>
<p>第三题</p>
<p>老师：这位同学你来讲讲这个部分分是怎么写的</p>
<p>同学：老师我是挂成这个部分分的</p>
<p>老师：。。。</p>
<p>这说明了这场比赛的挂分之惨。。DS 还是不要随便莽。。</p>
<p>听讲评的总结：T1 本来就会，T2 听了有点懵，T3 听了不懂。</p>
<p>估计之后的题不会这么简单了。。。</p>
<p>发 result.html 后：我 T3 Treap 数组开小了，<code>score-=15</code>。</p>
<p>至今不知道另外 $15$ 分怎么挂的。</p>
<hr>
<p><strong>upd：</strong> 另外 $15$ 分挂在动态开点线段树 <code>pushdown</code> 空节点。</p>
<hr>
<h1 id="Day-2-3-21"><a href="#Day-2-3-21" class="headerlink" title="Day 2 (3.21)"></a>Day 2 (3.21)</h1><p>心态爆炸的一天。</p>
<p>T1 一看：要建个图！</p>
<p>于是尝试了各种建图跑网络流、二分图匹配、最小点覆盖、最大独立集……的方法。</p>
<p>然后没想出来，直接心态爆炸，写了个暴力就滚了。</p>
<p>T2 T3 因为心态爆炸，连暴力都没打。</p>
<p>最终得分：$20$。并列 rk 57，我校 rk4（我校菜）。直接暴毙了。</p>
<p>绵羊 $90$ 分 orz。他 T1 写了个堆优的 prim 结果比不加堆优还慢/fad</p>
<p>等等，prim？？？</p>
<p>你告诉我这玩意是最小生成树？？？？？？？？？？？</p>
<p>我建图方法都想好了，然后直接滚去网络流……</p>
<p>我是**</p>
<hr>
<h1 id="Day-3-3-27"><a href="#Day-3-3-27" class="headerlink" title="Day 3 (3.27)"></a>Day 3 (3.27)</h1><p>第一题什么阴间题啊，扔掉了。</p>
<p>第二题果断先暴力，$12$ pts。</p>
<p>然后去搞第三题。</p>
<p>首先理解错了题意，以为这个函数需要是连续的，推了亿会式子之后发现这玩意定义域是 $\mathbb{Z}$。</p>
<p>于是果断爆搜啊（枚举每个点的纵坐标）！然后随便手搞了几组数据，调了一些错。纵坐标我枚举到了 $yp+C$ 来保证正确性（这就是找出来的错之一），复杂度不太对劲，但显然跑不满。说不定能拿到 $20$ pts。</p>
<p>然后发分，我 $0+12+20=32$，rk37，我校 rk1？？？</p>
<p>而且 T3 $20$ 分的全场竟然只有 $3$ 个？？？</p>
<p>离谱，是不是大家枚举没枚举够啊。。。</p>
<p>然后发现 T1 的某些部分分很傻，白给了。。（例如 $m=2$ 的部分分）</p>
<hr>
<h1 id="Day-4-3-28"><a href="#Day-4-3-28" class="headerlink" title="Day 4 (3.28)"></a>Day 4 (3.28)</h1><p>EI 场必有数数题。</p>
<p>结果你 ** 给我 $3$ 道数数？？？？</p>
<p>首先看 T1。</p>
<p>瞪了一会，想起了幼儿园排列组合的插空法，推了推式子，写了写逆元，切了。</p>
<p>然后去打了一下 T3 的最裸的暴力。</p>
<p>然后看了看 T2，想了个 $O(n^4)$ 的诡异 dp。</p>
<p>写完之后发现假了。</p>
<p>最终得分：$100+0+5=105$，并列 rk43，我校还是 rk1？？？？</p>
<p>另外两个写了 T1 正解的我校同学都挂了。他们逆元没处理到 $0$。。。</p>
<p>不过一绵羊挂成 $70$，registerGen 挂成 $50$，因为绵羊写了个按数据点分治（</p>
<hr>
<h1 id="Day-5-4-10-考试日"><a href="#Day-5-4-10-考试日" class="headerlink" title="Day 5 (4.10, 考试日)"></a>Day 5 (4.10, 考试日)</h1><p>直接自闭。</p>
<p>T1 先写了个假贪心，大样例虽然很水还是没有过第三个点。然后写了个暴力。</p>
<p>T2 先写了个高斯消元，然后啥也消不出来，最后写了下 $m=2$ 的点。考试结束前一小会 $n,m\le 3$ 的点稍微骗了下分（估计骗不到，毕竟这玩意随便卡）。</p>
<p>这是 $n=3,m=3$ 的特判（$n=2$ 的就不放了）：</p>
<p><img src="https://i.loli.net/2021/04/16/gGrzn4Yva9KLEl1.png" alt="离谱的骗分"></p>
<p>T3 只会打暴力。</p>
<p>估分：$20+30+16=66$。</p>
<p>出考场发现大家都多多少少打了一些其他的特殊性质。。感觉我人要没</p>
<hr>
<h1 id="Day-6-4-11-考试日"><a href="#Day-6-4-11-考试日" class="headerlink" title="Day 6 (4.11, 考试日)"></a>Day 6 (4.11, 考试日)</h1><p>还是自闭。</p>
<p>T1 先写了个暴力。然后想了半天搞出一个 $O(nm\log n)$ 的奇怪做法。于是开始写了之后发现它的空间也是 $O(nm\log n)$ 的，显然开不下，于是暴毙了。</p>
<p>T2 打爆搜，$O(n!\times m)$，结果发现连 $n=8$ 都过不去，真奇怪。。</p>
<p>T3 先写了个 tarjan，然而还是没什么用。于是还是向暴力低头。</p>
<p>估分：$25+25+10=60$。</p>
<p>出考场之后发现绵羊 T1 写了一条链的情况，结果和我放在树上 $O(nm\log n)$ 的做法一毛一样。。。但是写在一条链上简单很多，我是**。</p>
<p>T2 可以不带 $m$。。。枚举全排列之后贪心即可。。。而且带 $m$ 的同学也没一个跑的比我慢。。。我是**。</p>
<p>而且 T3 的 $m=n-1$ 的点一定是树。。。我没看见 $1$ 一定能到其它所有点。。。我是**。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次省选就当观光了吧。</p>
<p>人人打的分都比我多。</p>
<p>坐等出分。</p>
<p>另外某些民间数据纯随的真的水。。。我 T1 直接 $100$。。。</p>
<p>就离谱，然而 CCF 显然不会干这种事。</p>
<p>总估分：$20+30+16+25+25+10=126$。</p>
<hr>
<h1 id="出分"><a href="#出分" class="headerlink" title="出分"></a>出分</h1><p>挂分了，挂了 $-90$ 分。</p>
<p>实际得分：$90+50+16+25+25+10=216$。</p>
<p>T1 真就直接过，然而最后一个点被卡常，洛谷上最后一个点 $&gt;900\mathrm{ms}$，所以懒得申诉了。</p>
<p>T2 的骗分真就过了呗。。。这显然随便卡啊。。。</p>
<p>CCF 用脚造数据。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次 Div3 AK</title>
    <url>/2021/02/%E8%AE%B0%E4%B8%80%E6%AC%A1-Div3-AK/</url>
    <content><![CDATA[<p>这是人生第一次 AK Div3。</p>
<p>比赛链接在<a href="https://codeforces.com/contest/1490" target="_blank" rel="noopener">这里</a></p>
<a id="more"></a>
<p>这是最后的榜：</p>
<p><img src="https://i.loli.net/2021/02/18/PCT2w19y5roLbZf.png" alt="image.png"></p>
<p>可以发现：我对简单题的思考有很大的欠缺；而且罚时动不动爆炸，经常心急。</p>
<p>下面一道题一道题说。</p>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>题目中定义“密集的”序列是序列的任意相邻两数中，大的除以小的小于等于 $2$。</p>
<p>发现题目范围中 $a_i\le 50$，我们对于那些不满足题意的相邻两数暴力的在中间加数即可。具体来讲就是不停的加入 $\min\{a_i,a_{i+1}\}\times 2^k$，直到 $\frac{\max\{a_i,a_{i+1}\}}{\min\{a_i,a_{i+1}\}\times 2^k}\le 2$ 为止。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n,a[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx=max(a[i],a[i+<span class="number">1</span>]),mn=min(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">while</span>((mx+mn<span class="number">-1</span>)/mn&gt;<span class="number">2</span>) &#123;</span><br><span class="line">                mn*=<span class="number">2</span>,ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>我们循环按题意模拟两边即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        <span class="keyword">int</span> c[<span class="number">3</span>];</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>) c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            c[x%<span class="number">3</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,anss=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> x=n/<span class="number">3</span>;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">if</span>(c[i]!=x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i]&lt;x) ;</span><br><span class="line">            <span class="keyword">else</span> ans+=c[i]-x,c[(i+<span class="number">1</span>)%<span class="number">3</span>]+=c[i]-x,c[i]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">if</span>(c[i]!=x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i]&lt;x) ;</span><br><span class="line">            <span class="keyword">else</span> ans+=c[i]-x,c[(i+<span class="number">1</span>)%<span class="number">3</span>]+=c[i]-x,c[i]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        anss=min(anss,ans);ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>因为 $1\le x\le 10^{12}$，因此 $a,b$ 不会超过 $\sqrt[3]{10^{12}}=10^4$。</p>
<p>所以我们枚举 $1\sim 10^4$ 这些数的三次方。把这些三次方数扔进一个 <code>set</code> 里。</p>
<p>然后对于每一个询问，我们遍历一遍 <code>set</code>，看看这个数减去遍历到的数是不是在那个 <code>set</code> 里面。如果是的话，这个数就可以表示成 $a^3+b^3$ 的形式。如果遍历了一遍都不是的话，就不行。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i,<span class="number">1</span>,<span class="number">10000</span>) s.insert(i*i*i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=s.begin();ii!=s.end();++ii) &#123;</span><br><span class="line">            <span class="keyword">int</span> qwq=(*ii);</span><br><span class="line">            <span class="keyword">if</span>(qwq&gt;=n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> rem=n-qwq;</span><br><span class="line">            <span class="keyword">if</span>(s.count(rem)) &#123;flg=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flg) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>题目给了一棵二叉树的中序遍历，让我们求出所有节点的深度。</p>
<p>这不大水题吗？？考虑分治，每次找到范围内最大的数拎成根，更新答案，然后从这里劈两半继续往下处理即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>],ans[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;ans[l]=dep;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,id;</span><br><span class="line">    rep(i,l,r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mx) mx=a[i],id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[id]=dep;</span><br><span class="line">    solve(l,id<span class="number">-1</span>,dep+<span class="number">1</span>);</span><br><span class="line">    solve(id+<span class="number">1</span>,r,dep+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        solve(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>首先一个人肯定有机会打败 $a$ 值 $\le$ 他的人（因为 $a$ 值相同的话是随机打败，总之有机会）。</p>
<p>因此我们先将 $a$ 数组排个序。</p>
<p>打败完了这么多人之后，我们设这个人位置为 $x$，他现在的 $a$ 值变成了所有 $a$ 值 $\le a_x$ 的人的 $a$ 值之和。</p>
<p>然后他打败了这么多人后还有机会接着向后打败，也就是说，如果现在这个人的 $a$ 值比后头一个人的 $a$ 值大，那么就可以往下继续滚雪球。但如果遇到当前 $a$ 值比后一个人的 $a$ 值小了，这个人就打败不了，后头的人也打败不了了。</p>
<p>也就是说我们肯定要先做个前缀和。</p>
<p>一个人要赢，肯定就是要打败所有人，意思就是他滚的雪球要滚到底。</p>
<p>所以我们从后往前推，如果说哪里遇到当前的前缀和比后一个人的 $a$ 值小了，那么就 <code>break</code> 掉，因为再往前的人都打败不了这个人了，雪球滚不下去。否则就继续循环。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">bool</span> ans[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">200005</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; summ,nxt;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        summ.clear();nxt.clear();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) ans[i]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) b[i]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].first);</span><br><span class="line">            a[i].second=i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+a[i].first;</span><br><span class="line">            summ[a[i].first]=sum[i];</span><br><span class="line">            <span class="keyword">if</span>(a[i].first!=a[i<span class="number">-1</span>].first) nxt[a[i<span class="number">-1</span>].first]=a[i].first;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[a[n].second]=<span class="number">1</span>;</span><br><span class="line">        nxt[a[n].first]=<span class="number">0</span>;</span><br><span class="line">        per(i,n<span class="number">-1</span>,<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(summ[a[i].first]&gt;=nxt[a[i].first]) ans[a[i].second]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> qwq=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i]) ++qwq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,qwq);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i]) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>一句话题意：给一个数组 $a$，我们要任意画一条线 $C$，使得出现次数比 $C$ 多的数的出现次数要删到 $C$，出现次数比 $C$ 少的数的出现次数要删到 $0$，问所有划线的方案中最少要删多少个数。</p>
<p>首先我们先离散化一下数组 $a$，这样 $a$ 数组中的数可以扔进一个桶 $bin$ 里。</p>
<p>然后我们对这个桶数组进行排序（也就是将所有数的出现次数排个序），然后跑个前缀和。</p>
<p>由于所有数最多出现 $n$ 次，因此我们画的线 $C$ 一定不超过 $n$。那么我们可以枚举 $C$，对于每个 $C$，在桶中二分找到第一个 $\ge C$ 的数。在这个数前面的就都删到 $0$，删除次数就是个前缀和；在这个数后面的就都删到 $C$，删除次数就是用前缀和相减再减去这些数的个数 $\times C$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>],b[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> bin[<span class="number">200005</span>],sum[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line">        sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> nn=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) a[i]=lower_bound(b+<span class="number">1</span>,b+nn+<span class="number">1</span>,a[i])-b;</span><br><span class="line">        rep(i,<span class="number">1</span>,nn) bin[i]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) bin[a[i]]++;</span><br><span class="line">        sort(bin+<span class="number">1</span>,bin+nn+<span class="number">1</span>);</span><br><span class="line">        rep(i,<span class="number">1</span>,nn) sum[i]=sum[i<span class="number">-1</span>]+bin[i];</span><br><span class="line">        <span class="keyword">int</span> anss=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        rep(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">            <span class="keyword">int</span> id=lower_bound(bin+<span class="number">1</span>,bin+nn+<span class="number">1</span>,i)-bin;</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span>(id&gt;nn) ans=sum[nn];</span><br><span class="line">            <span class="keyword">else</span> ans=sum[id<span class="number">-1</span>]+(sum[nn]-sum[id<span class="number">-1</span>]-(nn-id+<span class="number">1</span>)*i);</span><br><span class="line">            anss=min(anss,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p>题目用蜗牛爬井解释更好理解一点。</p>
<hr>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一只蜗牛在从一个井里往上爬。初始时它所在高度为 $0$。</p>
<p>他按照序列 $a$ 不停的爬着（序列 $a$ 长度为 $n$），每次爬的时候，他所在高度都 $+a_i$（$a_i$ 可能为负）。爬完 $n$ 次之后又从 $a_1$ 继续爬。</p>
<p>有 $m$ 次询问，每次问蜗牛爬到高度 $x$ 最少需要爬多少次，如果蜗牛会一直爬下去不停下，输出 <code>-1</code>。</p>
<hr>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑把蜗牛在一次循环内能到达的正数所需的最短时间扔进一个 <code>map</code> 内。换句话说，我们想知道蜗牛在一次循环中到达 $x$ 最少需要爬多少次，只需在这个 <code>map</code> 上 <code>lower_bound</code> 一下 $x$ 就可以了。</p>
<p>然后显然还需要存一次循环总共蜗牛会移动多少，记为 $k$。</p>
<p>那么我们对于每个询问，先在 <code>map</code> 中找一下第一轮能不能到。</p>
<p>能就直接输出，不能的话分两种情况：</p>
<ol>
<li><p>如果 $k\le0$，那么蜗牛一定会永无停息地爬，输出 <code>-1</code>。</p>
</li>
<li><p>如果 $k&gt;0$，我们可以找到一个循环的次数 $w$ 使得 <code>map</code> 中最高的 <code>key</code> $+w\times k\ge x$ 。这个时候就是 $x$ 第一次被达到的时候。</p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tim;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        tim.clear();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>,mx=<span class="number">0</span>,mxid=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">            row+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(row&gt;mx) mx=row,mxid=i,tim[mx]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator ii=tim.lower_bound(x);</span><br><span class="line">            <span class="keyword">if</span>(ii==tim.end()&amp;&amp;row&lt;=<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"-1 "</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ii==tim.end())&#123;</span><br><span class="line">                <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator lst=tim.end();--lst;</span><br><span class="line">                <span class="keyword">int</span> ned=(x-lst-&gt;first+row<span class="number">-1</span>)/row;</span><br><span class="line">                ii=tim.lower_bound(x-ned*row);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ii-&gt;second+ned*n<span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ii-&gt;second<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>赛后总结</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF240F TorCoder</title>
    <url>/2021/01/%E9%A2%98%E8%A7%A3-CF240F-TorCoder/</url>
    <content><![CDATA[<p>考虑开 26 棵线段树。每棵线段树维护它对应的字母在这个字符串中的出现情况。</p>
<a id="more"></a>
<p>然后我们考虑，什么样的区间能转换成一个回文串呢？</p>
<p>这个区间中，出现的任何字母的出现次数<strong>要么都为偶数，要么只有一个奇数，其余都是偶数</strong>时，这个区间可以通过字母重排变为一个回文串。所以每棵线段树都需要支持区间求和以查询区间中特定字母的出现次数。</p>
<p>如果可以转换，怎么让这个区间重排之后字典序最小？</p>
<p>思想：字典序越小的字母，我们优先把它放前面就可以了。</p>
<p>具体来说，如果字母的出现次数中有一个奇数，那么先把出现了奇数次的这个字母单拎出来扔到中间。然后，为了保证字典序最小，我们从 $a$ 到 $z$ ，从两边到中间放即可。对于每个字母，一边放一半。因此我们的每棵线段树需要支持区间赋值的操作。</p>
<p>具体见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> sum,tag;</span><br><span class="line">&#125;t[<span class="number">26</span>][N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    t[tr][p].sum=t[tr][p&lt;&lt;<span class="number">1</span>].sum+t[tr][p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[tr][p].tag!=<span class="number">-1</span>) &#123;</span><br><span class="line">        t[tr][p&lt;&lt;<span class="number">1</span>].tag=t[tr][p].tag;</span><br><span class="line">        t[tr][p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag=t[tr][p].tag;</span><br><span class="line">        t[tr][p&lt;&lt;<span class="number">1</span>].sum=(t[tr][p&lt;&lt;<span class="number">1</span>].r-t[tr][p&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*t[tr][p].tag;</span><br><span class="line">        t[tr][p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum=(t[tr][p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-t[tr][p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*t[tr][p].tag;</span><br><span class="line">        t[tr][p].tag=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[tr][p].l=l;t[tr][p].r=r;</span><br><span class="line">    t[tr][p].sum=<span class="number">0</span>;t[tr][p].tag=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        t[tr][p].sum=(s[l]-<span class="string">'a'</span>)==tr;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(tr,p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    build(tr,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    pushup(tr,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=t[tr][p].l&amp;&amp;t[tr][p].r&lt;=r) &#123;</span><br><span class="line">        t[tr][p].tag=val;</span><br><span class="line">        t[tr][p].sum=(t[tr][p].r-t[tr][p].l+<span class="number">1</span>)*val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(tr,p);</span><br><span class="line">    <span class="keyword">int</span> mid=(t[tr][p].l+t[tr][p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) modify(tr,p&lt;&lt;<span class="number">1</span>,l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) modify(tr,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,val);</span><br><span class="line">    pushup(tr,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=t[tr][p].l&amp;&amp;t[tr][p].r&lt;=r) <span class="keyword">return</span> t[tr][p].sum;</span><br><span class="line">    pushdown(tr,p);</span><br><span class="line">    <span class="keyword">int</span> mid=(t[tr][p].l+t[tr][p].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=query(tr,p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) ans+=query(tr,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"output.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;n,&amp;m,s+<span class="number">1</span>);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">25</span>) build(i,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">int</span> tim[<span class="number">26</span>],odd=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nedod=<span class="number">-1</span>;</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">25</span>) tim[j]=query(j,<span class="number">1</span>,l,r);</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">25</span>) <span class="keyword">if</span>(tim[j]&amp;<span class="number">1</span>) ++odd,nedod=j;</span><br><span class="line">        <span class="keyword">if</span>(odd&gt;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">25</span>) modify(j,<span class="number">1</span>,l,r,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(odd) --tim[nedod],modify(nedod,<span class="number">1</span>,(l+r)&gt;&gt;<span class="number">1</span>,(l+r)&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> nl=l,nr=r;</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">25</span>) <span class="keyword">if</span>(tim[j]) &#123; <span class="comment">// 从两边向中间放，一边放一半</span></span><br><span class="line">            modify(j,<span class="number">1</span>,nl,nl+tim[j]/<span class="number">2</span><span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            nl+=tim[j]/<span class="number">2</span>;</span><br><span class="line">            modify(j,<span class="number">1</span>,nr-tim[j]/<span class="number">2</span>+<span class="number">1</span>,nr,<span class="number">1</span>);</span><br><span class="line">            nr-=tim[j]/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">25</span>) <span class="keyword">if</span>(query(j,<span class="number">1</span>,i,i)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,j+<span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF323C Two permutations</title>
    <url>/2021/01/%E9%A2%98%E8%A7%A3-CF323C-Two-permutations/</url>
    <content><![CDATA[<p>话说这题怎么评到黑的？？</p>
<a id="more"></a>
<p>我们可以把第二个排列中的数在第一个排列中出现的位置都处理出来。</p>
<p>然后对于每个询问，答案就变成了第二个序列中 $[l_2,r_2]$ 这个区间内，在第一个序列中位置处于 $[l_1,r_1]$ 的数的个数。</p>
<p>我们以第二个排列的下标为版本，以对应的第一个排列中的位置为下标建立一棵可持久化线段树。</p>
<p>具体就是扫一遍这个序列，对于序列中的每一个数都在前一个数的基础上新建一个版本，以这个数为下标在这个版本上 $+1$。然后答案就是版本 $r_2$ 与版本 $l_2-1$ 中询问 $[l_1,r_1]$ 这两个区间的区间和做差。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],tmp[N],m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,ls,rs;</span><br><span class="line">&#125;t[N*<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> rt[N];</span><br><span class="line"><span class="keyword">int</span> lst=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x+lst<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> q,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    p=++tot;</span><br><span class="line">    t[p].ls=t[q].ls;</span><br><span class="line">    t[p].rs=t[q].rs;</span><br><span class="line">    t[p].val=t[q].val+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;=mid) modify(t[p].ls,t[q].ls,l,mid,val);</span><br><span class="line">    <span class="keyword">else</span> modify(t[p].rs,t[q].rs,mid+<span class="number">1</span>,r,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) <span class="keyword">return</span> t[p].val;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid) ans+=query(t[p].ls,l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;qr) ans+=query(t[p].rs,mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        tmp[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        a[i]=tmp[b[i]];</span><br><span class="line">        modify(rt[i],rt[i<span class="number">-1</span>],<span class="number">1</span>,n,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1,l2,r1,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        l1=f(l1),l2=f(l2),r1=f(r1),r2=f(r2);</span><br><span class="line">        <span class="keyword">if</span>(l1&gt;r1) swap(l1,r1);</span><br><span class="line">        <span class="keyword">if</span>(l2&gt;r2) swap(l2,r2);</span><br><span class="line">        lst=query(rt[r2],<span class="number">1</span>,n,l1,r1)-query(rt[l2<span class="number">-1</span>],<span class="number">1</span>,n,l1,r1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lst);</span><br><span class="line">        ++lst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>USACO 2021 Jan 总结</title>
    <url>/2021/01/USACO-2021-Jan-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这次是我第一次打 USACO qaq</p>
<p>于是参加了铜组和银组（铜组 AK 提前晋级）。</p>
<a id="more"></a>
<h1 id="USACO-2021-Jan"><a href="#USACO-2021-Jan" class="headerlink" title="USACO 2021 Jan"></a>USACO 2021 Jan</h1><h2 id="Bronze"><a href="#Bronze" class="headerlink" title="Bronze"></a>Bronze</h2><p>铜组的题都很水啦。。</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>直接模拟。将 Farmer John 听到的字符串扫一遍，如果有相邻的两个字母在牛版字母表中逆序，就重新开一个新的字母歌。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s 为牛的字母表，t 为 FJ 听到的字符串</span></span><br><span class="line">rep(i,<span class="number">0</span>,<span class="number">25</span>) &#123;</span><br><span class="line">    to[s[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>,now=<span class="number">-1</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,l) &#123;</span><br><span class="line">    <span class="keyword">if</span>(to[t[i]-<span class="string">'a'</span>]&lt;=now) &#123;</span><br><span class="line">        now=to[t[i]-<span class="string">'a'</span>];</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125; <span class="keyword">else</span> now=to[t[i]-<span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>先统计奇数和偶数的个数。</p>
<p>由于题目要求一奇一偶交替，于是我们可以先把奇数和偶数中个数最少的那个先用完。</p>
<p>然后只剩下一堆奇数或者一堆偶数了。</p>
<p>如果剩下一堆偶数，那么可以把这堆偶数搓成一团放在下一个。答案 $+1$。</p>
<p>如果剩下一堆奇数，由于题目要保证所有的牛都划分完，所以我们分奇数个数$\mod 3$ 的三种情况讨论即可。具体见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=min(ji,ou);</span><br><span class="line">ji-=ans,ou-=ans;</span><br><span class="line"><span class="keyword">if</span>(ou) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ji%<span class="number">3</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="number">2</span>+(ji/<span class="number">3</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ji%<span class="number">3</span>==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="number">2</span>+(ji/<span class="number">3</span>)*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="number">2</span>+((ji<span class="number">-2</span>)/<span class="number">3</span>)*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>考虑乘法原理。</p>
<p>我们把牛从高到低考虑，因为如果先考虑低牛的话，低牛可能会占用高牛的必须位置，但是先考虑高牛就不会影响到低牛的方案数。</p>
<p>然后就是裸的乘法原理了。对于每头牛，将答案乘以这头牛的方案数即可。别忘了乘完之后下一头牛的方案数要 $-1$，因为这头牛占用了下一头牛的一个可能情况（只是可能情况，而不是必须位置）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>,now=<span class="number">0</span>;</span><br><span class="line">per(i,n,<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> id=lower_bound(b+<span class="number">1</span>,b+n+<span class="number">1</span>,a[i])-b;</span><br><span class="line">    id=n-id+<span class="number">1</span>; <span class="comment">// 有多少个牛棚塞得下这头牛</span></span><br><span class="line">    ans*=id-now; <span class="comment">// -now 是因为更高的牛一定占用了其中的 now 个牛棚</span></span><br><span class="line">    ++now; <span class="comment">// 下一头牛方案数 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Silver"><a href="#Silver" class="headerlink" title="Silver"></a>Silver</h2><p>这次银组还是比较有含金量的。</p>
<h3 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h3><p>我们先模拟一轮，看每头牛分别能到哪里，对每头牛开一个 <code>set</code>。</p>
<p>模拟完一轮之后，我们可以找到这个序列中所有的环。</p>
<p>然后将这些环中的 <code>set</code> 合并即可。</p>
<p>一个节省代码量的小 trick：将两个 <code>set</code> 合并可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a.insert(b.begin(),b.end()); <span class="comment">// 意为将 b 合并进 a</span></span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k,<span class="keyword">bool</span> first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!first&amp;&amp;u==k) <span class="keyword">return</span> ;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    s[k].insert(s[u].begin(),s[u].end());</span><br><span class="line">    dfs(cow[u],k,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k,<span class="keyword">bool</span> first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!first&amp;&amp;u==k) <span class="keyword">return</span> ;</span><br><span class="line">    ans[u]=s[k].size();</span><br><span class="line">    dfs2(cow[u],k,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) cow[i]=i,s[i].insert(i);</span><br><span class="line">    rep(i,<span class="number">1</span>,k) &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        swap(cow[a],cow[b]);</span><br><span class="line">        s[cow[b]].insert(b);</span><br><span class="line">        s[cow[a]].insert(a);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">        dfs(i,i,<span class="number">1</span>);</span><br><span class="line">        dfs2(i,i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h3><p>我们可以先 dp 求出前缀的答案和后缀的答案。</p>
<p>具体可以开一个桶，转移的时候分两种情况讨论即可。</p>
<p>然后对一个挖掉的区间 $[l,r]$，答案就是 $pre_{l-1}+suf_{r+1}$。</p>
<p>详见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]&gt;s[i<span class="number">-1</span>]) f[i]=f[i<span class="number">-1</span>]+<span class="number">1</span>,vis[s[i]-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+(!vis[s[i]-<span class="string">'A'</span>]);</span><br><span class="line">        per(j,s[i<span class="number">-1</span>]-<span class="string">'A'</span>,s[i]-<span class="string">'A'</span>+<span class="number">1</span>) vis[j]=<span class="number">0</span>;</span><br><span class="line">        vis[s[i]-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">0</span>,<span class="number">25</span>) vis[i]=<span class="number">0</span>;</span><br><span class="line">per(i,n,<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]&gt;s[i+<span class="number">1</span>]) g[i]=g[i+<span class="number">1</span>]+<span class="number">1</span>,vis[s[i]-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        g[i]=g[i+<span class="number">1</span>]+(!vis[s[i]-<span class="string">'A'</span>]);</span><br><span class="line">        per(j,s[i+<span class="number">1</span>]-<span class="string">'A'</span>,s[i]-<span class="string">'A'</span>+<span class="number">1</span>) vis[j]=<span class="number">0</span>;</span><br><span class="line">        vis[s[i]-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">1</span>,q) &#123;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[l<span class="number">-1</span>]+g[r+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>只会一半分的 $N\le 10$ 做法qwq</p>
<p>具体来说就是，我们确定了一行一列之后，其它的格子都可以直接确定。</p>
<p>那么爆搜这一行一列即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qwq=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==n+<span class="number">1</span>) &#123;</span><br><span class="line">        rep(i,<span class="number">2</span>,n) rep(j,<span class="number">2</span>,n) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=now[i<span class="number">-1</span>][j<span class="number">-1</span>]+now[i][j<span class="number">-1</span>]+now[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(!tmp||tmp==<span class="number">3</span>) &#123;anss-=qwq;<span class="keyword">return</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp==<span class="number">1</span>) anss+=a[i][j],now[i][j]=<span class="number">1</span>,qwq+=a[i][j];</span><br><span class="line">            <span class="keyword">else</span> now[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,anss);</span><br><span class="line">        anss-=qwq;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==n+<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>) x=<span class="number">1</span>,y=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span>) &#123;</span><br><span class="line">        now[x][y]=<span class="number">1</span>;</span><br><span class="line">        anss+=a[x][y];</span><br><span class="line">        dfs(x+<span class="number">1</span>,y);</span><br><span class="line">        now[x][y]=<span class="number">0</span>;</span><br><span class="line">        anss-=a[x][y];</span><br><span class="line">        dfs(x+<span class="number">1</span>,y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        now[x][y]=<span class="number">1</span>;</span><br><span class="line">        anss+=a[x][y];</span><br><span class="line">        dfs(x,y+<span class="number">1</span>);</span><br><span class="line">        now[x][y]=<span class="number">0</span>;</span><br><span class="line">        anss-=a[x][y];</span><br><span class="line">        dfs(x,y+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) rep(j,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Bronze 没啥好说的，轻松 AK。</p>
<p>Silver C 没想出来正解，不过估计能上 Gold 了。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title>一元二次方程的整根问题</title>
    <url>/2021/01/%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E7%9A%84%E6%95%B4%E6%A0%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>二次跑得比一次快。</p>
<center>————lxj</center>

</blockquote>
<a id="more"></a>
<h2 id="一元二次方程的整根问题"><a href="#一元二次方程的整根问题" class="headerlink" title="一元二次方程的整根问题"></a>一元二次方程的整根问题</h2><p>对于一元二次方程的整根问题，有以下 5 种主要方法。</p>
<p>其中前两种为中考要求。</p>
<h3 id="利用判别式列不等式求范围"><a href="#利用判别式列不等式求范围" class="headerlink" title="利用判别式列不等式求范围"></a>利用判别式列不等式求范围</h3><p>例：一元二次方程 $x^2-4x+m=0$ 有整根，求所有满足条件的正整数 $m$。</p>
<p>解：$\because \Delta=16-4m\ge 0$，$\therefore m\le 4$。</p>
<p>经检验，$m=3,4$ 时符合题意。故 $m=3$ 或 $m=4$。</p>
<p>这种方法主要用于 $\Delta\ge 0$ 就可以卡出很小的 $m$ 的范围的情况。</p>
<h3 id="可以直接求根"><a href="#可以直接求根" class="headerlink" title="可以直接求根"></a>可以直接求根</h3><p>例：一元二次方程 $mx^2-(m+2)x+2=0$ 两根均为整根，求所有满足条件的正整数 $m$。</p>
<p>解：因式分解可得 $(mx-2)(x-1)=0$。</p>
<p>$\therefore x_1=\frac{2}{m},x_2=1$。</p>
<p>$\therefore m=\pm 1,\pm 2$。</p>
<h3 id="判别式是二次式：令-Delta-k-2"><a href="#判别式是二次式：令-Delta-k-2" class="headerlink" title="判别式是二次式：令 $\Delta=k^2$"></a>判别式是二次式：令 $\Delta=k^2$</h3><p>例：$x^2-ax+a=0$ 的两根都为整根，求整数 $a$ 的值。</p>
<p>解：$\Delta=a^2-4a\ge 0$。</p>
<p>令 $a^2-4a=k^2(k$为非负整数$)$。</p>
<p>$\therefore (a-2)^2-k^2=4$。$\therefore (a+k-2)(a-k-2)=4$。</p>
<p>然后枚举 $4$ 的约数即可。</p>
<h3 id="韦达定理"><a href="#韦达定理" class="headerlink" title="韦达定理"></a>韦达定理</h3><p>例：$x^2-ax+a=0$ 的两根都为整根，求整数 $a$ 的值。</p>
<p>解：$\Delta=a^2-4a\ge 0$。</p>
<p>此时，</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
x_1+x_2=a \\ 
x_1x_2=a
\end{matrix}\right.</script><p>故 $x_1x_2-x_1-x_2=0$。</p>
<p>两边同时 $+1$，因式分解可得 $(x_1-1)(x_2-1)=1$。</p>
<p>然后枚举 $1$ 的约数即可。</p>
<h3 id="主元法"><a href="#主元法" class="headerlink" title="主元法"></a>主元法</h3><p>例：$x^2-ax+a=0$ 的两根都为整根，求整数 $a$ 的值。</p>
<p>解：变形可得 $a=\frac{x^2}{x-1}=x+1+\frac{1}{x-1}$。</p>
<p>$\therefore (x-1)|1$。</p>
<p>还是枚举 $1$ 的约数。</p>
<p>也就是说可以将 $a$ 的表达式化为部分分式求解。</p>
<p>另外，主元法如果求出 $a$ 的表达式中分子次数比分母小的情况了，且规定了 $a$ 为正整数的话，因为“二次跑得比一次快”（二次的增长速度比一次快很多），所以用分子 $\ge$ 分母这个不等式可以卡出很小的范围，方便一个一个讨论。</p>
]]></content>
      <categories>
        <category>whk</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>二次方程</tag>
        <tag>整根问题</tag>
      </tags>
  </entry>
  <entry>
    <title>一次函数的平移及对称点问题</title>
    <url>/2021/01/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0%E7%9A%84%E5%B9%B3%E7%A7%BB%E5%8F%8A%E5%AF%B9%E7%A7%B0%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>博客真是个好东西呢，复习数学也可以在这里总结（</p>
<a id="more"></a>
<h2 id="一次函数与图像平移"><a href="#一次函数与图像平移" class="headerlink" title="一次函数与图像平移"></a>一次函数与图像平移</h2><p>众所周知，一次函数的图像是一条直线。</p>
<p>以函数 $y=2x+3$ 为例：</p>
<p><img src="https://i.loli.net/2021/01/16/TBz2dvPljGaCQXY.png" alt=""></p>
<p>我们把它向下平移一格？</p>
<p><img src="https://i.loli.net/2021/01/16/ySrXALEVRuFejtT.png" alt=""></p>
<p>平移后的函数为 $y=2x+2$。</p>
<p>向上一格？$y=2x+4$。</p>
<p>平移 $k$ 格？$y=2x+(k+3)$</p>
<p>也就是说，我们得到了上下平移的规律：<strong>上加下减</strong>。</p>
<p>左右平移呢？</p>
<p>还是以 $y=2x+3$ 为例，把它向左一格？</p>
<p><img src="https://i.loli.net/2021/01/16/jOy9MRnLbCBtFPD.png" alt=""></p>
<p>平移后的函数为 $y=2x+5$，即 $y=2(x+1)+3$。</p>
<p>向右一格？$y=2(x-1)+3$。</p>
<p>平移 $k$ 格？$y=2(x-k)+3$。</p>
<p>也就是说，我们得到了左右平移的规律：<strong>左加右减</strong>。</p>
<h3 id="左加右减，上加下减就是一次函数平移的规律。"><a href="#左加右减，上加下减就是一次函数平移的规律。" class="headerlink" title="左加右减，上加下减就是一次函数平移的规律。"></a>左加右减，上加下减就是一次函数平移的规律。</h3><p>关于这个是为什么，我简单口胡了个解释。</p>
<p>因为 $y$ 是函数上一个点的 $y$ 坐标，所以往 $y$ 上面加就是往纵坐标上面加。因此上加下减。</p>
<p>左加右减稍微难理解一点。其实可以理解成如果要把一个直线向左平移，对于原直线上的一个点，它平移后的点肯定也向左平移了。但是平移后仅仅是向左平移，纵坐标是不变的。因此想要维持纵坐标不变，需要在横坐标上把平移的消耗给加回来。因此左加右减。</p>
<h2 id="函数的图像与轴对称"><a href="#函数的图像与轴对称" class="headerlink" title="函数的图像与轴对称"></a>函数的图像与轴对称</h2><p>我们探讨一个点关于一条直线的对称点问题。</p>
<p>这玩意好毒瘤啊。。</p>
<h3 id="当直线与坐标轴平行时"><a href="#当直线与坐标轴平行时" class="headerlink" title="当直线与坐标轴平行时"></a>当直线与坐标轴平行时</h3><p>设 $A(x_0,y_0)$，直线为 $x=a$。</p>
<p>则对称点 $B(2a-x_0,y_0)$。</p>
<p>例如：</p>
<p><img src="https://i.loli.net/2021/01/16/qKP7MLzuavsY3cA.png" alt=""></p>
<p>由于 $A$ 到直线的距离等于 $B$ 到直线的距离且 $AB$ 与该直线垂直，而且到直线的距离由于直线与坐标轴平行非常好求，因此我们可以快速得到 $B$ 点的坐标。</p>
<p>同理，当直线为 $y=b$ 时，对称点 $C(x_0,2b-y_0)$。</p>
<h3 id="当直线与坐标轴成-45°-角时"><a href="#当直线与坐标轴成-45°-角时" class="headerlink" title="当直线与坐标轴成 $45°$ 角时"></a>当直线与坐标轴成 $45°$ 角时</h3><p>这个东西的结论比较特殊。</p>
<p>设 $A(x_0,y_0)$，直线为 $y=x+b$。</p>
<p>则对称点为 $B(y_0-b,x_0+b)$。</p>
<p>例如：</p>
<p><img src="https://i.loli.net/2021/01/16/ciQCFdKHw2DL7bx.png" alt=""></p>
<p>若直线为 $y=-x+b$，则对称点为 $C(-y_0+b,-x_0+b)$。</p>
<p>例如：</p>
<p><img src="https://i.loli.net/2021/01/16/yOcELSaoCeWMqQm.png" alt=""></p>
<p>关于这两个东西的证明，我们可以自 $A$ 向该直线作一条垂线，然后倍长它就可以了。</p>
<p>为什么把这两个从一般情况中单拿出来呢？因为这两个东西有比较好的结论，而且有一种很好的记法。</p>
<p>记法：对于 $A(x_0,y_0)$ 与直线 $y=kx+b(k\in\{-1,1\})$，对称点可以写成 $B(\frac{y_0-b}{k},kx_0+b)$。</p>
<p>有人可能会说，这算什么好记？那么我们可以把 $x=x_0$ 与 $y=y_0$ 分别代入进去看看：</p>
<p>若 $x=x_0$，$y=kx+b=kx_0+b$。</p>
<p>若 $y=y_0$，$y_0=kx+b$，$\therefore x=\frac{y_0-b}{k}$。</p>
<p>分别代进去之后，求出的 $x$ 与 $y$ 刚好是该对称点的 $x,y$ 坐标！</p>
<h3 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h3><p>这个东西就不用去记了，计算方法我刚刚也说过：可以自 $A$ 向该直线作一条垂线，然后倍长它就可以了。</p>
<p>但是很烦人就对了…</p>
<p>这里给出结论：对于 $A(x_0,y_0)$ 与直线 $l:y=kx+b$，可以得出 $A$ 关于 $l$ 的对称点</p>
<script type="math/tex; mode=display">B(\frac{(1-k^2)x_0+2ky_0-2kb}{1+k^2},\frac{2kx_0+(k^2-1)y_0+2b}{1+k^2})</script><p>所以我说不用去记…</p>
]]></content>
      <categories>
        <category>whk</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>一次函数</tag>
      </tags>
  </entry>
  <entry>
    <title>FHQ-Treap</title>
    <url>/2021/01/FHQ-Treap/</url>
    <content><![CDATA[<p>期末考试前写这玩意，我危。</p>
<a id="more"></a>
<h1 id="FHQ-Treap"><a href="#FHQ-Treap" class="headerlink" title="FHQ-Treap"></a>FHQ-Treap</h1><h2 id="为啥不旋转了？"><a href="#为啥不旋转了？" class="headerlink" title="为啥不旋转了？"></a>为啥不旋转了？</h2><p>转来转去不可爱！难写难调（较非旋 Treap 而言），结构还不稳定，不能可持久化！</p>
<h2 id="怎么分裂-合并？"><a href="#怎么分裂-合并？" class="headerlink" title="怎么分裂/合并？"></a>怎么分裂/合并？</h2><p>FHQ-Treap 维护值域大概是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//split 函数的作用是将一棵 FHQ-Treap 分裂成权值 &lt;=val 和 &gt;val 的两部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) &#123;x=y=<span class="number">0</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    pushdown(now); <span class="comment">//别忘记 pushdown!</span></span><br><span class="line">    <span class="keyword">if</span>(t[now].val&lt;=val) &#123;</span><br><span class="line">        x=now;</span><br><span class="line">        split(t[now].r,t[x].r,y,val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y=now;</span><br><span class="line">        split(t[now].l,x,t[y].l,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//merge 函数的作用是将两棵左边权值严格比右边小的 FHQ-Treap 按堆权合并成一棵树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(t[x].rnk&lt;t[y].rnk) &#123;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        t[x].r=merge(t[x].r,y);</span><br><span class="line">        pushup(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pushdown(y);</span><br><span class="line">        t[y].l=merge(x,t[y].l);</span><br><span class="line">        pushup(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，FHQ-Treap 还可以用来维护序列。</p>
<p>具体来说，我们不再按照 <code>val</code> 分裂，而是选择按照 <code>size</code> 分裂。这样可以满足其映射的序列的下标满足二叉搜索树性质。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//split 函数的作用是将一棵 FHQ-Treap 分裂成下标 &lt;=k 与 &gt;k 的两部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) &#123;x=y=<span class="number">0</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    pushdown(now); <span class="comment">//别忘记 pushdown!</span></span><br><span class="line">    <span class="keyword">if</span>(t[t[now].l].sz&lt;k) &#123;</span><br><span class="line">        x=now;</span><br><span class="line">        split(t[now].r,t[x].r,y,k-t[t[now].l].sz<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y=now;</span><br><span class="line">        split(t[now].l,x,t[y].l,k);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//merge 函数的作用是将两棵左边下标严格比右边小的 FHQ-Treap 按堆权合并成一棵树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(t[x].rnk&lt;t[y].rnk) &#123;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        t[x].r=merge(t[x].r,y);</span><br><span class="line">        pushup(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pushdown(y);</span><br><span class="line">        t[y].l=merge(x,t[y].l);</span><br><span class="line">        pushup(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他操作？"><a href="#其他操作？" class="headerlink" title="其他操作？"></a>其他操作？</h2><p>可以轮番调用 <code>split</code> 和 <code>merge</code> 来解决。</p>
<p>维护序列可以打标记。</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态开点线段树</title>
    <url>/2020/12/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>今天学校讲了这玩意。算是正式步入省选了。</p>
<p>觉得还不是太熟悉，有必要写一写这篇 blog。</p>
<a id="more"></a>
<h1 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h1><h2 id="Why-to-动态开点？"><a href="#Why-to-动态开点？" class="headerlink" title="Why to 动态开点？"></a>Why to 动态开点？</h2><p>下标太大、节点太多，炸空间。</p>
<p>离散化又需要离线，太麻烦。</p>
<p>于是我们动态地开点，不需要开的点就不开，减少空间开销。</p>
<p>这是开一个点的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=++tot;</span><br><span class="line">    t[p].l=l;t[p].r=r; <span class="comment">//我习惯把 l 和 r 存进结构体里，但是在动态开点线段树中貌似没什么用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// something you want to maintain</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><code>pushup</code> 按照普通线段树写法模仿，把 <code>p&lt;&lt;1</code> 与 <code>p&lt;&lt;1|1</code> 换成 <code>t[p].ls</code> 和 <code>t[p].rs</code> 即可。</p>
<p><code>pushdown</code> 同理。</p>
<p>插入下标为 $[L,R]$ 的区间？这里以最大值为例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=add(l,r);</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;t[p].mx=t[p].tag=x;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    pushdown(p);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; <span class="comment">//特别地，若下标有负数，应使用 l+(r-l&gt;&gt;1)</span></span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) modify(t[p].ls,l,mid,L,R,x);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R) modify(t[p].rs,mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询？这里也以最大值为例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> t[p].mx;</span><br><span class="line">    pushdown(p);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>; <span class="comment">//特别地，若下标有负数，应使用 l+(r-l&gt;&gt;1)</span></span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) ans=max(ans,query(t[p].ls,l,mid,L,R,x));</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R) ans=max(ans,query(t[p].rs,mid+<span class="number">1</span>,r,L,R,x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反正和线段树很像。就是每次到一个点就把它新建一下就行了。</p>
<p>注意有初值的话最大值得用 ST 表处理一波初值。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="CF915E-Physical-Education-Lessons"><a href="#CF915E-Physical-Education-Lessons" class="headerlink" title="CF915E Physical Education Lessons"></a>CF915E Physical Education Lessons</h2><p><del>珂朵莉树好题</del></p>
<p>动态开点。因为 $n$ 太大了，但 $q$ 很小，所以需要开的点很少。</p>
<p>动态开点线段树维护区间和、区间赋值即可。</p>
<h2 id="P5459-BJOI2016-回转寿司"><a href="#P5459-BJOI2016-回转寿司" class="headerlink" title="P5459 [BJOI2016]回转寿司"></a>P5459 [BJOI2016]回转寿司</h2><p>由于这题 $a_i$ 可以为负，于是不能用双指针扫。</p>
<p>考虑使用前缀和。则本题就是要统计满足 $L\le sum_{r}-sum_{l-1}\le R$ 的区间 $[l,r]$ 的个数。</p>
<p>考虑固定 $l$，求有多少种 $r$。</p>
<p>此时的 $r$ 需要满足 $L+sum_{l-1}\le sum_r\le R+sum_{l-1}$。</p>
<p>可以开一个动态开点的权值线段树。从后往前扫一遍，每次加入它自己的 $sum_i$ 之后问线段树中在 $L+sum_{i-1}\sim R+sum_{i-1}$ 范围内的点的个数。</p>
<p><del>也可以离散化后用权值树状数组搞</del></p>
<h2 id="CF817F-MEX-Queries"><a href="#CF817F-MEX-Queries" class="headerlink" title="CF817F MEX Queries"></a>CF817F MEX Queries</h2><p><del>珂朵莉树好题</del></p>
<p>动态开点线段树维护区间推平成 $1$ 或 $0$、区间取反和区间和。</p>
<p>询问就在线段树上二分，看哪里的区间和小于区间中数的个数就往哪里跑。</p>
<h2 id="CF803G-Periodic-RMQ-Problem"><a href="#CF803G-Periodic-RMQ-Problem" class="headerlink" title="CF803G Periodic RMQ Problem"></a>CF803G Periodic RMQ Problem</h2><p>好题。</p>
<p>由于 $n\times k$ 太大了，显然要动态开点。</p>
<p>但是在新建一个节点的时候，我们需要将它的初值赋好。</p>
<p>用一个 ST 表维护一下原序列的区间 $\min$ 用来给开的点赋初值，然后就是区间推平、区间 $\min$ 的动态开点线段树板子了。</p>
<p>特别地，如果开的点经过两个 $n$ 的段（因为题目中 $n$ 循环了 $k$ 次），那么分两段讨论即可。如果开的点跨越了整个段，那么直接用整个序列的 $min$ 来赋初值。</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2020游记</title>
    <url>/2020/12/NOIP2020%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>学校模拟赛血崩，<code>RP--</code>。</p>
<a id="more"></a>
<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>下午被迫自愿去看学校的足球联赛总决赛，是社会实践记中考 1 分。于是 NOIP 前一天的加课集训就被冲了。</p>
<p>于是我们班三个勇士（我、sqrt_7、2x6_81）去找青蛙（我们班主任）请了个假。</p>
<p>青蛙挺好说话的，给我们准假了（让我们先看 10min 开幕式，然后就溜）。于是我们奔向机房。</p>
<p>老师讲了讲一些注意事项和可能踩的坑。同时加了道 Day -1 的模拟赛题的加强版。</p>
<p>晚上发现同学都在码平衡树，就我不会/fad。</p>
<p>看来数据结构真的忘光光了。</p>
<h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>考试日。带了亿些吃的。</p>
<p>然后因为怕迟到提前来了两个小时，天还是黑的，只好在旁边（400m左右）早餐店坐了亿会，背了背对拍板子（没用上）。</p>
<p>先开 T1：这不**题吗？</p>
<p>toposort，加上通分搞定。</p>
<p>看见了 $m$ 的限制，觉得会有很多人因为 $m$ 被卡。</p>
<p>然后是 T2：正解不会，去码了个 $Tn^2$ 的 hash 暴力。</p>
<p>然后就用这暴力去打了会所有字符相同的情况的表。结果 12:30 了都没打出来（期间在看其他题）。</p>
<p>出考场之后发现这 hash 可以轻松优化成 $Tn\log n$。。。</p>
<p>然后去看了看 T3。手玩了亿会发现不会，果断放弃。</p>
<p>T4 先打了个 $30$ pts 的暴力，然后打了个 $k=1$ 的情况。估分 $40$。</p>
<p>然后 12:30 了。回去看 T2 的所有字符相同的情况。</p>
<p>表还没打完，死在那里了。于是我开始推式子。</p>
<p>这式子挺好推的（</p>
<p>然后就开始码</p>
<p>然后开始调</p>
<p>终于调对了！赶快交！诶怎么 13:00 了？？</p>
<p>卡着 13 点整调出了这 8 分。。。要是在其他省估计这 8 分就有了。。可是我们 BJ 是程序回收系统。。考试结束自动关闭提交通道。。。</p>
<p>成功丢掉了这 $8$ pts。现在想想挺可惜的。</p>
<p>估分：$100+48+0+40=188$。</p>
<p>回家看 LA 群里讨论貌似 T1 要用高精？完了。。</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>BJ 选手的代码发了。</p>
<p>Luogu 自测：$90+48+0+30=168$</p>
<p>Oitiku 自测：$90+48+0+30=168$</p>
<p>T4 的 $k=1$ 情况写挂了。沦为与暴力老哥同分。</p>
<p>绵羊神仙 T2 貌似多测不清空，只有 $8$ pts 是稳的，壮烈牺牲。</p>
<p>（不过按照 CCF 数据的尿性应该所有字符串的长度都一样？那绵羊应该还没事。</p>
<h1 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h1><p>$60+48+0+35=143$。</p>
<p>T1 先乘后除死了。</p>
<p>T4 输出 $-1$ 多骗了 $5$ 分。</p>
<h1 id="Day-？？"><a href="#Day-？？" class="headerlink" title="Day ？？"></a>Day ？？</h1><p>由于是初中生，1= $\to$ 4=。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>树学竞赛——NOIP历年树题刷题计划</title>
    <url>/2020/11/%E6%A0%91%E5%AD%A6%E7%AB%9E%E8%B5%9B%E2%80%94%E2%80%94NOIP%E5%8E%86%E5%B9%B4%E6%A0%91%E9%A2%98%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>开了个新坑。。12月NOIP之前争取填完吧。。</p>
<p>目前还剩：P5659 P5024（这两个阴间题目不打算做了，所以算是填完坑了吧）</p>
<a id="more"></a>
<h1 id="P5658-括号树"><a href="#P5658-括号树" class="headerlink" title="P5658 括号树"></a><a href="https://www.luogu.com.cn/problem/P5658" target="_blank" rel="noopener">P5658 括号树</a></h1><p>先考虑一条链的情况。</p>
<p>发现这玩意可以 $\operatorname{O}(n)$ 转移。</p>
<p>然后推广到一棵树上就行了（</p>
<p>转移的细节要考虑一下，然后就没了。</p>
<p>时间复杂度 $\operatorname{O}(n)$ 。</p>
<hr>
<h1 id="P5666-树的重心"><a href="#P5666-树的重心" class="headerlink" title="P5666 树的重心"></a><a href="https://www.luogu.com.cn/problem/P5666" target="_blank" rel="noopener">P5666 树的重心</a></h1><p>一道树上倍增+换根的好题。</p>
<p>首先有一个显而易见的结论就是：一棵树的重心必定在这棵树根节点往下的重链上。</p>
<p>那么就可以倍增跳重链了。</p>
<p><code>dfs</code> 一棵树，考虑删边情况。</p>
<p>删边之后，那个子树很好处理，但是子树以外的部分需要换根解决，讨论即可。</p>
<p>时间复杂度 $\operatorname{O}(n\log n)$。</p>
<p>（貌似有 $\operatorname{O}(n)$ 做法？</p>
<hr>
<h1 id="P5021-赛道修建"><a href="#P5021-赛道修建" class="headerlink" title="P5021 赛道修建"></a><a href="https://www.luogu.com.cn/problem/P5021" target="_blank" rel="noopener">P5021 赛道修建</a></h1><p>看了题，一眼就是二分。</p>
<p>考虑二分这个长度最小的赛道的值，那么题目变成了“能否修建 $m$ 条以上的赛道使得这几条赛道的长度都 $\ge x$ ”。</p>
<p>可以一遍 dfs 解决。</p>
<p>具体来说：对于每个点，它往下可以有若干条没用过的链，那么可以两两拼起来，拼的方式跟<a href="https://www.luogu.com.cn/problem/P1094" target="_blank" rel="noopener">P1094</a>差不多。就是一个爆了，就让它自己待着；否则就两两拼，并且小的和大的拼。拼完之后多余的（太小了或者拼完了剩下了）就取个最大值了返回，在处理父亲节点的时候有用。</p>
<p>这个拼的过程可以用 <code>multiset</code> 维护，总时间复杂度 $\operatorname{O}(n\log^2n)$。</p>
<p>（话说我 #8 被卡T了，吸了氧才过</p>
<hr>
<h1 id="P2680-运输计划"><a href="#P2680-运输计划" class="headerlink" title="P2680 运输计划"></a><a href="https://www.luogu.com.cn/problem/P2680" target="_blank" rel="noopener">P2680 运输计划</a></h1><p>一眼二分题。</p>
<p>二分完了，来一波树上差分随便搞搞。</p>
<p>具体来说：二分一个 $mid$ 表示这个答案要求的最短时间，然后找一遍所有路径中超出要求的，做个差分，找到所有这些路径中都经过的一些边，枚举这些边看看有没有一条边能使得这些路径长度都 $\le mid$ 。</p>
<p>时间复杂度 $\operatorname{O}(n\log \sum t_i+m\log n)$</p>
<hr>
<h1 id="P1351-联合权值"><a href="#P1351-联合权值" class="headerlink" title="P1351 联合权值"></a><a href="https://www.luogu.com.cn/problem/P1351" target="_blank" rel="noopener">P1351 联合权值</a></h1><p>由于要求的点对之间距离为 $2$，于是考虑枚举点对之间的中转点。</p>
<p>对于每个中转点 $u$，它带来的点对的联合权值之和就是 $2$ 倍的所有与它相连的点两两配对的权值乘积之和。</p>
<p>也就是 $\sum_{(u,v)\in E}\sum_{(u,w)\in E, w\not =v}W_vW_w$。</p>
<p>这玩意可以通过完全平方公式转化成：$(\sum_{(u,v)\in E} W_v)^2-\sum_{(u,v)\in E} W_v^2$ 。</p>
<p>扫一遍每个点为中转点的情况，最后求和即可。</p>
<p>关于最大值就对于每个中转点找两个 $W$ 最大的点求联合权值，最后取 $\max$ 即可。</p>
<p>可以 $\operatorname{O}(n)$ 解决。</p>
<hr>
<h1 id="P1099-树网的核"><a href="#P1099-树网的核" class="headerlink" title="P1099 树网的核"></a><a href="https://www.luogu.com.cn/problem/P1099" target="_blank" rel="noopener">P1099 树网的核</a></h1><p>$\operatorname{O}(n^3)$ 暴力随便艹过去。。</p>
<p>先 <code>floyd</code> 一下，然后随便暴力枚举就过了。。。</p>
<hr>
<h1 id="P7073-表达式"><a href="#P7073-表达式" class="headerlink" title="P7073 表达式"></a><a href="https://www.luogu.com.cn/problem/P7073" target="_blank" rel="noopener">P7073 表达式</a></h1><p>众所周知，后缀表达式可以 $\operatorname{O}(n)$ 用一个栈求解，而且可以建一棵树。</p>
<p>那么可以把题目中的后缀表达式先建一个树出来，算出每个点子树的答案。</p>
<p>接着对于每个点 $i$ 考虑一下改变它会不会影响上面它父亲节点的结果，可以根据之前算出的答案以及它父亲的运算符来求。开一个 <code>bool</code> 数组记为 $can_i$。</p>
<p>那么对于每一个 $x_i$，如果从根节点到它的路径上所有点的 $can$ 值都为 $1$ 的话，那么改变 $x_i$ 就会改变最终结果。否则不会改变最终结果。具体实现可以对每一条根节点到叶子节点的路径都做一个 $can$ 的前缀和来解决。</p>
<p>时间复杂度 $\operatorname{O}(n+q)$。</p>
<hr>
<h1 id="P5689-多叉堆"><a href="#P5689-多叉堆" class="headerlink" title="P5689 多叉堆"></a><a href="https://www.luogu.com.cn/problem/P5689" target="_blank" rel="noopener">P5689 多叉堆</a></h1><p>算是一个树（森林？）题吧。</p>
<p>其实是 <del>树</del> 数学题。</p>
<p>用并查集维护每个树根，然后对于每棵树，令 $ans_i$ 表示以 $i$ 为根的树的答案，$sz_i$ 表示以 $i$ 为根的树的大小。</p>
<p>那么当把以 $x$ 为根的树插进以 $y$ 为根的树中时，$ans_y=ans_y\times ans_x\times\operatorname{C}_{sz_y+sz_x-1}^{sz_x}$。然后更新 $sz_y=sz_y+sz_x$。</p>
<p>对于组合数，可以预处理阶乘和阶乘的逆元来算。利用公式 $C_m^n=\frac{m!}{n!(m-n)!}$ 求解。</p>
<hr>
<h1 id="P1600-天天爱跑步"><a href="#P1600-天天爱跑步" class="headerlink" title="P1600 天天爱跑步"></a><a href="https://www.luogu.com.cn/problem/P1600" target="_blank" rel="noopener">P1600 天天爱跑步</a></h1><p>神仙树上差分题。</p>
<p>这是几个月之前做的。详细见<a href="https://blog.henrytb.ml/2020/03/%E9%A2%98%E8%A7%A3-LuoguP1600-NOIP2016-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5">我的题解</a></p>
<hr>
<h1 id="P1967-货车运输"><a href="#P1967-货车运输" class="headerlink" title="P1967 货车运输"></a><a href="https://www.luogu.com.cn/problem/P1967" target="_blank" rel="noopener">P1967 货车运输</a></h1><p>这题是好久好久之前写的呢。</p>
<p>一句话题解：在最大生成树上跑 $\operatorname{lca}$。</p>
<p>没啥好说的。</p>
<hr>
<h1 id="P1084-疫情控制"><a href="#P1084-疫情控制" class="headerlink" title="P1084 疫情控制"></a><a href="https://www.luogu.com.cn/problem/P1084" target="_blank" rel="noopener">P1084 疫情控制</a></h1><p>可以推出一个显而易见的结论：军队一定要往上移动。</p>
<p>而且时间这个东西可以二分。</p>
<p>那么问题变成：在规定时间内，能不能控制疫情？</p>
<p>首先尽可能把军队往上移，然后看看能不能移到 $1$ 这个点。</p>
<p>如果不行，那么就让它留在这里。</p>
<p>如果可以的话，分以下情况讨论：</p>
<ol>
<li>能到 $1$ 号节点但是回不来了：还不如就让它呆在这里呢</li>
<li>能去别的节点：把所有的需要军队的根节点的叶子节点求出来，然后把它们到根的距离开一个数组存。再把能去别的节点的所有军队的剩余时间都存进另一个数组，跑个双指针，就做完了。</li>
</ol>
<hr>
<h1 id="完结撒花✿✿ヽ-°▽°-ノ✿"><a href="#完结撒花✿✿ヽ-°▽°-ノ✿" class="headerlink" title="完结撒花✿✿ヽ(°▽°)ノ✿"></a>完结撒花✿✿ヽ(°▽°)ノ✿</h1>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
        <tag>水题选做</tag>
        <tag>NOIP</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S2 2020 游记</title>
    <url>/2020/11/CSP-S2-2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>去北师大附实验了，带了点吃的。</p>
<a id="more"></a>
<hr>
<p>进入考场，看见了 2 个同校神仙，rp++。</p>
<p>开机密码 <code>daydayup</code>，解压密码…老师敲错了好多遍，后来发现把大写的 I 看成 1 或 l 了。。。</p>
<p>进来看题！</p>
<p>T1：smwy，CCF我$<em>$你$*</em>$</p>
<p>没关系，不着急，慢慢来。</p>
<p>于是我分了4类讨论 T1 的日期：</p>
<ol>
<li>公元前的</li>
<li>公元后儒略历的</li>
<li>儒略历结束那一年年末（讨论这个纯属是因为我懒</li>
<li>儒略历结束的下一年开始的</li>
</ol>
<p>然后除了第三类以外每一类来个二分。。要吐血了。。</p>
<p>1h 肝完了这道题。。</p>
<p>代码冗长，详见我的T1题解（还咕着</p>
<p>T2：哦哦这题挺良心的</p>
<p>30min 搞完了</p>
<p><del>然后出考场发现不开ull见祖宗了</del></p>
<p>T3：这又是啥</p>
<p>好像是个 DAG，topsort？</p>
<p>先写了个暴力，不知道为啥样例RE了，先去看T4了。</p>
<p>T4：“看起来”挺简单</p>
<p>实际上。。。</p>
<p>不会处理“我吃了你我会变成最短的，但是最长的不敢吃我”的这种情况。。想了半天浪费了好多时间。。</p>
<p>20pts，滚了</p>
<p>回去看T3，时间不多了。</p>
<p>调那个RE，调啊调，考试结束前 1min 最后发现有个地方 <code>j</code> 写成 <code>i</code> 了。。。</p>
<p>在考试结束前 <code>30s</code> 交了题。。</p>
<p>测完样例，过了，然后发现已经到点了。</p>
<p>危险操作，请勿模仿！</p>
<p>出了考场，估分 $100+100+20+20=240$</p>
<hr>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>然后在各大 OJ 上自测。。</p>
<ul>
<li>oitiku $100+70+10+20$</li>
<li>LG $100+60+5+25$</li>
<li>牛客 $100+65+0+20$</li>
</ul>
<p>T2 不开ull见祖宗了，$100\to (60\sim100)$。</p>
<p>T3 不知道哪里挂了，$20\to (0\sim20)$</p>
<p>T2 又搞这种 $k\le 64$ 的恶心玩意，jbl。。</p>
<p>等 CCF 吧。</p>
<hr>
<h1 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h1><p>CCF 数据出了。</p>
<p>$100+75+10+20=205$。一等了。</p>
<p>莫名感觉今年 1= 有手就行？</p>
<h1 id="Day-？？"><a href="#Day-？？" class="headerlink" title="Day ？？"></a>Day ？？</h1><p>最终排名出了。比去年没进步多少。</p>
<p>但是卡线 $205$ 拿到了 $7$ 级蓝勾！开心！</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1175E Minimal Segment Cover</title>
    <url>/2020/11/%E9%A2%98%E8%A7%A3-CF1175E-Minimal-Segment-Cover/</url>
    <content><![CDATA[<p>我们先考虑一下一道“缩水版”的题目。</p>
<blockquote>
<p>已知数轴上有一个区间，左端点记为 $L$，右端点记为 $R$，以及 $n$ 条线段 $s_i$，请问在 $n$ 条线段中最少选择多少条，可以把区间完全覆盖（包括 $L$ 点和 $R$ 点）。</p>
</blockquote>
<a id="more"></a>
<p>我们可以定义 $f_i$ 表示从 $i$ 这个点，通过一条线段能到达的最右的点。</p>
<p>实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rep(i,<span class="number">1</span>,MAXR) f[i]=i; <span class="comment">//MAXR是值域</span></span><br><span class="line">rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">    f[s[i].l]=max(f[s[i].l],s[i].r);</span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">0</span>,MAXR) f[i]=max(f[i],f[i<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure>
<p>然后暴力从 $L$ 开始跳 $f$ 即可。</p>
<p>如果遇到了 $f_i=i$ 且 $i&lt;R$ 的情况，那么无解。</p>
<p>跳到 $R$ 以后 <code>break</code> 掉循环。</p>
<p>那么可以来看这道题目了。如果说要优化一次询问的过程呢？</p>
<p>可以倍增！设 $f_{i,j}$ 表示从 $i$ 这个点通过 $2^j$ 个线段能到达的最右的点。</p>
<p>这样一次询问我们就优化成了 $O(\log n)$，可以通过本题。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>,MAXL=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fare[MAXL][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> mxr=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        fare[l][<span class="number">0</span>]=max(fare[l][<span class="number">0</span>],r);</span><br><span class="line">        mxr=max(mxr,r);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">0</span>,mxr) fare[i][<span class="number">0</span>]=max(fare[i][<span class="number">0</span>],fare[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">    rep(j,<span class="number">1</span>,<span class="number">21</span>) rep(i,<span class="number">0</span>,mxr) &#123;</span><br><span class="line">        fare[i][j]=fare[fare[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">        per(j,<span class="number">21</span>,<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fare[x][j]&lt;y) &#123;</span><br><span class="line">                ans+=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                x=fare[x][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fare[x][<span class="number">0</span>]&gt;=y) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF689D Friends and Subsequences</title>
    <url>/2020/10/%E9%A2%98%E8%A7%A3-CF689D-Friends-and-Subsequences/</url>
    <content><![CDATA[<p>在这里介绍一个防止二分写挂的神仙方法（今天教练介绍的2333</p>
<a id="more"></a>
<p>我们先枚举一个左端点，发现随着右端点的增长，$\min$ 值单调递减，$\max$ 值单调递增。</p>
<p>于是可以二分一下这个右端点的可能区间。具体就二分一下右端点区间的左端和右端点区间的右端即可。使用 ST 表优化查询区间 $\min$、$\max$ 值的速度。</p>
<p>但是，这个二分很容易<strong>写挂</strong>！</p>
<p>怎么办？</p>
<p>我们索性不考虑二分的边界啥的，在 $l$ 与 $r$ 距离很小的时候就跳出二分，然后暴力地在这个 $l$ 和 $r$ 之间找一下即可！</p>
<p>这样可以减少很多细节的考虑！方便考场调试代码！</p>
<p>具体见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> mn[N][<span class="number">22</span>],mx[N][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]),mx[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b[i]),mn[i][<span class="number">0</span>]=b[i];</span><br><span class="line">    rep(j,<span class="number">1</span>,<span class="number">21</span>) &#123;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))<span class="number">-1</span>&gt;n) mx[i][j]=mx[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> mx[i][j]=max(mx[i][j<span class="number">-1</span>],mx[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(j,<span class="number">1</span>,<span class="number">21</span>) &#123;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))<span class="number">-1</span>&gt;n) mn[i][j]=mn[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> mn[i][j]=min(mn[i][j<span class="number">-1</span>],mn[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">int</span> l=i,r=n;</span><br><span class="line">        <span class="keyword">int</span> rr=<span class="number">0</span>,ll=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r-l&gt;<span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//printf("de:%lld %lld %lld\n",l,r,mid);</span></span><br><span class="line">            <span class="keyword">int</span> lg=log2(mid-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> mxx=max(mx[i][lg],mx[mid-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">int</span> mnn=min(mn[i][lg],mn[mid-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">if</span>(mxx&gt;mnn) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        per(j,r,l) &#123;</span><br><span class="line">            <span class="keyword">int</span> lg=log2(j-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> mxx=max(mx[i][lg],mx[j-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">int</span> mnn=min(mn[i][lg],mn[j-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">if</span>(mxx==mnn) &#123;rr=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l=i,r=n;</span><br><span class="line">        <span class="keyword">while</span>(r-l&gt;<span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> lg=log2(mid-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> mxx=max(mx[i][lg],mx[mid-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">int</span> mnn=min(mn[i][lg],mn[mid-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">if</span>(mxx&gt;=mnn) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(j,l,r) &#123;</span><br><span class="line">            <span class="keyword">int</span> lg=log2(j-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> mxx=max(mx[i][lg],mx[j-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">int</span> mnn=min(mn[i][lg],mn[j-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">if</span>(mxx==mnn) &#123;ll=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ll&amp;&amp;rr) ans+=(rr-ll+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S1 2020 游记</title>
    <url>/2020/10/CSP-S1-2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>临阵擦枪了一波。感觉要炸</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上和同学一块坐车去首师大附中。</p>
<p>路上聊了大半路的雀魂和小半路的初赛。</p>
<hr>
<p>北洼路还是那么堵，提前下车走了几百米进了考点。</p>
<p>进考场，拿到试卷，看了一眼：</p>
<ul>
<li>单选很简单的样子</li>
<li>阅读程序题好像第一个程序挺简单，第二个有点难懂，第三个什么玩意？</li>
<li>完善程序是一个部分背包和一个状压dp，感觉部分背包在送分</li>
</ul>
<hr>
<p>开始答题了。</p>
<p>单选飞快地做完了，rp++（然后出考场之后发现自己爬楼梯那道题忘+1了，我是**）</p>
<hr>
<p>然后开始肝阅读程序。。。</p>
<p>第一个程序挺简单的，火速做完（然后对完答案后发现第一道判断题就错了，小于看成小于等于。。）</p>
<p>第二个程序嘛。。。</p>
<p>我<em>**</em>！</p>
<p>好像是个随机化 <code>nth_element</code> ？费了好大劲才做完。</p>
<p>然后出去对答案时发现单调递减和 $d[i]$ 为 $i$ 那两个复杂度分析都错了。。。wtcl</p>
<p>第三个程序：CCF nb！这手写map $\operatorname{O}(n^2)$ 笑死我了（<code>string</code> 比较是 $\operatorname{O}(n)$ 的）。。</p>
<blockquote>
<p>“CCF 教你手写 STL”.jpg</p>
</blockquote>
<p>然后时间复杂度 $\operatorname{O}(n!)$ 看起来很对，然后就打钩，然后就错了</p>
<p>第 6 题那个选择基本上是蒙的，错了</p>
<p>不过，第 5 题那个数列，找规律 nb，构造 辣鸡。花了几 min <del>大眼观察法</del>找出了规律，成就感++。</p>
<p>第三个程序做题耗时极长。。</p>
<hr>
<p>然后是完善程序。。</p>
<p>分数背包果然送分，回家对答案发现自己全对</p>
<p>状压 dp 那题感觉比去年简单，但还是错了俩</p>
<p>做完感觉完善程序比阅读程序轻松好多。。</p>
<hr>
<p>出考场，和另一个同学坐车，也聊了一路的雀魂。</p>
<p>回到家，对答案，估分 80。</p>
<p>估计能过。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF472D Design Tutorial: Inverse the Problem</title>
    <url>/2020/10/%E9%A2%98%E8%A7%A3-CF472D-Design-Tutorial-Inverse-the-Problem/</url>
    <content><![CDATA[<p>这道题挺好玩的。</p>
<a id="more"></a>
<p>先按照题目建一个以“树上两点之间距离”为边权的图，然后跑一遍最小生成树。</p>
<p>由于这张以“树上两点之间距离”为边权的图对应的树（不是刚刚求的生成树）上两个点之间只有一条路径，于是，我们可以枚举生成树上任意两个点看看这两个点在生成树上的距离和它们两个点在以“树上两点之间距离”图（就是题目给的那个邻接矩阵）上面之间的边权一不一样。如果不一样的话就不能对应一棵树。</p>
<p>可以暴力或者 <code>LCA</code> 做。</p>
<p>注意特判！</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x]==x?fa[x]:fa[x]=find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> target[<span class="number">4005</span>],pre[<span class="number">4005</span>],last[<span class="number">2005</span>],w[<span class="number">4005</span>],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> ww)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">    w[tot]=ww;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> used[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> fir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(target[ptr]!=fa) &#123;</span><br><span class="line">            dis[fir][target[ptr]]=dis[fir][u]+w[ptr];</span><br><span class="line">            dfs(target[ptr],u,fir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">bool</span> flg=<span class="number">1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) rep(j,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w);</span><br><span class="line">        <span class="keyword">if</span>(w!=<span class="number">0</span>) flg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) e[++m].u=i,e[m].v=j,e[m].w=w,mp[i][j]=mp[j][i]=w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w!=<span class="number">0</span>) &#123;<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j]!=w) &#123;<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flg&amp;&amp;n!=<span class="number">1</span>) &#123;<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) fa[i]=i;</span><br><span class="line">    sort(e+<span class="number">1</span>,e+m+<span class="number">1</span>,cmp);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=find(e[i].u),v=find(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u!=v) &#123;</span><br><span class="line">            add(e[i].u,e[i].v,e[i].w);</span><br><span class="line">            add(e[i].v,e[i].u,e[i].w);</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            used[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) dfs(i,<span class="number">0</span>,i);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=e[i].u,v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(dis[u][v]!=e[i].w) &#123;<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2020游记</title>
    <url>/2020/08/WC2020%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>家里蹲。</p>
<p>明天就是人生第一次 WC 经历，感觉好紧张。。。</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>事实上，没什么好紧张的。</p>
<h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>看了看课表。</p>
<p>第二课堂讲线段树，感觉会比较难吧。</p>
<p>结果进去一看，从零开始讲线段树。。。</p>
<p>去第一课堂硬着头皮听了一会。。。又太难了听不下去。。。</p>
<p>很自闭，全程掉线。</p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>算法优化？？听听吧</p>
<p>怎么在讲二分啊？？</p>
<p>最后居然还讲了个网络流+二分的毒瘤题hhh</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><p>第二课堂是“图论中的相关算法”，听听吧。</p>
<p>草，一个上午才讲到最小生成树？？？</p>
<p>第一课堂什么神仙玩意？？？</p>
<h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2><p>“分治思想及其应用”，听听吧，说不定有 cdq、整体二分啥的。</p>
<p>还真有，赚了赚了</p>
<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><h2 id="上午-2"><a href="#上午-2" class="headerlink" title="上午"></a>上午</h2><p>第二课堂讲生成函数，几乎全程掉线。</p>
<h2 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h2><p>“从零开始学动态规划算法”。</p>
<p>这节课还不错。</p>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="上午-3"><a href="#上午-3" class="headerlink" title="上午"></a>上午</h2><p>只剩下第一课堂了，硬着头皮听吧。</p>
<p>“随机思想在 OI 中的应用”？</p>
<p>刚开始的时候：讲概率论啊。</p>
<p>然后后来就越来越变态，接着我就爬了。。</p>
<h2 id="下午-3"><a href="#下午-3" class="headerlink" title="下午"></a>下午</h2><p>讲爆搜的，这个还算能听。</p>
<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>考试日。</p>
<p>时间严重不足。</p>
<p>先看 T1。</p>
<p>感觉好神仙啊，看看测试点。</p>
<p><img src="/pics/1.png" alt=""></p>
<p>于是我就先敲了个 $O(n+qn\log n)$ 的暴力，10 分。</p>
<p>而且感觉后面的特殊性质很好玩的样子…</p>
<p>先看 T2 去。</p>
<p>T2 这题意有毒吧。。。还好有样例解释。。。</p>
<p>看了看，好像只会写暴力。</p>
<p>于是打了个 20 分的 $O(2^n)$ 做法。</p>
<p>去看 T3。</p>
<p>T3 先尝试写了一下 $N\le 1000$，$p=0$ 的背包，然后写挂了。。。过了很久还是没调出来，放弃。</p>
<p>然后写了一下 T3 的 $w_i=1$，$p=0$ 的做法，这个写对了。</p>
<p>暴力看了一下，很复杂，于是我先回去玩 T1 的特殊性质。</p>
<p>T1 这特殊性质我貌似只能搞出来一条链的情况，我太菜了。。。</p>
<p>而且还用了一个特别 sb 的方法搞，我居然写了个二分+树状数组。。。明明一个 $\lceil \frac{size_S}{2}\rceil$ 的事就能搞定。。。</p>
<p>wssb。不过写对了是写对了，T1 现在有 $20$ 分了。</p>
<p>然后去看 T3 暴力了，写了半天。然后到只剩半个小时的时候终于写出来了，于是我开始调试。</p>
<p>结果没调出来。。。</p>
<p>GG。。。</p>
<p>估分：$20+20+10=50$ 。感觉这次要拿 Fe 了。</p>
<p>smy 神仙估分 $10+20+20=50$，xcs 神仙貌似考炸了，估分 $10+0+0$。</p>
<p>下午讲题的时候，发现自己并没有听懂。</p>
<h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><h2 id="上午-4"><a href="#上午-4" class="headerlink" title="上午"></a>上午</h2><p>一上午的往年 NOI 选手交流，几乎全程摸鱼。</p>
<p>smy 神仙颓了很久的 tr，我颓了很久 OI-wiki 。</p>
<h2 id="下午-4"><a href="#下午-4" class="headerlink" title="下午"></a>下午</h2><p>要出成绩了。。。</p>
<p>首先是总的数据。$Au$ 线 $130$，$Ag$ 线 $75$，$Cu$ 线 $35$ 。</p>
<p>诶，感觉可以拿个 $Cu$ ？</p>
<p>然后是教学比赛的颁奖，感觉越来越紧张。。。</p>
<p>终于，到了选手颁奖的时候。</p>
<p>第一个公布的名单就是 $Cu$。</p>
<p>第 $2$ 页出现了 smy 神仙的名字！！smy $35$ 分 $Cu$！！！</p>
<p>然后紧接着，$40$……$45$……好多页，都没有我的名字。</p>
<p>随着页数的增加，公布的分数也离我的理论最高分越来越近……</p>
<p>我越来越紧张，越来越担心自己会挂分，甚至能听见我的心跳。</p>
<p>到了 $50$ 分的第一页，还是没有我的名字。</p>
<p>我焦急地等待着主持人把这页念完，主持人翻到了下一页。</p>
<p>我一眼就在中间看见了我的名字，我没挂分！！！$Cu$ get！</p>
<p>人生第一个奖牌，拿到了！</p>
<p>最终得分：smy $5+10+20=35$，我 $20+20+10=50$。</p>
<p>我现在还震惊我居然 $1$ 分没挂…</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年 8 月水题选做</title>
    <url>/2020/08/8%E6%9C%88%E6%B0%B4%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<p>这么快就 8 月了呢…</p>
<a id="more"></a>
<h1 id="8-1"><a href="#8-1" class="headerlink" title="8/1"></a>8/1</h1><p><a href="https://www.luogu.com.cn/problem/CF875F" target="_blank" rel="noopener">$\color{green}{\text{CF875F}}$</a></p>
<p>又一道想出结论之后就非常简单的题。</p>
<p>考虑把王子当成点，公主当成边，然后就求个最大生成基环树就好了。</p>
<p>求法魔改一下 <code>Kruskal</code> 就完事了。</p>
<h1 id="8-2"><a href="#8-2" class="headerlink" title="8/2"></a>8/2</h1><p>打了人生第一场 atcoder 。</p>
<h2 id="ABC-174"><a href="#ABC-174" class="headerlink" title="ABC 174"></a>ABC 174</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>sb 题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">30</span>)<span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>sb 题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;d);</span><br><span class="line">rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">double</span> k=<span class="built_in">sqrt</span>(<span class="number">1.0</span>*x*x+<span class="number">1.0</span>*y*y);</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=d)++ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br></pre></td></tr></table></figure>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>考虑模数周期性，然后这就是道 sb 题了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    mo=<span class="number">7</span>%k;</span><br><span class="line">    used[mo]=<span class="number">1</span>;<span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(mo!=<span class="number">0</span>) &#123;</span><br><span class="line">        ++ans;</span><br><span class="line">        mo*=<span class="number">10</span>;mo+=<span class="number">7</span>;</span><br><span class="line">        mo%=k;</span><br><span class="line">        <span class="keyword">if</span>(used[mo]) &#123;flg=<span class="number">1</span>;<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">        used[mo]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flg)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>考虑贪心。把所有的 R 移到它该移的位置（前面）即可。根本用不上改变颜色的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==<span class="string">'R'</span>) ++r;</span><br><span class="line">&#125;</span><br><span class="line">k=r;</span><br><span class="line">rep(i,<span class="number">1</span>,r) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==<span class="string">'R'</span>) --k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k);</span><br></pre></td></tr></table></figure>
<h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h3><p>二分。二分完了 <code>check</code> 随便写写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">int</span> kk=a[i]/x;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%x==<span class="number">0</span>) kk--;</span><br><span class="line">        now+=kk;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]),mx=max(mx,a[i]);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=mx;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h3><p>HH 的项链。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">rep(i,<span class="number">1</span>,m) asks[i].id=i,<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;asks[i].l,&amp;asks[i].r);</span><br><span class="line">sort(asks+<span class="number">1</span>,asks+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">    rep(j,now,asks[i].r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[a[j]]) modify(used[a[j]],<span class="number">-1</span>);</span><br><span class="line">        modify(j,<span class="number">1</span>);</span><br><span class="line">        used[a[j]]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[asks[i].id]=query(asks[i].r)-query(asks[i].l<span class="number">-1</span>);</span><br><span class="line">    now=asks[i].r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br></pre></td></tr></table></figure>
<h3 id="切题顺序：A-B-D-E-F-C"><a href="#切题顺序：A-B-D-E-F-C" class="headerlink" title="切题顺序：A-B-D-E-F-C"></a>切题顺序：A-B-D-E-F-C</h3><p>就这样愉快地 AK 了。</p>
<h1 id="8-3"><a href="#8-3" class="headerlink" title="8/3"></a>8/3</h1><p><a href="https://www.luogu.com.cn/problem/CF165D" target="_blank" rel="noopener">$\color{green}{\text{CF165D}}$</a></p>
<p>树剖裸题，只是因为有点忘记树剖怎么写了来练练手而已。</p>
<h1 id="8-5"><a href="#8-5" class="headerlink" title="8/5"></a>8/5</h1><p>晚上 CF 爆炸了。。。</p>
<h1 id="8-6"><a href="#8-6" class="headerlink" title="8/6"></a>8/6</h1><p>愉快的叉了几个同学昨天 CF 的 C 题。</p>
<p><a href="https://www.luogu.com.cn/problem/P3950" target="_blank" rel="noopener">$\color{green}{\text{P3950}}$</a></p>
<p>裸树剖题，很久以前写了但一直没调出来，今天调出来了。</p>
<p>原来是在跳重链的时候出了点锅。</p>
<h1 id="8-7"><a href="#8-7" class="headerlink" title="8/7"></a>8/7</h1><p><a href="https://www.luogu.com.cn/problem/P2787" target="_blank" rel="noopener">$\color{red}{\text{P2787}}$</a></p>
<p>开 26 棵线段树即可，但是不知道哪里写炸了全 WA。。。</p>
<p>另外，这题本来我想用珂朵莉树水的，结果发现它卡珂朵莉树。。。</p>
<h1 id="8-8"><a href="#8-8" class="headerlink" title="8/8"></a>8/8</h1><p><a href="https://www.luogu.com.cn/problem/P2837" target="_blank" rel="noopener">$\color{green}{\text{P2837}}$</a></p>
<p><del>不要说我做水题，是老师布置的</del></p>
<p>简单的线性 dp，设 $f_{i,0}$ 表示前 $i$ 头奶牛，第 $i$ 头奶牛是 $1$ 时需要改的最小数量， $f_{i,1}$ 则反之。</p>
<h1 id="8-9"><a href="#8-9" class="headerlink" title="8/9"></a>8/9</h1><p><a href="https://www.luogu.com.cn/problem/P2642" target="_blank" rel="noopener">$\color{green}{\text{P2642}}$</a></p>
<p>预处理一下前缀的最大子段和、后缀的最大子段和，然后枚举断点统计一下答案即可。</p>
<p><a href="https://www.luogu.com.cn/problem/P1982" target="_blank" rel="noopener">$\color{green}{\text{P1982}}$</a></p>
<p><del>人生苦短，我用 python</del></p>
<p>按照题意求一下前缀最大子段和，然后模拟一下。</p>
<p>但是会爆 <code>long long</code>，于是我们用 <del>python</del> 高精就能解决这道题目。</p>
<p><a href="https://www.luogu.com.cn/problem/P1043" target="_blank" rel="noopener">$\color{green}{\text{P1043}}$</a></p>
<p>简单区间 dp。</p>
<p>断环成链，设 $f_{i,j,k}$ 表示从第 $i$ 位到第 $j$ 位，分 $k$ 段得到的最大值。</p>
<p>然后设 $g_{i,j,k}$ 表示从第 $i$ 位到第 $j$ 位，分 $k$ 段得到的最小值。</p>
<p>随便转移转移就好了。</p>
<h2 id="Codeforces-Round-663-Div-2"><a href="#Codeforces-Round-663-Div-2" class="headerlink" title="Codeforces Round 663 (Div. 2)"></a>Codeforces Round 663 (Div. 2)</h2><p>今天打了场 CF。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1391A" target="_blank" rel="noopener">$\color{green}{\text{CF1391A}}$</a></p>
<p>发现 $1\sim n$ 即是合法的序列，直接输出即可。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1391B" target="_blank" rel="noopener">$\color{green}{\text{CF1391B}}$</a></p>
<p>找到右侧的 <code>R</code> 与下侧的 <code>D</code>，统计一下。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1391C" target="_blank" rel="noopener">$\color{green}{\text{CF1391C}}$</a></p>
<p>OEIS nb！</p>
<p>手玩一下，然后在 OEIS 上查 <code>0,0,2,6</code> 即可（</p>
<p>然后发现答案是 $n!-2^{n-1}$。</p>
<h1 id="8-10"><a href="#8-10" class="headerlink" title="8/10"></a>8/10</h1><p><a href="https://www.luogu.com.cn/problem/P5662" target="_blank" rel="noopener">$\color{green}{\text{P5662}}$</a></p>
<p>哈哈哈我发现我居然还没把去年 PJ AK掉。</p>
<p>大水题，对于每天都与后一天做差跑个完全背包就好了。</p>
<p><a href="https://www.luogu.com.cn/problem/P2871" target="_blank" rel="noopener">$\color{green}{\text{P2871}}$</a></p>
<p>背包裸题。</p>
<p><a href="https://www.luogu.com.cn/problem/P1164" target="_blank" rel="noopener">$\color{green}{\text{P1164}}$</a></p>
<p>背包裸题。</p>
<p><a href="https://www.luogu.com.cn/problem/P2639" target="_blank" rel="noopener">$\color{green}{\text{P2639}}$</a></p>
<p>背包裸题。<del>话说老师为啥留这么多裸题</del></p>
<p><a href="https://www.luogu.com.cn/problem/P1802" target="_blank" rel="noopener">$\color{green}{\text{P1802}}$</a></p>
<p>还是背包裸题。。。</p>
<p><a href="https://www.luogu.com.cn/problem/P1877" target="_blank" rel="noopener">$\color{green}{\text{P1877}}$</a></p>
<p><code>bool</code> 数组的背包 dp。</p>
<p><a href="https://www.luogu.com.cn/problem/P1510" target="_blank" rel="noopener">$\color{green}{\text{P1510}}$</a></p>
<p>还是背包裸题。。</p>
<p><a href="https://www.luogu.com.cn/problem/P1504" target="_blank" rel="noopener">$\color{green}{\text{P1504}}$</a></p>
<p>用背包看看哪些高度所有的城堡都能达到，然后取个最高的。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>luogu</tag>
        <tag>题解</tag>
        <tag>水题选做</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF506D Mr. Kitayuta&#39;s Colorful Graph</title>
    <url>/2020/07/%E9%A2%98%E8%A7%A3-CF506D-Mr-Kitayuta-s-Colorful-Graph/</url>
    <content><![CDATA[<p>神仙题。</p>
<p>暴力+暴力=AC。</p>
<p>没错，先想出两个暴力，然后拼起来，你就 AC 了这道题。</p>
<p><strong>用分块来选择用哪个暴力，可能也是一种正解的做法。</strong></p>
<a id="more"></a>
<p>首先我们能想到最无脑的暴力 1 。</p>
<h2 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力 1"></a>暴力 1</h2><p>对于每种颜色建一个仅含有这一种颜色的边的图，然后用并查集判连通，扫一次所有询问统计贡献。</p>
<p>时间复杂度：首先 $\operatorname{O}(m)$ 的枚举颜色，然后 $\operatorname{O}(n\alpha(n))$ 的建图+并查集（其实建图可以不用，直接并查集就够了），再加上 $\operatorname{O}(q\alpha(n))$ 的处理询问。总时间复杂度 $\operatorname{O}(m\alpha(n)(n+q))$ 。</p>
<p>这显然是过不了这道题的，那么我们再来想另一个暴力。</p>
<h2 id="暴力-2"><a href="#暴力-2" class="headerlink" title="暴力 2"></a>暴力 2</h2><p>其实只是对暴力 1 的一点修改。</p>
<p>对于每种颜色建一个仅含有这一种颜色的边的图，然后用并查集判连通，在每个连通块内枚举所有的点对 $(u,v)$ ，更新 $(u,v)$ 这个点对的贡献。</p>
<p>这个东西在连通块很小（连通块大小的平方小于 $q$ ）的时候会比暴力 1 更优一些。</p>
<p>时间复杂度：首先 $\operatorname{O}(m)$ 的枚举颜色，然后 $\operatorname{O}(n\alpha(n))$ 的建图+并查集（其实建图可以不用，直接并查集就够了），然后 $\operatorname{O}(n^2\alpha(n))$ 的算贡献。总时间复杂度 $\operatorname{O}(mn^2\alpha(n))$。</p>
<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>那么，我们就想到：可不可以在连通块大小的平方小于 $q$ 的时候用暴力 2 ，而在连通块大小的平方大于 $q$ 的时候再用暴力 1 呢？</p>
<p>当然可以。</p>
<p>什么时候一个颜色的图中每个连通块大小的平方都小于 $q$ ？</p>
<p>在 该颜色边数 $&lt;\sqrt{m}$ 的时候，所有这种颜色的所有连通块内点数的平方和不会超过 $n\sqrt n$ 。</p>
<p>于是，暴力 2 就可以胜任这部分的任务，复杂度 $\operatorname{O}(n\alpha(n)\sqrt n)$。</p>
<p>在 该颜色边数 $\ge\sqrt{m}$ 的时候，我们就可以用暴力 1 ，因为此时满足这种情况的颜色数量只会 $\le\sqrt m$。这样的话再扫一遍所有询问，复杂度是 $\operatorname{O}(\sqrt m(q\alpha(q)))$ 的。</p>
<p>这样，两个暴力拼起来，就打出了正解。</p>
<p>考虑实现统计答案时用 <code>map</code> 统计，复杂度应乘上 $\operatorname{O}(\log q)$。所以，总复杂度为：$\operatorname{O}((n\alpha(n)\sqrt n+\sqrt m(q\alpha(q)))\log q)$ 。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; e[N],qs;</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; ans,lst;</span><br><span class="line"><span class="keyword">int</span> f[N],sz[N],qto[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]==i?i:f[i]=find(f[i]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u=find(u);v=find(v);</span><br><span class="line">    <span class="keyword">if</span>(u!=v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sz[u]&gt;sz[v]) &#123;</span><br><span class="line">            f[v]=u;</span><br><span class="line">            sz[u]+=sz[v];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[u]=v;</span><br><span class="line">            sz[v]+=sz[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bao1</span><span class="params">(<span class="keyword">int</span> co)</span> </span>&#123;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) f[i]=i,sz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=e[co].begin();ii!=e[co].end();++ii) &#123;</span><br><span class="line">        merge(ii-&gt;first,ii-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=qs.begin();ii!=qs.end();++ii) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=ii-&gt;first,v=ii-&gt;second;</span><br><span class="line">        u=find(u),v=find(v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) &#123;</span><br><span class="line">            ++ans[make_pair(ii-&gt;first,ii-&gt;second)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bao2</span><span class="params">(<span class="keyword">int</span> co)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ps[N],tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=e[co].begin();ii!=e[co].end();++ii) &#123;</span><br><span class="line">        ps[++tot]=ii-&gt;first;</span><br><span class="line">        ps[++tot]=ii-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ps+<span class="number">1</span>,ps+tot+<span class="number">1</span>);</span><br><span class="line">    tot=unique(ps+<span class="number">1</span>,ps+tot+<span class="number">1</span>)-ps<span class="number">-1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,tot) f[ps[i]]=ps[i],sz[ps[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=e[co].begin();ii!=e[co].end();++ii) &#123;</span><br><span class="line">        merge(ii-&gt;first,ii-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,tot) &#123;</span><br><span class="line">        rep(j,i+<span class="number">1</span>,tot) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> u=find(ps[i]),v=find(ps[j]);</span><br><span class="line">            <span class="keyword">if</span>(u==v) flg=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(flg&amp;&amp;ans.count(make_pair(ps[i],ps[j]))) &#123;</span><br><span class="line">                ans[make_pair(ps[i],ps[j])]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;c);</span><br><span class="line">        num[c]++;e[c].push_back(make_pair(min(u,v),max(u,v)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,q) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(!ans.count(make_pair(min(u,v),max(u,v)))) &#123;</span><br><span class="line">            qs.push_back(make_pair(min(u,v),max(u,v)));</span><br><span class="line">            ++now;</span><br><span class="line">            lst[make_pair(min(u,v),max(u,v))]=now;</span><br><span class="line">            qto[i]=now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> qto[i]=lst[make_pair(min(u,v),max(u,v))];</span><br><span class="line">        ans[make_pair(min(u,v),max(u,v))]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&gt;=<span class="built_in">sqrt</span>(m)) &#123;</span><br><span class="line">                bao1(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> bao2(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,q) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=qs[qto[i]<span class="number">-1</span>].first,v=qs[qto[i]<span class="number">-1</span>].second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[make_pair(u,v)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年 7 月水题选做</title>
    <url>/2020/07/7%E6%9C%88%E6%B0%B4%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<h1 id="7-20"><a href="#7-20" class="headerlink" title="7/20"></a>7/20</h1><p>这个东西是为了膜 <a href="https://registergen.github.io" target="_blank" rel="noopener">RegisterGen神仙</a> 而发出来的。</p>
<a id="more"></a>
<p><a href="https://www.luogu.com.cn/problem/CF506D" target="_blank" rel="noopener">$\color{green}{\text{CF506D}}$</a></p>
<p>神仙题。</p>
<p>暴力+暴力=AC。</p>
<p>没错，先想出两个暴力，然后拼起来，你就 AC 了这道题。</p>
<p>详细见<a href="/2020/07/题解-CF506D-Mr-Kitayuta-s-Colorful-Graph">我的题解</a>。</p>
<h1 id="7-21"><a href="#7-21" class="headerlink" title="7/21"></a>7/21</h1><p>今天打了场 div2 的 CF 。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1382A" target="_blank" rel="noopener">$\color{green}{\text{CF1382A}}$</a></p>
<p>sb 题。找一下两个数组有没有相同的数，完事。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1382B" target="_blank" rel="noopener">$\color{green}{\text{CF1382B}}$</a></p>
<p>仔细想想，发现所有 $\ge 2$ 的数都可以换成 $2$ 。</p>
<p>再想想，对于一个 $2$ ，先取到它的人可以调整先后手顺序。</p>
<p>那么，拿到第一个 $2$ 的人就可以调整顺序，使得他拿到第二个 $2$ ，以此类推。</p>
<p>这样，拿到第一个 $2$ 的人就把调整顺序的主动权牢牢控制在了他手中。所以拿到第一个 $2$ 的人有必胜策略。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1381A1" target="_blank" rel="noopener">$\color{green}{\text{CF1382C1}}$</a> 和 <a href="https://www.luogu.com.cn/problem/CF1381A2" target="_blank" rel="noopener">$\color{green}{\text{CF1382C2}}$</a></p>
<p>这题没让我们最小化操作次数啥的，只用求出一个可行解就完事了。</p>
<p>那么我们就可以随便乱搞了。</p>
<p>想想有什么状态是这两个 $01$ 串都能达到的？而且很好写的？</p>
<p>当然是 $111\cdots1$ 啦！</p>
<p>那么我们就可以处理一下第一个串到 $111\cdots1$ 的操作、第二个串到 $111\cdots1$ 的操作，然后拼起来，完事。</p>
<p>处理这个操作怎么 $\operatorname{O}(n)$ 呢？</p>
<p>我们可以预处理这两个串的极大全 $0$ 子串，然后随便做就完事了。</p>
<h1 id="7-22"><a href="#7-22" class="headerlink" title="7/22"></a>7/22</h1><p>全天有课且无 CF ，咕咕。</p>
<h1 id="7-23"><a href="#7-23" class="headerlink" title="7/23"></a>7/23</h1><p>全天有课且无 CF ，咕咕。</p>
<h1 id="7-24"><a href="#7-24" class="headerlink" title="7/24"></a>7/24</h1><p><a href="https://www.luogu.com.cn/problem/P4768" target="_blank" rel="noopener">$\color{green}{\text{P4768}}$</a></p>
<p>终于 A 了归程！</p>
<p>若不强制在线，可以将询问按海拔排序用并查集处理。</p>
<p>强制在线就用可持久化并查集就完事了。</p>
<p>另外：关于 SPFA ，它死了。</p>
<h1 id="7-25"><a href="#7-25" class="headerlink" title="7/25"></a>7/25</h1><p>晚上有事，白天有课，咕咕。</p>
<h1 id="7-26"><a href="#7-26" class="headerlink" title="7/26"></a>7/26</h1><p>咕咕咕咕咕！</p>
<h1 id="7-27"><a href="#7-27" class="headerlink" title="7/27"></a>7/27</h1><p>晚上是学校集训的摸底赛，除了最后一题都很水。。</p>
<p>但是乐多赛这玩意真恶心。。</p>
<p>放一张榜：</p>
<p><img src="https://i.loli.net/2020/07/27/zoS6tyEfwCAlMBq.jpg" alt=""></p>
<p>orz 绵羊，rG %%%</p>
<h1 id="7-28"><a href="#7-28" class="headerlink" title="7/28"></a>7/28</h1><p><a href="https://www.luogu.com.cn/problem/CF547D" target="_blank" rel="noopener">$\color{green}{\text{CF547D}}$</a></p>
<p>一个很难想但是想出来了就很好写的题。</p>
<p>对于每个点，将它的 $x$ 坐标与 $y$ 坐标连边，然后跑一遍欧拉回路。</p>
<p>完事。</p>
<h1 id="7-29"><a href="#7-29" class="headerlink" title="7/29"></a>7/29</h1><p>咕咕咕咕咕</p>
<p>话说我咕的天数比 xcs 神仙多多了。</p>
<h1 id="7-30"><a href="#7-30" class="headerlink" title="7/30"></a>7/30</h1><p><a href="https://www.luogu.com.cn/problem/P5829" target="_blank" rel="noopener">$\color{green}{\text{P5829}}$</a></p>
<p>KMP 自动机的模板。</p>
<p>在 KMP 自动机上找两个前缀的 $\operatorname{LCA}$ 就好了。</p>
<h1 id="7-31"><a href="#7-31" class="headerlink" title="7/31"></a>7/31</h1><p><a href="https://www.luogu.com.cn/problem/P2503" target="_blank" rel="noopener">$\color{green}{\text{P2503}}$</a></p>
<p>《random_shuffle 在 OI 中的应用》</p>
<p><code>random_shuffle</code> 若干次，每次都贪心求一下答案然后取个 $\min$ ，就切了这道题。</p>
<p><a href="https://www.luogu.com.cn/problem/CF896E" target="_blank" rel="noopener">$\color{green}{\text{CF896E}}$</a></p>
<p>循环展开+玄学卡常的暴力艹过去了哈哈哈哈哈哈</p>
<h2 id="另外昨天打了一场-CF-Div2"><a href="#另外昨天打了一场-CF-Div2" class="headerlink" title="另外昨天打了一场 CF Div2"></a>另外昨天打了一场 CF Div2</h2><p>这场 D 题比较水，于是我先去做 D 。眼疾手快切掉了之后发现自己变成了 rk15 。。。</p>
<p>但是 C 题一直没有调出来。。。就眼睁睁看着自己名次掉啊掉挺难受的。。</p>
<p>最终结果，可以看见我的 C 题多么惨烈：</p>
<p><img src="https://i.loli.net/2020/08/01/SebJfLdps6wi1Tl.png" alt="CF.png"></p>
<p><a href="https://codeforces.com/contest/1388/problem/A" target="_blank" rel="noopener">$\color{green}{\text{CF1388A}}$</a></p>
<p>sb 结论题。大部分情况输出 <code>n-6-10-14</code> 就完事。</p>
<p>小部分无解、重复数字的情况讨论一下。</p>
<p><a href="https://codeforces.com/contest/1388/problem/B" target="_blank" rel="noopener">$\color{green}{\text{CF1388B}}$</a></p>
<p>也是道很好推的结论题。</p>
<p>可以发现让位数越大越好，那么每个数位就只能取 $8$ 和 $9$ 。</p>
<p>又因为他后头会擦掉一些位数，那么就把被擦掉的位数填上 $8$ ，剩下的填 $9$ 就能在最大化答案的同时最小化那个数。</p>
<p><a href="https://codeforces.com/contest/1388/problem/C" target="_blank" rel="noopener">$\color{red}{\text{CF1388C}}$</a></p>
<p>难受啊，考试的时候一直 <code>WA on pretest 3</code> 。没调出来。</p>
<p>思路就是先统计一下经过某个点的人流量，然后配合 $h$ 值求出到每个点的时候有好心情的人。</p>
<p>然后我就 <code>WA</code> 得很惨。。。但是思路是对的，就是小细节问题。</p>
<p><a href="https://codeforces.com/contest/1388/problem/D" target="_blank" rel="noopener">$\color{green}{\text{CF1388D}}$</a></p>
<p>当时写完 A 和 B 之后我直接去做 D 题了，因为我一眼看出了做法。</p>
<p>把 $b$ 数组看做下标之间的连边（$i$ 连向 $b_i$），那么这个 $a$ 数组之间就连成了一个 DAG 。</p>
<p>拓扑排序一下，如果当前的权值 $&gt;0$ 就把当前权值累加进下一个，然后按顺序丢进输出的序列。否则就不加，然后从末尾倒序丢进序列。</p>
<p>最后输出就按顺序输出那个序列就完事了。</p>
<p>当时我切掉 D 题是第 $37$ 分钟，全场 rk15 。</p>
<p>（截图只截到了 rk16 的时候）</p>
<p><img src="https://i.loli.net/2020/08/01/BPl7WT8QeSvuJoY.png" alt=""></p>
<p>后来嘛，就一直掉啊掉，C 题爆炸导致我一直掉到了 rk859 。</p>
<p>不过还是上分了的， <code>rating+=94</code> 。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>luogu</tag>
        <tag>题解</tag>
        <tag>水题选做</tag>
      </tags>
  </entry>
  <entry>
    <title>ZR2020春季NOIP模拟赛day4总结</title>
    <url>/2020/03/ZR2020%E6%98%A5%E5%AD%A3NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9Bday4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="be840ca8ecf2dcfa0e2f67641f8663d5c0849e1c3742c55f562b159bce9c50c0">a3e4f48b81db38135a5ff9adeee672dc202c767c025bac6bbf465deff10e4a8711aba74008397e266eef2d9b9ad75dffc952d6a6ee1fd944640ed39c6b4a68a1ffda5062de1fc206cd29cd43cf4dfd6b6e3ee40877de9ae01ff67da8df5b4824d82748e780c8fddec3a122f2762102b81e87c81ca924e1cb6b108f592e9699bc4122943dbc65a40f23c32bbd03589041ad739988590fd12859ff59d005d0cbc9f3b221b50818ba123dc671a33d525195dd895e753415fbebd3142e7fc538f9da0d34311041bef5e43b86af0bd02f0f61b7d0418d3cefbd745766a0ebf3f16ae153a4cf059f2cacb713332fb816288c30056a9b9328b5c956207e9a2ebd3399b9b6dab0408d56134fe53a683c2c2eed92421b7fd122b5130544ec4287ed361adf9060f90da227dc29bc5f8146e04d2613fb4a2c05e8134f25740a69ae8d085e9811827da3d57f56707bd7cbecd17e642e7515950cbbe02a42a013c4ba2c2c41fd99e8f9e31fcaa711c2008875c5d4eaf86c53838533fe89940d82532b64f4ddf772e6cfc516e217006f5602f53372b8cbd053558eb2a2438dbf41229acda4f786f40cfb2d4f8efd3ced4fa4be7351765db085a4851d8332d676b4ce2fe7f0da9ee39b3e030a34207745ce2e671496095bc1a5f45d016abf82ebf86dcc5efc98034a4d7f595d9f02c5e9b50f9390befa34bde926a5da188eeed4fbea6f6681de16a3bcaf4a4d5a7577d59021e834ae8d2edd7d63dddeca164cb7d8b1d713bde58f85761542ebb67bc59d50c75aeb4dd6eaeda109e1b572c2e4c8ce5f19e6c4afa16055e6bfae6bd3820252ee82759ca27c9e81d8ebc47e26af506bf81970c0f84e2c42e04dbca48ebc440c3e0018e0b645a5e4baa9ea35f6db14f7c17d1e853c67e3b2b535e638a397cbaf88b60ea7491a514a719c4ce2c657bba17318b8032c4436202b0dff199e227ecbc262937a4b263e6476c314fc3d90ab5ddd102a70085bad6dd2f5b7708e3811735843db8f101486c5440e695886f721a6537aa859fbebd81c948dc96d4736b858f1c58c984617a215a40e35c1a7a04d7813cb262d2684b1bae2c90de8b93e6a613e2a18c3eac871eb5e4fadea7a5429130513cf6d040d70f7e827515f1530211cfdea596418bec1312091b368e9855696fa7f727dc098f94128979a42a5ffe6d9550eb0845412b3ce688b68654c2f3f5a0981af6524f02bb4e305a96065fe45f3b4cff493a0d4000a2e6297bd776889bcdd40ea4c433edc841319f32fd4f65338af9b1674ee1aa5cd6cb9fa2415ed638d1f16d30507895f209685d455dff24a71f25e4db51cf0f3b73505329cff27b79262825183e5dc6552fbce43d78caeee91f4ff8c450da190028c4aeccc7e6671924fa27f3b0d8edf557958c95a647f3d72b118c2a5c896e420573fe584e695f1c8ac93cc17724b2aa86e5cda98fd0360c0549e43b58abac21318e48f04c28563acc27349dcdb5ce89a3dc873569ff4074e168f05f27465b8d17429840893f0f23b001ffff6a8160cba2dd875ce1f79e7a8819db6606cde337f7e041b353851131ea9949f31c74851d5d224f414c27fc9fc6c4a6db3b29477c36e7d83b6d89d65070f7fd6259ac114a26a6c003aefec35282283ff86d8d0b761a06e8182a7df12f43ec6fee2164b885f1b009ce72aef4736ab52d74d8e550fd4a4fb1a2c0371486aaf11d17fb283f140d4607002bb22dfa74e4879aa894fd763a293d803cb78f4bd50a89b5770fe16648a04cd8f15588ffbdf2f9c84fa15f0dd390526d0a0477a9d835db47bab61e643b02a372b440717cb99d91f002503717e7283c97d89d5b669467aa5ec2511ee8d96945fd3ba3dde9c70e5becc5ee1</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LuoguP1600 [NOIP2016]天天爱跑步</title>
    <url>/2020/03/%E9%A2%98%E8%A7%A3-LuoguP1600-NOIP2016-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1600" target="_blank" rel="noopener">题目传送门</a></p>
<h1 id="前置知识：树上差分"><a href="#前置知识：树上差分" class="headerlink" title="前置知识：树上差分"></a>前置知识：树上差分</h1><p>各位大佬们肯定知道在数组上差分是什么吧：差分数组中的值是原数组中这个位置与它左边（或右边，写法无所谓）位置的差。这个方法可以把“区间加”转化为“左端点加，右端点减”。</p>
<a id="more"></a>
<p>然后对于一个位置，它的值就是差分数组中的前缀和。</p>
<p>例如：一个数组 $[1,0,2,5,3]$。</p>
<p>它的差分数组就是 $[1,-1,2,3,-2]$ 。</p>
<p>在区间 $[2,4]$ 上 $+1$ ，就等价于在差分数组中下标为 $2$ 的地方 $+1$ ，下标为 $5$ 的地方 $-1$ 。差分数组变为 $[1,0,2,3,-3]$。</p>
<p>此时求原数组下标为 $4$ 的地方就是求差分数组的下标范围 $[1,4]$ 的和，为 $6$ 。</p>
<p>类似地，我们可以把差分这个算法转化到树上。</p>
<p>设差分数组为 $b$ ，对于树上的一个路径加 $1$ ，例如 $u\to v$ 这条路径上面所有点的权值 $+1$ ，我们可以把它转化成 $b[u]$ 加 $1$ ，$b[v]$ 加 $1$ ，$b[\operatorname{lca}(u,v)]$ 减 $1$ ， $b[fa[\operatorname{lca}(u,v)]]$ 减 $1$ 。最后对于一个点上的权值，我们求这个点的差分数组的子树和就可以了。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>《算法竞赛进阶指南》大法好！</p>
<p>首先对于每个玩家的跑步路线，我们把它拆成两段： $S_i\to \operatorname{lca}(S_i,T_i)$ 和 $\operatorname{lca}(S_i,T_i)\to T_i$（不包括 $\operatorname{lca}(S_i,T_i)$ ）。</p>
<p>然后分开考虑：</p>
<ol>
<li>若一个观察员 $x$ 处在 $S_i$ 到 $\operatorname{lca}(S_i,T_i)$ 的路径上，当且仅当 $deep[S_i]-deep[x]=w[x]$ 时，这个观察员可以观察到这个玩家 $i$ 。其中 $deep$ 数组表示节点的深度。</li>
<li>若一个观察员 $x$ 处在 $\operatorname{lca}(S_i,T_i)$ 到 $T_i$ 的路径上，当且仅当 $deep[S_i]+deep[x]-2\times deep[\operatorname{lca}(S_i,T_i)]=w[x]$ 时，这个观察员可以观察到这个玩家 $i$ 。</li>
</ol>
<p>对于情况一，把关于 $x$ 的项都移到等式右边，得到 $deep[S_i]=deep[x]+w[x]$ 时，这个玩家可以被位于点 $x$ 的观察员观察到。</p>
<p>那么这种情况就转化为：每一个玩家在 $S_i$ 到 $\operatorname{lca}(S_i,T_i)$ 的路径上放一个类型为 $deep[S_i]$ 的物品。最后求任意 $x$ 处的类型为 $deep[x]+w[x]$ 的物品有多少个。</p>
<p>看到这里，就知道可以用树上差分了！</p>
<p>“路径 $u\to v$ 上放类型为 $k$ 的物品”可以转化为：在 $u$ 处产生一个物品 $k$ ， $v$ 处也产生一个物品 $k$ ，在 $fa[\operatorname{lca}(u,v)]$ 处减去两个物品 $k$ 。然后对于一个点上拥有的物品，我们求这个点的子树中所有的物品即可。</p>
<p>情况二类似，请读者自行推导（<del>或者看《算法竞赛进阶指南》中的结果，只要你有</del>）。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> grep(u) for(int ptr=last[u];ptr;ptr=pre[ptr])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">5</span>,LOGMAX=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s[N],t[N],w[N];</span><br><span class="line"><span class="keyword">int</span> target[<span class="number">2</span>*N],pre[<span class="number">2</span>*N],last[N],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deep[N],bel[N][LOGMAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    deep[u]=deep[fa]+<span class="number">1</span>;</span><br><span class="line">    bel[u][<span class="number">0</span>]=fa;</span><br><span class="line">    rep(i,<span class="number">1</span>,LOGMAX<span class="number">-1</span>) &#123;</span><br><span class="line">        bel[u][i]=bel[bel[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    grep(u) <span class="keyword">if</span>(target[ptr]!=fa) dfs(target[ptr],u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bok1[N],bok2[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[u]&lt;deep[v]) swap(u,v);</span><br><span class="line">    per(i,LOGMAX<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(deep[bel[u][i]]&gt;=deep[v]) u=bel[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line">    per(i,LOGMAX<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(bel[u][i]!=bel[v][i]) u=bel[u][i],v=bel[v][i];</span><br><span class="line">    <span class="keyword">return</span> bel[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c[N*<span class="number">2</span>],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=c[w[u]+deep[u]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok1[u].begin();ii!=bok1[u].end();++ii) ++c[*ii];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok2[u].begin();ii!=bok2[u].end();++ii) --c[*ii];</span><br><span class="line">    grep(u) <span class="keyword">if</span>(target[ptr]!=fa) dfs1(target[ptr],u);</span><br><span class="line">    <span class="keyword">int</span> ans=c[w[u]+deep[u]]-now;</span><br><span class="line">    sum[u]+=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=c[w[u]-deep[u]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok1[u].begin();ii!=bok1[u].end();++ii) ++c[*ii];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok2[u].begin();ii!=bok2[u].end();++ii) --c[*ii];</span><br><span class="line">    grep(u) <span class="keyword">if</span>(target[ptr]!=fa) dfs2(target[ptr],u);</span><br><span class="line">    <span class="keyword">int</span> ans=c[w[u]-deep[u]]-now;</span><br><span class="line">    sum[u]+=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s[i],&amp;t[i]);</span><br><span class="line">        <span class="keyword">int</span> lca=query(s[i],t[i]);</span><br><span class="line">        bok1[s[i]].push_back(deep[s[i]]);</span><br><span class="line">        bok2[bel[lca][<span class="number">0</span>]].push_back(deep[s[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    rep(i,<span class="number">1</span>,n) bok1[i].clear(),bok2[i].clear();</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> lca=query(s[i],t[i]);</span><br><span class="line">        bok1[t[i]].push_back(deep[s[i]]<span class="number">-2</span>*deep[lca]);</span><br><span class="line">        bok2[lca].push_back(deep[s[i]]<span class="number">-2</span>*deep[lca]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%d "</span>,sum[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ZR2020春季NOIP模拟赛day3总结</title>
    <url>/2020/03/ZR2020%E6%98%A5%E5%AD%A3NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9Bday3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="b24e8cda58b901643ba832c5a81be566451b2c318c7e79211237f7bdd70a09af">2610e6f9332f0e99dc1d9430e23048d6cf0ef08c8ac1e07d3300ae0f9e4dc84914bb775af9d74637b7ea2d72de7c0093e2d8fc336dfd2107a359a9d1633b3309492529a2fbba8e671ae28303f0c36f92ca6a83f9923a00816c057fe1b0fffb40127d0d0c09b2cbec5b933908e4c20840c94faf172bdef113d421d29633cb0e3ff427ddb92b41095869bd43c077622e7302968bc7a0e23a762c0a238b59c9000b49e47699b55cbc4d102d4c8c0d590dcea52cf35681205b87dddff65f412efe65b4d9fcd3db54231be0a986ea67b3d29ae39aaf05bac7a2d9849f246953404e60474516143ad0f851b12a58eff36ea7c399022e3113dd2a075aae99c686f8896d4b0ee93c1c0a245d9385e81a5a69dd459caacea6cd8e800c8abe47bbf98f822269a0b5e55aa88b2c2623cb695c161c31be360aed4041357ba8de0f8afe729d4a942869c517f1be2f91b291a60f17c96730bc7ce8a806de55916b85011aa3cdc638cb7643971bcdeb1ef4d6114d057fe33494c5516d20c406d97a357fe6b7dd8854e0bbfe7133e165f4b04d8e28a6bd4bd7c4776cd1443e641e4cf35c8a510571c8c8f5df82678cf240f9079babbd066b4c938a91d0720fe6ae18e5185e5ac2f6dba38d73dbb823f74391a729aacec44a409dd9593d35a80cd81aaf613e854527488b0e56a1954e81897e9a16e69fc43d23af136f8f0619d66447bd3bebd0aa92291ba1a2dc56d0b2f24987a0431204f755c36113a03d5f95328df135f04d2477c1d35fdfe2d58ebb76d820cca948655731e5b6c640a1c0e100ab6fb30a3678a948b5ea67100e2b9eead25523a422a205a7bc79abf48b9ba05a6a6bf33a0d6a6bf18193d7f07560b615bcb9af1ce5c07f7e997096ee5fc73b55fdd7cb48546e0c2846820a1149e0390bdcd003dc0b0617b47984a4766ebbfccccca4edbc8e877bc45e8e8b12d023ccc5ca9e49f09c7c3fdd1806644d05074015690454777646afba4601ebf4cdbeee2f88f246d949c6b9af708ca12e1631c02b2324e3b2b511d73af600b6163bdb42cba841d1691e53e7a994f554a15d03f7bd58cd809d190b3240539901cce89a6a7c94b233638af9f9212948e0df07b4fb287f04d0370ffa0ba8a631dc65c74100ed1da06e6e56a7474e520b4ddb6f82226cdbba2ebfc43788b6f02df9b6bc17491a3310b52633aba46dffe621694b25f8ed1d0d047b7abc9f48ed4aaa78ae91a4869101c65c5d8e10a0135d59b11bbd7e3f12ab6fa40689a6084c209b5de60e5e6d7461590034decf15b9ae3bc2bb926a88a45bb0dcff3efa8dda47ed8c6fbd7dfc42583e03a5227ec2dac767783ba52c5b90f969ac8a2629b5c854fe8383293994563a408a634accea1054add2353f2d24d1bc9d958f2a5a3b0165960591b8541b4ad08e7a48fa5362d6a49ad3b3e9a423a97437735b11af021c5eb97441aceabc51ab7d00553e3a0238a9b7688f6fb7d77a27d7ab1d40c39c84d23fe16efb0cdd8fa508ab76572e12cbb94fa0248e5f5b27ae8a2faad76039a75bbcef28c6ff28560f3d2da5eccb4dc3c660bb79abdc67021d05cb0cc1cb475660fea10db6bb84bef819e19e87872f65ec31cdf4e4b50be64ff49a3df92e6372a4ecb8f17fa3bd598420684c18e966b03e041d38a407eb7438924ccbd4fcd3f05cffcca25232049568fb2b78451d069712fda62ae978d9b68904e393a7f17a9fc33c36660d9cfd0af38165de075dc5554fb9c98975e2bab1467c1b86c01529638273c8b9fe7d70cde6840337a8e7f5a852ab546f840f2984791f9c67a74313801fc6fe59b46b1e438a4ace59c17606599b6142c6c00abe455f7ed4f0d95b0ac885fe80b3afb0094a038ea864f519561685c05b94078c7916bba2c39113b81c0586fab8c945f786bc9bf8ac4868fc1bb7edd3332326b3ca8a3cc4e24df52cb0ff96bd89268bf78f15a7de1e8a9b172cbf4004bbc2c057322b91b3fe584943f679fe3a79a4cc4bc41f9cc130f0e34d14c276440ca60efdaf340118085eed4b8f9210b2779ad3699e68d5f88ca0e9172ac1f45a7f9f5133a2f8c79d99e8e88d68b67d3842a07e20e1b40ffa91e1dcc3189e5b33deba0ee60b7e7d6fa2ecd5795dd11cd9a513ee1b27e2342bb6d0dd9275ed714495ccfef3298b9462a4e91c32</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LuoguP2602 [ZJOI2010]数字计数</title>
    <url>/2020/03/%E9%A2%98%E8%A7%A3-LuoguP2602-ZJOI2010-%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2602" target="_blank" rel="noopener">题目传送门</a></p>
<p>题意：给定两个正整数 $a$ 和 $b$ ，求在 $[a,b]$ 中的所有整数中，每个数码各出现了多少次。</p>
<p>数据范围：$a\le b\le 10^{12}$</p>
<p>首先，这道题显然是数位 DP 的套路题（统计某个区间内满足某个性质的数有多少之类的题基本都是数位DP）。</p>
<a id="more"></a>
<p>设状态 $f[i][sum]$ 表示已经考虑到了前 $i$ 位，目前的某个数码 $d$ 的个数为 $sum$ 。</p>
<p>我们可以转移：$f[i][sum]=\sum f[i-1][sum-(now==d)]$ ，其中 $now$ 表示考虑的第 $i$ 位上的数码。</p>
<p>采用记忆化搜索进行转移处理数位 DP 是很方便的，具体实现见代码（有注释）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">15</span>][<span class="number">15</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,num[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> sum,<span class="keyword">int</span> d,<span class="keyword">bool</span> lim,<span class="keyword">bool</span> zer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    x表示当前到了第几位，sum表示当前答案，d表示需要处理个数的数码，</span></span><br><span class="line"><span class="comment">    lim表示是否在上界，zer表示是否为前导0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="comment">//递归到终点了，返回答案</span></span><br><span class="line">    <span class="keyword">if</span>(~f[x][sum][lim][zer]) <span class="keyword">return</span> f[x][sum][lim][zer];</span><br><span class="line">    <span class="comment">//给f数组加入了lim和zer两个0/1量来保证返回的数据是符合当前条件的。</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,lim?num[x]:<span class="number">9</span>) &#123;</span><br><span class="line">        <span class="comment">//这里判断lim是为了处理在上界时只能for到b的那一位的情况。</span></span><br><span class="line">        <span class="keyword">if</span>(zer&amp;&amp;i==<span class="number">0</span>) ans+=dp(x<span class="number">-1</span>,sum,d,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//前导的0不计入答案。</span></span><br><span class="line">        <span class="keyword">else</span> ans+=dp(x<span class="number">-1</span>,sum+(i==d),d,lim&amp;&amp;(i==num[x]),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][sum][lim][zer]=ans; <span class="comment">//赋值用于记忆化。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) num[++tot]=x%<span class="number">10</span>,x/=<span class="number">10</span>; <span class="comment">//拆位。</span></span><br><span class="line">    <span class="keyword">return</span> dp(tot,<span class="number">0</span>,d,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%llu%llu"</span>,&amp;a,&amp;b);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">9</span>) <span class="built_in">printf</span>(<span class="string">"%llu "</span>,sol(i,b)-sol(i,a<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ZR2020春季NOIP模拟赛day2总结</title>
    <url>/2020/03/ZR2020%E6%98%A5%E5%AD%A3NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9Bday2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="a711f5d457d0605b8b01f279dae50879650e37eb9d9f8d113735581bab1b1534">fc64cbd0556ec1bf561d9ef649835821ef2e62a9e0abb9292ff81767627d374e5d09c68ea842cc6d931e510ca79fd058df85115dcb8a64175493c45adaeb56ef51462976fc1850a9c5f5d33ad4c0cdc1c2c2d9158965281e9aec01905254cdcfc5c7a6a5409458e369630e3696222b25c6461ff5b804babd3f15968222c414b35d840b6734cd4034b0d60e03436c7c875ac150c48bc8bf2ff670c7674a2d668665adbf0ebf28eae3fa72d548298c70b893a1f7dd938faf0d084b9f6e6415c09771c7d684b20cdf6c3e70f9fef0431f5fe3cf9e48c57a1caf93ea1c8eae86f7ba9f97ce5a01331a58ace09675237d795e640959e01b6bf5601a5e05cd8e3971c9661895cfd40adcc14d3fc7c5cd353ddc92c7f452d45870d5920bc670074fa7d863581e9bc7008e98135f91b45892ad45aa62af6f3c9d31bd0b318cb42c69133835bf6d483f399fad4af89093a32f53753609c2c00519d7e83df9afcb81697e168e9f19dd37d3f71759a4e08286a04507fe310aee2c0c18e3fc6832240f31e0b04da32b67eb79ff26d589b40f7f780ce0c4f3586880bc56f4b5df8edbe4cb3b618b66a6480816c26cd2a324792e87f54be2dbfd6e377ef179c98175ae4ec39d415bdb408fd16040b10f0e7fb6361c17989d971d0ad9361926f71aaabb70c6c9a73792ebdf670e08b544aff740196a6e2aa558c60a45a3077aeb10fd6306e651e4a498c84b3951cc4855553e29fa02397905f54215d28c195bcbe63ab77be3bd3384701960b7fdeddea6ab50cf74a50bdd0d3f3a6f14a7c1a8d993441d43e6af6ff70935a98b363ff68f2d51764d72c2bc96924b4200bcf1f99cff812aa0595733d4e9b2f0687d28f2d8d8cdc986fd0f85a821cc7b3d0b9a6412e13773bf926036458579e2a995337d8a5542096e1081db6fe66a22af3c9cce8b358488a2e9658bd434514b2e310c19b7a8f4c86253617b040b6988e61845daf7dba87e950ed61f600cacee5c9c1e2819070e54f827672baffa31729309f195d4fafa88a372d5f5c5bbbd77efa498a7cb00642792cced7c8e2172fd47befec5aa260ee2d17663c1374e9930410ab8e73afe3e4be4a020e86e2a0e4e1641ff229b5c8a68fdefe5b487955c4e60dc5131d7829d76332ded246669683e76744d88f7f1c93121224aef4a6e53b31c6e93f017f269a15d0afbd24ccc7fcdadd55e75895f98df6194e1a5fb448ab76c01f86ac8a996651e4834e25303f34c2af5635ede5f00795e8d7440a62ace7409903cd44aaf7a2bf19c142bb8fdb676a35003a016af7376fae7094db8c20e8deda3d6d9d098c9f3d93e37ea547de865c98869a9464c311f1fedc66719469e6bd6e8f9298db2bc54c4c58a1ae5a4c96a67f4139b6bac4a26314594668238f3d2a0759d4d222b2e1dafa5c1fbaf784101af22e3a69b4383470f5bc11b08dc413776664a724982c6f7770014d50654b3a3b97c782287e314f57eceb85a9d91d2e9869fdb3ca7fc9161a31efb67f37fea6d9f5acd95e8cdbe680eea02537f51cb28411d0f101465d7c1166192631d8fd06e660528a4c5cb1cb21059827b34abe297bf577f6fb6a578998a269ba0afbbfcc6353008441ad82d774824391f8ab1d6fe780ac70ffefa540aa3d703b88b449fc15af0320d35f25b0eb39cb8ab3ba52b0dd8f6b98b1dab686b648e70f405aab7c34ecf3a8b3875834e4bb5cabd3f1d3c3ea4512f4772ce1b515008f4256d1b149e09c86956c5a396654e5f259c7024385d088377d1487ee2c0a3fd03cdeeb20c4d77284187eb54bb11df60a96191f28459503b92faeee26a114d37c7560f04f43c8cfd88971071c73154c2fdd2d01f49f36b3849b145eaa9b0ce9013ef6a4288709690282fded40e5c1e7f4d3959d517ea92032b079eac518d81043b1d0133951859a4927ebe9ca62abf3faa5df0922097ab2d159027a00f2efc005cf90512efe33e61e833298a41e2cb1c586d54609d4bdeb2377de20831ff71f7a46dfa19307eea2c3a0ab5c8a9806b09e9458ac5a176b404feaf7a57762ab9d9ed1e8253f89909d4c80caefc3e0123592637e866fd4e3d902fcf8982127983c9a3808121ec980a2e5f14a4bd8b020b07e46a52f6689759c0cb12659f6b80f438af5701954166044798e84e28d6f0d990d46a8ecfe7e17741f3b3345f0b495338e1d1276236bced4118fbb52d02fbdd46faae207161ac593e40a8a0c5434961fe71a91ae27e2c940a450b112fc1540186dd329bb13b907eba2f9d5296017b5669235b6393fd12f184f2b351575f331cab32f576d1f9fef617e4b36853660991419d75f447383c234b13a0d1ed13cfe844b45c1da241e5c1b76dedf7d26bed902e31ebf50f90f621e07595ede313d41b6b9bed8bbbfdff0f6f46daf7c53b2d5b52ab402512dc9e5bdd906ccd73103d6957109067064e77928f0339d93c1be532f313919e86ebb8e93dfd61943524ec7e89503dff3509be149eb4ab34acc0e2378a0b8c6c6da5fd6617de9fc5896a6864c906b20c5ee69bebafd6e8a425bac4384c983668e2b1ed1cc7c9af594a6c32e52ae06c10a78af37b399e74b2f67d71abaccf8b5a6937b5e7a42050a2dbc26cb385a44d811d609377ff8e7c32580d3027e83a8b4a5753326a150207ed92dad56aee7f2e1a2fec96207972e8a7aa02c149d5af5c2c314b68513dab8f4fbfc696a8c4be8138cdcdc7b56a534f46a729b357eb327beb0ce2aa100cc14ac64cbbebaaf5de7b406773415896cdd7e01001207fe03dccf27e8e425d437042afa6692dfd921930666cb9b77aee1d0fde2f68f7c2bcfea5df33e2430b27291b7adc5812a0a5e0aa</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LuoguP3469 [POI2008]BLO-Blockade</title>
    <url>/2020/02/%E9%A2%98%E8%A7%A3-LuoguP3469-POI2008-BLO-Blockade/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3469" target="_blank" rel="noopener">题目传送门</a></p>
<p>题意：有$n$个点、$m$条边的无向图，对任意$1\le i\le n$，求出将第$i$个点和与其关联的边删去时，有多少个有序点对$(u,v)$满足$u$和$v$不连通。</p>
<p>显然，这道题需要用到割点。</p>
<a id="more"></a>
<p>先考虑$i$不是割点的情况。因为$i$不是割点，所以把$i$和与其相关联的边去掉时，其他$n-1$个点依然是连通的。因此答案为$2(n-1)$。（注意题目中说的是<strong>有序点对</strong>）</p>
<p>然后来考虑$i$是割点的情况。</p>
<p>很显然，若$i$是割点，删去$i$和与其相关联的边后，原图会变成若干个连通块。那怎么求这些连通块的大小呢？</p>
<p>我们思考一下：tarjan算法是如何判定割点的？</p>
<p>答案是：在搜索树上，如果$i$不是根节点，则如果有任意$son_i$满足$dfn[i]\le low[son_i]$，$i$即为割点。当$dfn[i]\le low[son_i]$时，$son_i$除了往上走树边到达$i$以外不能到达$i$子树外的地方，也就是说删除$(i,son_i)$这条边后，图会分为$son_i$的子树与其它这两个部分。所以$i$就是割点。</p>
<p>所以这道题的答案就很显而易见了：对任意满足割点判定式$dfn[i]\le low[son_i]$的儿子$son_i$，在删去$i$和与其相关联的边后，$son_i$的子树会变成图中的一个单独的连通块。因此我们只需要在tarjan找割点的同时统计一下这些子树的大小加进答案里即可。</p>
<p>别忘了还有一个连通块是除了$i$子树以外的所有点。</p>
<p>Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,M=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> target[M],last[N],pre[M],tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],sz[N],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u]=<span class="number">1</span>;</span><br><span class="line">    dfn[u]=low[u]=++cnt;</span><br><span class="line">    <span class="keyword">int</span> flg=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> iscut=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=target[ptr];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            sz[u]+=tarjan(v);</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;=dfn[u]) &#123;</span><br><span class="line">                ++flg;</span><br><span class="line">                ans[u]+=sz[v]*(n-sz[v]);</span><br><span class="line">                sum+=sz[v];</span><br><span class="line">                <span class="keyword">if</span>(u!=<span class="number">1</span>||flg&gt;<span class="number">1</span>) iscut=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> low[u]=min(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iscut) ans[u]+=(sum+<span class="number">1</span>)*(n-sum<span class="number">-1</span>)+(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> ans[u]=<span class="number">2</span>*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> sz[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    tarjan(<span class="number">1</span>);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>题解UVa1220 Hali-Bula的晚会</title>
    <url>/2020/02/%E9%A2%98%E8%A7%A3UVa1220-Hali-Bula%E7%9A%84%E6%99%9A%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="刘汝佳大法好！"><a href="#刘汝佳大法好！" class="headerlink" title="刘汝佳大法好！"></a>刘汝佳大法好！</h1><p>是不是感觉看到这题很熟悉？好像很像<a href="https://www.luogu.com.cn/problem/P1352" target="_blank" rel="noopener">没有上司的舞会</a>这题诶！</p>
<p>可是我们发现，这里还新加了一个“判断唯一性”的任务。</p>
<a id="more"></a>
<p>我们定义：</p>
<p>$d(u,0)$表示不选$u$的$u$的子树的最大独立集的节点个数</p>
<p>$d(u,1)$表示选$u$的$u$的子树的最大独立集的节点个数</p>
<p>$f(u,0)$表示不选$u$的$u$的子树的最大独立集的唯一性（$0$不唯一，$1$唯一）</p>
<p>$f(u,1)$表示选$u$的$u$的子树的最大独立集的唯一性（$0$不唯一，$1$唯一）</p>
<p>则</p>
<script type="math/tex; mode=display">d(u,1)=1+\sum_{(u,v)\in E}d(v,0)</script><script type="math/tex; mode=display">d(u,0)=\sum_{(u,v)\in E}\max\{d(v,0),d(v,1)\}</script><p>以上两个就是求最大独立集的转移方程。</p>
<p>然后考虑怎么判断唯一性。</p>
<p>对于$f(u,1)$的情况：如果$u$的任意一个儿子$v$的$f(v,0)=0$，那么$f(u,1)$就等于$0$。</p>
<p>对于$f(u,0)$的情况：设$v$为$u$的任意一个儿子</p>
<ul>
<li>若$d(v,0)=d(v,1)$，则$f(u,0)=0$。</li>
<li>若$d(v,0)&gt;d(v,1)$且$f(v,0)=0$，则$f(u,0)=0$。</li>
<li>反之亦然。</li>
</ul>
<p>以下为代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot=<span class="number">0</span>,target[N],pre[N],last[N];</span><br><span class="line"><span class="keyword">int</span> d[N][<span class="number">2</span>],f[N][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!last[u]) &#123;</span><br><span class="line">        d[u][<span class="number">0</span>]=<span class="number">0</span>;f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        d[u][<span class="number">1</span>]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][<span class="number">1</span>]=<span class="number">1</span>;f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    d[u][<span class="number">0</span>]=<span class="number">0</span>;d[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        dfs(target[ptr]);</span><br><span class="line">        <span class="keyword">if</span>(f[target[ptr]][<span class="number">0</span>]==<span class="number">0</span>) f[u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        d[u][<span class="number">1</span>]+=d[target[ptr]][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v=target[ptr];</span><br><span class="line">        <span class="keyword">if</span>(d[v][<span class="number">0</span>]==d[v][<span class="number">1</span>]) f[u][<span class="number">0</span>]=<span class="number">0</span>,d[u][<span class="number">0</span>]+=d[v][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[v][<span class="number">0</span>]&gt;d[v][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[v][<span class="number">0</span>])f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            d[u][<span class="number">0</span>]+=d[v][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[v][<span class="number">0</span>]&lt;d[v][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[v][<span class="number">1</span>])f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            d[u][<span class="number">0</span>]+=d[v][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">string</span> x,y;</span><br><span class="line">        mp.clear();</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        mp[x]=++cnt;</span><br><span class="line">        rep(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(!mp.count(x)) mp[x]=++cnt;</span><br><span class="line">            <span class="keyword">if</span>(!mp.count(y)) mp[y]=++cnt;</span><br><span class="line">            add(mp[y],mp[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">1</span>][<span class="number">0</span>]==d[<span class="number">1</span>][<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">"%d No\n"</span>,d[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[<span class="number">1</span>][<span class="number">0</span>]&gt;d[<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!f[<span class="number">1</span>][<span class="number">0</span>]) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[<span class="number">1</span>][<span class="number">0</span>]&lt;d[<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!f[<span class="number">1</span>][<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>题解UVa12186 工人的请愿书</title>
    <url>/2020/02/%E9%A2%98%E8%A7%A3UVa12186-%E5%B7%A5%E4%BA%BA%E7%9A%84%E8%AF%B7%E6%84%BF%E4%B9%A6/</url>
    <content><![CDATA[<h2 id="刘汝佳大法好！"><a href="#刘汝佳大法好！" class="headerlink" title="刘汝佳大法好！"></a>刘汝佳大法好！</h2><p>设$dp(u)$表示让$u$号员工给上级发信至少需要多少个工人。</p>
<p>那么假设$u$的子节点个数为$k$个，则至少需要$c=(kT-1)/100+1$个直接下属发信才可以让$u$号员工给上级发信（注意以上公式括号内的$-1$是为了防止$kT$为$100$的倍数而减一的）。</p>
<a id="more"></a>
<p>则我们更新$dp(u)$的方法是：将$u$的$k$个下属中$dp$值最小的$c$个做和，即可保证$dp(u)$是最小的。</p>
<p>最后答案就是$dp(0)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="keyword">int</span> target[N],pre[N],last[N],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot] = v;</span><br><span class="line">    pre[tot] = last[u];</span><br><span class="line">    last[u] =  tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!last[u]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp[N],cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        tmp[++cnt]=dfs(target[ptr]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ned = (cnt*t<span class="number">-1</span>)/<span class="number">100</span>+<span class="number">1</span>,dp=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,ned) dp+=tmp[i]; <span class="comment">//取最小的c个dp值</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;t)&amp;&amp;n&amp;&amp;t) &#123;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            add(x+<span class="number">1</span>,i+<span class="number">1</span>); <span class="comment">//这里我把点的编号加一了，从0~n变成了1~n+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dfs(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-J/S 2019游记</title>
    <url>/2020/02/CSP-J-S-2019%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>日常肝作业+复习到12点.jpg</p>
<p>瞎背了背板子，在背匈牙利的时候被rui_er大佬喷了：</p>
<blockquote>
<p>rui_er: “匈牙利多简单~”</p>
</blockquote>
<p>dijkstra这么zz的算法都经常背错，我也是自闭了…</p>
<p>爆0预定</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>昨天没睡好.jpg</p>
<p>忍着眼皮子想要打架的欲望起了床。。。</p>
<p>开始一天的旅程</p>
<p>首先临阵擦枪，在车上背了背LCA板子，又复习了一下dijkstra <del>（尽管这两天都没用到）</del></p>
<p>迷迷糊糊走进了考场</p>
<h2 id="Senior-Day-1"><a href="#Senior-Day-1" class="headerlink" title="Senior Day 1"></a>Senior Day 1</h2><p>三样密码都没猜对</p>
<p>看T1</p>
<p>诶诶诶T1这不是道**题吗？</p>
<p>赶快A掉，看T2</p>
<p>我先花了半个多小时好不容易YY出了一条链情况的$O(n)$算法</p>
<p>又花了十几分钟打了一下。本来冲着100分去的，但是由于我太菜，代码能力有点弱，70跑路（100看脸，能被半链半菊花卡死）</p>
<p>T3是什么？能吃么？10分走人</p>
<p>回去检查T1T2</p>
<p>文件名都没问题</p>
<p>看看数据范围</p>
<p>诶诶诶T1我$n=63$怎么炸了？</p>
<p>赶快<code>unsigned long long</code>。。。</p>
<p>诶诶诶$n=64$怎么又炸了？</p>
<p>改成<code>(1&lt;&lt;(n-1))-1+(1&lt;&lt;(n-1))</code>。。。</p>
<p>总算好了，虚惊一场</p>
<p>20分差点没了</p>
<p>今年真**难</p>
<p>希望是Day1 Day2 难度互换了</p>
<p>估分：100+70+10=180</p>
<h2 id="Junior"><a href="#Junior" class="headerlink" title="Junior"></a>Junior</h2><p>普及没什么压力</p>
<p>T1：zz题，50秒AC</p>
<p>T2：暴力模拟即可，常数45，听说有人被大样例卡常了？！</p>
<p>T3：看起来是原题，可我还是不会。打了个部分分和假贪心，大概40分</p>
<p>T4：一眼题。打完发现大样例RE了。。。可只剩下十分钟不到了没时间调试了，40分跑路</p>
<p>总结：今天T4太可惜了，丢了60分。。。</p>
<p>T3完全背包没看出来.jpg</p>
<p>我连每天全卖光都想到了，然后呢，就去想假贪心了。。。</p>
<p>估分100+100+40+40=280，可惜没上300</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>昨晚肝作业++</p>
<h2 id="Senior-Day-2"><a href="#Senior-Day-2" class="headerlink" title="Senior Day 2"></a>Senior Day 2</h2><p>密码还是没猜对</p>
<p>打开题目，一惊：凉了！</p>
<p>原来Day1 Day2难度并没有互换。。。</p>
<p>T1第一眼不会，T2第一眼不会</p>
<p>跑去打T1部分分。</p>
<p>匆匆忙忙打了个12分的$m=2,a_{i,j}&lt;2$的部分分走了</p>
<p>T2呢？暴力+假贪心12+rand()分跑路。</p>
<p>过去看T3</p>
<p>我*！T3好像部分分很足的样子！</p>
<p>一言不合就40分暴力，$O(m)$枚举删边，$O(n)$找重心。</p>
<p>再来个15分的一条链，获得55分。</p>
<p>估分12+12+55=79</p>
<p>于是TG总估分就出来了。100+70+10+12+12+55=259。</p>
<p>事实证明，之前背的板子都没用上。。。</p>
<h1 id="Day-4（2019-11-19）"><a href="#Day-4（2019-11-19）" class="headerlink" title="Day 4（2019.11.19）"></a>Day 4（2019.11.19）</h1><p>于是BJ的选手代码出来了。</p>
<p>跑洛谷上去测民间数据，100+70+10+8+12+55=255。D2T1好像挂了？</p>
<p>跑icode上去查估分，95+70+10+4+0+55=234。额更玄学了，T1我明明好好检查了呀？D2T1和T2可能真的挂了。。。</p>
<p>然而这样icode估分好像还是我们弱校rk1？不可能吧.jpg</p>
<p>深深感到自己的渺小</p>
<h1 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h1><p>于是发分了</p>
<p>PJ炸了，100+100+30+35=265。不过一等还在。</p>
<p><del>PJ不上300还比TG考的低太没面子了</del></p>
<p>TG D1T2数据水，70-&gt;100，但D2T1果然挂了，0分。</p>
<p>于是TG 100+100+10+0+12+55=277拿了个省一qwq</p>
<p><del>看来以后不要相信icode</del></p>
<p><del>以下是吐槽：</del></p>
<p><del>一个奖状要100！CCF NB！</del></p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
</search>
