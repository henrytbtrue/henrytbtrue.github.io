<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022 年 9 月做题记录</title>
    <url>/2022/09/2022-%E5%B9%B4-9-%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="8-29"><a href="#8-29" class="headerlink" title="8.29"></a>8.29</h2><p><del>假装已经九月了</del></p>
<a id="more"></a>
<h3 id="P4822"><a href="#P4822" class="headerlink" title="P4822"></a>P4822</h3><p>简单的最短路。跑 $k$ 次 Bellman-Ford 即可（相当于加一维）。</p>
<p>本质是分层图。</p>
<h3 id="P2149"><a href="#P2149" class="headerlink" title="P2149"></a>P2149</h3><p>建出最短路图（是一个 DAG），然后在上面找连续的重复边即可。</p>
<p>注意正反要分别处理。</p>
<h3 id="P3807"><a href="#P3807" class="headerlink" title="P3807"></a>P3807</h3><p>Lucas 板子。现在终于来写了一下。</p>
<script type="math/tex; mode=display">
\binom n m \bmod p = \binom {\lfloor n / p \rfloor} {\lfloor m / p \rfloor} \cdot \binom {n \bmod p} {m \bmod p} \bmod p</script><h3 id="P2700"><a href="#P2700" class="headerlink" title="P2700"></a>P2700</h3><p>有趣的思想（我题还是做少了，一眼没出来正解）。</p>
<p>考虑正难则反，改删边为加边，然后仿照 Kruskal 算法贪心从大到小尽可能加边即可。</p>
<p>删边连通性问题通常都可以时间倒流。</p>
<h2 id="8-30"><a href="#8-30" class="headerlink" title="8.30"></a>8.30</h2><h3 id="P7706"><a href="#P7706" class="headerlink" title="P7706"></a>P7706</h3><p>有趣的线段树。</p>
<p>考虑 <code>pushup</code> 时如何更新，观察到当前最优解一定是左儿子区间中最优解、右儿子区间中最优解、左儿子 $\max \{ A_i - B_j \}$ 与右儿子 $\max A_i$ 之和、左儿子 $\max A_i$ 与右儿子 $\max \{B_i - A_j\}$ 之和中最大的一个。</p>
<p>正确性：如果在“左儿子 $\max \{ A_i - B_j \}$ 与右儿子 $\max A_i$ 之和”这个情况中选出一个不合法的（$B_j$ 事实上不是最小值），那么一定会有更优合法解在“左儿子 $\max A_i$ 与右儿子 $\max \{B_i - A_j\}$ 之和” 中取到，反之亦然。</p>
<p>$\max \{ A_i - B_j\}$ 和 $\max \{ A_j - B_i \}$ 的更新也是类似的。</p>
<h3 id="P1155"><a href="#P1155" class="headerlink" title="P1155"></a>P1155</h3><p>神仙题。不看题解完全不会。</p>
<p>观察到出现这样的模式时一个栈不能解决问题：</p>
<script type="math/tex; mode=display">\exists i < j < k, p_k < p_i < p_j</script><p>这时 $i, j$ 必须不在同一个栈中。这样我们就给出了一种二分图染色的做法，如果有限制 $i, j$，则连边 $(i, j)$，然后进行二分图判定。</p>
<p>本题需要输出方案，因此结尾对字典序的贪心需要仔细斟酌才能过 hack 数据。。。</p>
<h3 id="P4198"><a href="#P4198" class="headerlink" title="P4198"></a>P4198</h3><p>这道题启示我们：看似不能拼凑的东西也能间接拼凑。</p>
<p>具体来讲，线段树上一个区间的 <code>ans</code> 是由左儿子 <code>ans</code> 加上经左儿子影响后的右儿子 <code>ans</code> 时，我们想要知道左儿子对右儿子影响后的 <code>ans</code> 可以直接用整区间 <code>ans</code> 减去左儿子 <code>ans</code> 得到。</p>
<p>注意，线段树上二分的时候参数传 <code>double</code>。。。</p>
<h3 id="CF438D"><a href="#CF438D" class="headerlink" title="CF438D"></a>CF438D</h3><p>更改一个点后对这个点的有效取模操作不会超过 $\log$ 次。因此暴力取模（判一下 $\max$ 是否大于模数）即可。</p>
<h3 id="AT4168"><a href="#AT4168" class="headerlink" title="AT4168"></a>AT4168</h3><p>高维前缀和，维护一下某子集中的最大值和次大值即可。</p>
<h3 id="P4139"><a href="#P4139" class="headerlink" title="P4139"></a>P4139</h3><p><strong>扩展欧拉定理</strong>：</p>
<script type="math/tex; mode=display">
a^{b} \equiv a^{b \bmod \varphi(p) + \varphi(p)} \bmod p\ (b \ge \varphi(p))</script><p>按这个递归即可。递归终点 $p = 1$。</p>
<h2 id="8-31"><a href="#8-31" class="headerlink" title="8.31"></a>8.31</h2><h3 id="P6772"><a href="#P6772" class="headerlink" title="P6772"></a>P6772</h3><p>很有趣的不停优化的题。</p>
<p>首先非常显然的是要矩阵加速（$T \le 10^9$，图很小，边长度 $w \le 5$）。</p>
<p>然后先不考虑美食节，发现边长度虽然小，但是边很多，所以拆边受不了。</p>
<p>但是由于统计答案用的是点权（转化为到这个点之前一条边的边权），所以我们的边其实非常等价，不需要拆边，只需要拆点就行了（其实相当于共用了一下拆之后的边）。这样矩阵的规模就从 $(n + 4m) \times (n + 4m)$ 变成了 $5n \times 5n$。</p>
<p>然后我们发现存在美食节这个东西，显然要把每个美食节劈开处理。</p>
<p>然后发现劈开之后有 $200$ 段，每个内部段用矩阵快速幂，然后暴力接起来是不可接受的。</p>
<p>这时候我们发现我们只关心 $(1, 1)$ 的最终答案值（从 $1$ 出发回到 $1$），因此我们只需要维护一个行向量不停左乘这个矩阵，这样单次矩阵乘法的复杂度变成了 $5n^2$。</p>
<p>但是我们每一段依然有可能非常长，而且不能内部用矩阵快速幂了。这时我们考虑倍增地去乘这些矩阵，预处理好邻接矩阵的 $2^x$ 次方得到的矩阵，然后倍增地左乘这些东西，每段只需要乘 $\log T$ 次。</p>
<p>复杂度 $O((wn)^3\log T + (wn)^2k\log T)$。其中 $w$ 是边权，满足 $w \le 5$。</p>
<h3 id="P2831"><a href="#P2831" class="headerlink" title="P2831"></a>P2831</h3><p>卡精度垃圾状压 dp 题。（为什么我必须开 <code>long double</code> 才能过样例？）</p>
<h2 id="9-1"><a href="#9-1" class="headerlink" title="9.1"></a>9.1</h2><h3 id="P1654"><a href="#P1654" class="headerlink" title="P1654"></a>P1654</h3><p>遇到期望 dp 时，可以考虑<strong>期望的线性性</strong>。（不要忘了！！！）</p>
<p>具体来讲，我们可以分开考虑每个位置对期望的贡献，然后将其加起来。</p>
<p>这个时候我们发现一个位置产生的贡献和当前末尾极长连续的 $1$ 的长度有关，考虑维护“到某一位置末尾极长连续 $1$ 长度”的期望。发现这里还需要其平方的期望，一块维护就好了。<strong>平方的期望不等于期望的平方</strong>！</p>
<p>弱化的双倍经验：CF235B</p>
<h3 id="P2606"><a href="#P2606" class="headerlink" title="P2606"></a>P2606</h3><p>简单树上 dp 计数题。模数可能 $\le n$，所以组合数需要 lucas。</p>
<p>但！是！预处理阶乘逆从后往回推的时候，如果是从一个大于模数的地方往回推的话小的也会寄！</p>
<p>所以预处理阶乘、阶乘逆的时候必须只处理到 $\min\{n, p - 1\}$。这个很离谱，我如果没被 hack 的话想不到（因为先入为主地以为多处理一些也没问题了，但是忘记了阶乘逆是倒推回来的）。</p>
<h2 id="9-4"><a href="#9-4" class="headerlink" title="9.4"></a>9.4</h2><h3 id="CF222E"><a href="#CF222E" class="headerlink" title="CF222E"></a>CF222E</h3><p>水了道垃圾矩阵快速幂。</p>
<h2 id="9-5"><a href="#9-5" class="headerlink" title="9.5"></a>9.5</h2><h3 id="P3868"><a href="#P3868" class="headerlink" title="P3868"></a>P3868</h3><p>用这道题复习了一下 exCRT。</p>
<p>就是 exCRT 板子，但是有一些坑点。</p>
<ol>
<li>可能爆 <code>long long</code>，需要龟速乘。</li>
<li>可能只有一个方程，而且一开始 $b_1 = 1, a_1 \ge b_1$，直接输出 $a_1$ 会寄，需要先模上 $b_1$。</li>
</ol>
<h2 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h2><h3 id="P2421"><a href="#P2421" class="headerlink" title="P2421"></a>P2421</h3><p>exgcd。有一点细节（主要是我脑抽了，导致调了很久）。</p>
<h3 id="P6006"><a href="#P6006" class="headerlink" title="P6006"></a>P6006</h3><p>区间 dp 一下所有答案，动态维护一段区间的桶，不停移动即可做到 $O(n)$。</p>
<h3 id="P6007"><a href="#P6007" class="headerlink" title="P6007"></a>P6007</h3><p>观察到本质是 DAG 上 dp，但是不需要显式地把图建出来。</p>
<p>转移的本质是二维数点，离线之后用树状数组处理一下就完事了。</p>
<h2 id="9-8"><a href="#9-8" class="headerlink" title="9.8"></a>9.8</h2><h3 id="P1450"><a href="#P1450" class="headerlink" title="P1450"></a>P1450</h3><p>每次询问暴力背包肯定是不行的，因此我们需要预处理一些东西。</p>
<p>然而我们只能预处理没有个数限制的时候（即完全背包）的方案数。</p>
<p>考虑容斥，用没有限制的减掉不满足限制的。观察到我们钦定一个东西不满足限制等价于将 $s$ 减去 $c_i \times (d_i + 1)$，也就是事先取出了这么多足以让它不满足限制的钱数，然后就做完了。</p>
<h2 id="9-15"><a href="#9-15" class="headerlink" title="9.15"></a>9.15</h2><h3 id="P6189"><a href="#P6189" class="headerlink" title="P6189"></a>P6189</h3><p>$O(n\sqrt n)$ 求分拆数。</p>
<p>法 1：五边形数定理。</p>
<p>考虑</p>
<script type="math/tex; mode=display">\phi(x) = \prod_{i = 1}^{+\infty} (1 - x^i) = \sum_{i = 0}^{+\infty} (-1)^{i}x^{\frac{3k^2 \pm k}{2}}</script><p>再考虑到分拆数的生成函数是 $\frac{1}{\phi(x)}$。</p>
<p>于是可以写出分拆数的递推式</p>
<script type="math/tex; mode=display">p_n = p_{n - 1} + p_{n - 2} - p_{n - 5} - p_{n - 7} - \cdots</script><p>对着这个式子递推就行。因为五边形数的增长速度是平方的，所以这个递推的复杂度是 $O(n\sqrt n)$。</p>
<p>法 2：根号分治 dp。</p>
<p>考虑分拆数的两种求法。</p>
<p>第一种是类似完全背包，考虑 $f_{i, j}$ 表示 $i$ 用 $1 \sim j$ 的数分拆出来的方案数，那么显然有</p>
<script type="math/tex; mode=display">f_{i, j} = f_{i, j - 1} + f_{i - j, j}</script><p>第二种是考虑 $g_{i, j}$ 表示 $i$ 严格用 $j$ 个数分拆出来的方案数，那么</p>
<script type="math/tex; mode=display">g_{i, j} = g_{i - 1, j - 1} + g_{i - j, j}</script><p>然后根号分治（不知道怎么想到的，在我的思维水平之上）。</p>
<p>我们用 $f$ 求出用 $\le \sqrt n$ 的数分拆 $n$ 的方案数，然后用 $g$ 求出用 $ &gt; \sqrt n $ 的数分拆 $n$ 的方案数。</p>
<p>时间复杂度 $O(n \sqrt n)$，但是我完全不知道怎么想到这个做法的。</p>
<p>有点自闭。</p>
<h2 id="9-16"><a href="#9-16" class="headerlink" title="9.16"></a>9.16</h2><h3 id="P4053"><a href="#P4053" class="headerlink" title="P4053"></a>P4053</h3><p>反悔贪心。</p>
<p>首先显然需要按 $T_2$ 排序。</p>
<p>然后考虑我们想要什么。我们想知道的是在一个截止时间前最多能有多少个建筑被抢修，同时为了转移，我们还需要知道在最大化抢修建筑量的情况下，所需的最少时间是多少。</p>
<p>我们贪心地加任务进去，如果一个任务炸了，那么将其替换掉之前耗时最大的任务即可。可以发现这种方案一定能做到使当前解最优。</p>
<h3 id="P5909"><a href="#P5909" class="headerlink" title="P5909"></a>P5909</h3><p>与 P4053 相同。</p>
<h2 id="9-21"><a href="#9-21" class="headerlink" title="9.21"></a>9.21</h2><h3 id="P6190"><a href="#P6190" class="headerlink" title="P6190"></a>P6190</h3><p>第一眼显然是分层图最短路，也就是暴力 dp。</p>
<p>但是只能拿 $90$ 分。考虑优化。</p>
<p>我们观察到跨过某一层的边等价于右乘一个所有边都变成负的的邻接矩阵再右乘一个最短路矩阵（应该比较显然吧）。</p>
<p>然后做矩阵快速幂就可以了。</p>
<h2 id="9-28"><a href="#9-28" class="headerlink" title="9.28"></a>9.28</h2><h3 id="P7961"><a href="#P7961" class="headerlink" title="P7961"></a>P7961</h3><p>垃圾 dp 题。没啥好说的。</p>
<p>注意：在瓶颈上的任何可以优化的地方一定要优化。这个题千万不能带 $<br>\log$。</p>
<h3 id="P7962"><a href="#P7962" class="headerlink" title="P7962"></a>P7962</h3><p>发现操作本质是交换差分数组。发现方差最小时差分数组一定是单谷的。</p>
<p>dp。考虑从小往大依次加入差分值，每次判断这个差分值是放在左边还是右边最优。</p>
<p>（感觉想到从小往大加入差分，也就是从中间往两边扩展着填数是关键）</p>
<p>朴素的做法是 $O(n^2 a)$ 的。</p>
<p>考虑在 $\max a_i \le n$ 的时候，一定会有一些差分值为 $0$，这些时候都没有必要去转移。</p>
<p>这样复杂度就是 $O(na^2)$ 的了，可以通过本题。</p>
<h3 id="P7115"><a href="#P7115" class="headerlink" title="P7115"></a>P7115</h3><p>当时看这题十分吓人，现在感觉：就这？睡一觉基本上就想出来了绝大部分东西。</p>
<p>先考虑 $n = 2$ 的情况。我们将其中一列劈开，然后把另一列分成 $1$ 和 $2$ 两段分别浮在劈开后的这两列上方。然后把这两列倒置，把上面原来的“另一列”的部分堆到空列上，一个一个判断该放左边还是右边即可。</p>
<p>然后我们可以从 $n = 2$ 的情况推广。观察到我们想要每次将一种颜色处理完。</p>
<p>不妨设当前我们处理的颜色是 $1$。</p>
<p>根据刚刚的推理，我们可以让某一列中的所有的 $1$ 借助一个垃圾列让其全部浮在某一列上方。</p>
<p>那么我们只需要让所有列的 $1$ 都浮上来，然后把这堆 $1$ 塞到空列里，再把垃圾行整个消灭，$1$ 塞空列里，其他的都补到别的空位去。</p>
<p>让某一列的所有 $1$ 上浮需要 $1.5m$ 次操作。这个比较显然，用刚刚那个 $n = 2$ 做法的前半部分就行了。</p>
<p>那么这就是一个大约 $0.75n^2m$ 次操作的做法（因为 $n$ 在不断减少，有 $1/2$ 倍的常数）。</p>
<p>但是！但是！但是！我们的垃圾列的 $1$ 可能会散落到我们处理过的上浮 $1$ 的下方，这样就寄了！！！</p>
<p>因此，我们需要保证垃圾列中没有任何 $1$。这个可以牺牲一点常数轻松解决，如下图。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/f9jnrpsx.png" alt=""></p>
<p>然后这题就做完了。</p>
<h2 id="9-30"><a href="#9-30" class="headerlink" title="9.30"></a>9.30</h2><h3 id="P1850"><a href="#P1850" class="headerlink" title="P1850"></a>P1850</h3><p>经典期望 dp 题。</p>
<p>考虑<strong>期望的线性性</strong>，转移的时候看一看每一步的期望即可。</p>
<p>然后发现想知道每一步的期望就得知道上一次申请没申请才能转移。于是状态就直接出来了。</p>
]]></content>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
        <tag>水题选做</tag>
      </tags>
  </entry>
  <entry>
    <title>下降幂多项式</title>
    <url>/2022/08/%E4%B8%8B%E9%99%8D%E5%B9%82%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>今天听讲课的时候听到了这个有趣的东西，记录一下防止忘记。</p>
<a id="more"></a>
<h2 id="下降幂多项式"><a href="#下降幂多项式" class="headerlink" title="下降幂多项式"></a>下降幂多项式</h2><p>形如 $f(x) = \sum_{i = 0}^{n}a_i x^{\underline{i} }$ 的多项式被称为<strong>下降幂多项式</strong>。</p>
<p>它有一些绝妙的性质。</p>
<p>求值：可以快速求一段 $0 \sim m$ 内的所有点值。</p>
<p>插值：可以根据 $0 \sim n + 1$ 的点值简单地插出这个下降幂多项式。</p>
<p>对于求值，考虑</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x) & = \sum_{i = 0}^{n} a_i x^{\underline{i} } \\
& = x!\sum_{i = 0}^{n} a_i \frac{1}{(x - i)!}
\end{aligned}</script><p>只需要求 $f$ 和 $\exp$ 的卷积，乘上 $x!$ 即可计算出 $f(x)$。</p>
<p>对于插值，考虑</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x) & = \sum_{i = 0}^{n} a_i x^{\underline{i} } \\
& = \sum_{i = 0}^{x} \binom{x}{i} i! a_i
\end{aligned}</script><p>二项式反演。</p>
<script type="math/tex; mode=display">
\begin{aligned}
a_x & = \frac{1}{x!} \sum_{i = 0}^{x} (-1)^{x - i} \binom{x}{i} f(i) \\
& = \sum_{i = 0}^{x}\frac{f(i)}{i!} \cdot \frac{(-1)^{x - i}}{(x - i)!}
\end{aligned}</script><p>这样就用 $0 \sim n$ 处的点值插出了所有 $a_i$。只需要一次卷积。</p>
<h2 id="普通多项式转下降幂多项式"><a href="#普通多项式转下降幂多项式" class="headerlink" title="普通多项式转下降幂多项式"></a>普通多项式转下降幂多项式</h2><p>考虑分治。</p>
<p>设 $f$ 为待转换的普通多项式，$g$ 为转换后的下降幂多项式。</p>
<p>将 $f_{l\sim mid}$ 与 $f_{mid + 1 \sim r}$ 递归处理，求出 $g_{l\sim mid}$ 和 $g_{mid + 1 \sim r}$。</p>
<p>设 $m = mid - l + 1$，$len = r - l + 1$。</p>
<p>那么 $g_{l\sim r} = g_{l\sim mid} + x^m \cdot g_{mid + 1 \sim r}$。</p>
<p>考虑 $x^{m} \cdot g_{\ldots}$ 怎么求。其中 $g$ 已经是下降幂多项式了。</p>
<p>我们可以求出 $x^{m}$ 与 $g$ 在 $0 \sim len - 1$ 处的所有点值，$x^m$ 可以暴力，$g$ 可以采用上述方法处理。</p>
<p>然后将点值两两相乘得到 $x^m\cdot g$ 的点值，再插值回去即可得到 $x^m\cdot g$。</p>
<p>这样我们就将 $g_{l\sim mid}$ 和 $g_{mid + 1 \sim r}$ 合并成了 $g_{l\sim r}$。</p>
<h2 id="下降幂多项式转普通多项式"><a href="#下降幂多项式转普通多项式" class="headerlink" title="下降幂多项式转普通多项式"></a>下降幂多项式转普通多项式</h2><p>留坑待填。</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>一堆筛子</title>
    <url>/2022/08/%E4%B8%80%E5%A0%86%E7%AD%9B%E5%AD%90/</url>
    <content><![CDATA[<p>埃氏筛和线性筛就不多说了。</p>
<p>这里主要整理一堆能在亚线性复杂度下计算积性函数前缀和的筛法。</p>
<a id="more"></a>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><p>入门级筛子。比较难构造函数。</p>
<p>能 $O(n^{\frac{2}{3}})$ 求积性函数 $f(i)$ 的前缀和 $F(n) = \sum_{i = 1}^{n} f(i)$。同时也求出了所有 $F(\left\lfloor\frac{n}{k}\right\rfloor)$ 的值。</p>
<p>考虑设计一个前缀和能快速计算的积性函数 $g$ 使得 $f * g = h$ 的前缀和也能快速计算，则有。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i = 1}^{n} (f * g)(i) & = \sum_{i = 1}^{n}\sum_{d|i}f\left(\frac{i}{d}\right)g(d) \\
& = \sum_{d = 1}^{n}g(d)\sum_{i = 1}^{\lfloor n / d \rfloor}f(i) \\
& = \sum_{d = 1}^{n}g(d)F\left(\left\lfloor\frac{n}{d}\right\rfloor\right) \\
& = F(n) + \sum_{d = 2}^{n}g(d)F\left(\left\lfloor\frac{n}{d}\right\rfloor\right) \\
\therefore F(n) & = \sum_{i = 1}^{n}(f * g)(i) - \sum_{d = 2}^{n}g(d)F\left(\left\lfloor\frac{n}{d}\right\rfloor\right)
\end{aligned}</script><p>整除分块求解即可。复杂度为 $O(n^{\frac{3}{4}})$。</p>
<p>预处理前 $O(n^{\frac{2}{3}})$ 个 $f$，将复杂度平衡至 $O(n^{\frac{2}{3}})$。</p>
<p>复杂度积分一下就能证了。</p>
<h2 id="Min-25-筛"><a href="#Min-25-筛" class="headerlink" title="Min_25 筛"></a>Min_25 筛</h2><p>很强的筛子。</p>
<p>能 $O(n^{1-\epsilon})$ 求解一类积性函数 $f(i)$ 的前缀和 $F(n)$ 。但是只能求出单点的前缀和值。优点是跑得飞快。</p>
<p>其思想为先求出对于 $G(n) = \sum_{i = 1}^{n}f(i) \cdot [i\text{ is prime}]$ 的所有 $G\left(\left\lfloor\frac{n}{k}\right\rfloor\right)$ 的值。然后再用其求 $F(n)$。</p>
<p>我们需要找到一个<strong>完全积性</strong>函数 $g$ 使得 $g$ 在质数处的取值与 $f$ 相同。那么可以得出 $G(n) = \sum_{i = 1}^{n}g(i) \cdot [i\text{ is prime}]$。</p>
<p>现在我们就拆分出了两个问题：</p>
<ol>
<li>对于一个完全积性函数 $g$，求出所有的 $G\left(\left\lfloor\frac{n}{k}\right\rfloor\right)$。</li>
<li>利用刚刚求得的所有 $G\left(\left\lfloor\frac{n}{k}\right\rfloor\right)$，求出 $F(n)$。</li>
</ol>
<p>假设我们已经做完了第一个问题，现在我们需要求解 $F(n)$。</p>
<p>考虑到所有合数的最小质因子一定 $\le \sqrt n$，因此我们可以对这个最小质因子做递归。具体来讲，设</p>
<script type="math/tex; mode=display">
F(i, j) = \sum_{k = 1}^{j} f(k) [k \text{ 的最小质因子} \ge p_i]</script><p>其中 $p_i$ 表示第 $i$ 个质数。$F(n)$ 就等于 $F(1, n) + f(1)$。考虑递归计算 $F(i, j)$，将所有可能的最小质因子单独拎出来：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(i, j) & = \sum_{k \ge i, p_k^2 \le j} \sum_{p_k^{e + 1}\le j} f(p_k^{e + 1}) + f(p_k^e) \times F\left(k + 1, \left\lfloor\frac{j}{p_k^{e}}\right\rfloor\right) & \cdots (1)\\
& + G(j) - \sum_{k = 1}^{i - 1}f(p_k) & \cdots (2)
\end{aligned}</script><p>$(1)$ 处，枚举当前满足条件的数的最小质因子 $p_k$ 及其幂次。</p>
<p>$(2)$ 处，将质数位置的函数值加入，但需要减去 $&lt; p_i$ 的质数位置的函数值。</p>
<p>不需要记忆化。</p>
<p>这一步的复杂度被证明是 $O(n^{1 - \epsilon})$ 的，但是实测 $10^{10}$ 量级无压力。</p>
<p>下面问题是，如何求出所有的 $G\left(\left\lfloor\frac{n}{k}\right\rfloor\right)$。</p>
<p>可以采用类似的定义，设</p>
<script type="math/tex; mode=display">
G(i, j) = \sum_{k = 1}^{j}g(k) \cdot [k\text{ is prime or }k \text{ 的最小质因子} > p_i]</script><p>这样 $G(t, n)$ 就是 $G(n)$ 的值（$t$ 表示 $\le \sqrt{n}$ 的素数个数）。</p>
<p>那么可以考虑用类似方法，把 $p_i$ 的影响筛掉来更新新的 $G$ 值。</p>
<script type="math/tex; mode=display">
\begin{aligned}
G(i, j) & = G(i - 1, j) - \sum_{k = 1}^{j}g(k) \cdot [k\text{ is not prime and } k \text{ 的最小质因子} = p_i] \\
& = G(i - 1, j) - G\left(i - 1, \left\lfloor\frac{j}{p_i}\right\rfloor\right)\cdot g(p_i) + \left(\sum_{k = 1}^{i - 1}g(p_k)\right) \cdot g(p_i)
\end{aligned}</script><p>其中，$G\left(i - 1, \left\lfloor\frac{j}{p_i}\right\rfloor\right)$ 代表了所有质数 $p_1, p_2, \ldots, p_{i - 1}$ 以及一切最小质因子 $\ge p_i$ 的数。我们希望减去一切最小质因子 $\ge p_i$ 的数乘上 $p_i$ 的函数值，也就是所有最小质因子就是 $p_i$ 的情况下的函数值。而直接减去 $G\left(i - 1, \left\lfloor\frac{j}{p_i}\right\rfloor\right) \cdot g(p_i)$ 后多减掉了所有 $p_1p_i, p_2p_i, \ldots, p_{i - 1}p_i$ 这些位置的函数值，因此需要加回来。</p>
<p>需要预处理 $\sum_{j = 1}^{i}g(p_j)$。</p>
<p>这一步骤的复杂度被证明是 $O\left(\frac{n^{\frac{3}{4}}}{\log n}\right)$ 的。</p>
<h2 id="Powerful-Number-筛"><a href="#Powerful-Number-筛" class="headerlink" title="Powerful Number 筛"></a>Powerful Number 筛</h2><p>留坑待填。</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay 复杂度分析</title>
    <url>/2022/06/Splay-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>众所周知，Splay 的复杂度分析需要用一个叫做“势能分析法”的东西。</p>
<p>所以首先得解释一下这个势能分析是个什么来头。</p>
<a id="more"></a>
<h2 id="势能分析法"><a href="#势能分析法" class="headerlink" title="势能分析法"></a>势能分析法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们在某些时间复杂度是均摊的问题上，往往进行草率的感性理解，虽然理解了复杂度是从何而来，但严谨证明却比较麻烦。</p>
<p>我们可以考虑在单次操作复杂度不好分析，可能复杂很大的时候（例如 <code>splay</code> 操作），为数据结构引入势能概念，当时间松时存储势能，当时间紧时释放势能。</p>
<p>可以理解为“存款”和“取款”。在某次操作耗时较少时，将盈余的时间分摊给其他耗时较长的操作。</p>
<h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><p>设一个数据结构为 $D_0$，进行 $m$ 次操作，分别为 $c_1, c_2, \ldots, c_m$。定义第 $k$ 次操作后的数据结构为 $D_k$。定义势函数 $\Phi(D_k)$ 表示数据结构 $D_k$ 的势能，这个函数将一个数据结构映射到一个实数上。</p>
<p>我们定义一次操作的摊还代价为 $\hat{c_i} = c_i + \Phi(D_i) - \Phi(D_{i - 1})$，即本次操作的实际代价加上操作前后数据结构势能的变化量。</p>
<p>这样，$m$ 次操作的总摊还代价为</p>
<script type="math/tex; mode=display">\sum_{i = 1}^{m} \hat{c_i} = \sum_{i = 1}^{m} c_i + \Phi(D_m) - \Phi(D_0)</script><p>因此，</p>
<script type="math/tex; mode=display">\sum_{i = 1}^{m} c_i = \sum_{i = 1}^{m}\hat{c_i} + \Phi(D_0) - \Phi(D_m)</script><p>这样，我们通过得出 $\sum_{i = 1}^{m} \hat{c_i}$ 和 $\Phi(D_0) - \Phi(D_m)$ 的上界，就可以求出 $\sum_{i = 1}^{m} c_i$ 的上界了！</p>
<h2 id="Splay-的势能分析"><a href="#Splay-的势能分析" class="headerlink" title="Splay 的势能分析"></a>Splay 的势能分析</h2><p>首先通过观察可以发现，Splay 的所有操作的代价都可以理解为常数倍的 <code>splay</code> 操作。</p>
<p>因此我们只需考虑 <code>splay</code> 操作。</p>
<p>设一个 Splay 中共 $n$ 个点，每个点对应的子树大小为 $s(i)$，每个点的势能 $\phi(i) = \left\lceil\log_2 s(i)\right\rceil$。</p>
<p>整个 Splay 的总势能为 $\Phi(D) = \sum_{i = 1}^{n} \phi(i)$。</p>
<p><code>splay</code> 操作有三种情况，下面分类讨论。</p>
<h3 id="zig-zag"><a href="#zig-zag" class="headerlink" title="zig (zag)"></a>zig (zag)</h3><p>当 $x$ 的父节点为根时，我们通过一次单旋将 $x$ 旋转到根。</p>
<p><img src="/pics/splay_zig.jpg" alt=""></p>
<script type="math/tex; mode=display">\Delta\Phi = \phi(x') + \phi(y') - \phi(x) - \phi(y)</script><script type="math/tex; mode=display">\because \phi(x') = \phi(y)</script><script type="math/tex; mode=display">\therefore \Delta\Phi = \phi(y') - \phi(x)</script><script type="math/tex; mode=display">\because \phi(x') \ge \phi(y')</script><script type="math/tex; mode=display">\therefore \Delta\Phi = \phi(y') - \phi(x) \le \phi(x') - \phi(x)</script><p>因为 zig 操作需要 <code>rotate</code> 一次，<code>rotate</code> 是 $O(1)$ 的，所以</p>
<script type="math/tex; mode=display">\hat{c}_{\mathrm{zig}} = \Delta\Phi + 1 \le \phi(x') - \phi(x) + 1</script><p>同理可证 zag 的摊还代价，因为 zig 和 zag 是对称的。</p>
<h3 id="zig-zig-zag-zag"><a href="#zig-zig-zag-zag" class="headerlink" title="zig-zig (zag-zag)"></a>zig-zig (zag-zag)</h3><p>当 $x$ 与父节点的儿子类型相同的时候，先旋转 $x$ 的父节点，再旋转 $x$。</p>
<p><img src="/pics/splay_zigzig.jpg" alt=""></p>
<p>则</p>
<script type="math/tex; mode=display">\Delta\Phi = \phi(x') + \phi(y') + \phi(z') - \phi(x) - \phi(y) - \phi(z)</script><script type="math/tex; mode=display">\because \phi(x') = \phi(z)</script><script type="math/tex; mode=display">\therefore \Delta\Phi = \phi(y') + \phi(z') - \phi(x) - \phi(y)</script><script type="math/tex; mode=display">\because \phi(x') \ge \phi(y'), \phi(x) \le \phi(y)</script><script type="math/tex; mode=display">\therefore \Delta\Phi \le \phi(x') + \phi(z') - 2\phi(x)</script><p>我们知道，当 $x, y &gt; 0, x + y \le 1$ 时，</p>
<script type="math/tex; mode=display">
\begin{aligned}
\because (x - y)^2 & \ge 0\\
\therefore x^2 - 2xy + y^2 & \ge 0\\
\therefore x^2 + 2xy + y^2 & \ge 4xy\\
\therefore (x + y)^2 & \ge 4xy \\
\therefore xy & \le \frac{(x + y)^2}{4}\\
\log_2 x + \log_2 y & = \log_2 xy \\
& \le \log_2 \frac{(x + y)^2}{4} \\
\end{aligned}</script><p>取等当且仅当 $x = y$。</p>
<p>当 $x + y$ 取最大值 $1$ 时，$\log_2\frac{(x + y)^2}{4}$ 取最大值 $-2$。</p>
<p>因此</p>
<script type="math/tex; mode=display">\log_2 x + \log_2 y \le -2</script><p>那么，</p>
<script type="math/tex; mode=display">
\begin{aligned}
\phi(x) + \phi(z') - 2\phi(x') & = (\phi(x) - \phi(x')) + (\phi(z') - \phi(x')) \\
& = (\log_2 s(x) - \log_2 s(x')) + (\log_2 s(z') - \log_2 s(x')) \\
& = \log_2 \frac{s(x)}{s(x')} + \log_2 \frac{s(z')}{s(x')} \\
\end{aligned}</script><script type="math/tex; mode=display">
\because s(x) + s(z') \le s(x') \\</script><script type="math/tex; mode=display">
\therefore \frac{s(x)}{s(x')} + \frac{s(z')}{s(x')} \le 1 \\</script><script type="math/tex; mode=display">
\because \frac{s(x)}{s(x')} > 0 , \frac{s(z')}{s(x')} > 0</script><script type="math/tex; mode=display">
\therefore \log_2 \frac{s(x)}{s(x')} + \log_2 \frac{s(z')}{s(x')} \le -2</script><script type="math/tex; mode=display">\therefore \phi(x) + \phi(z') - 2\phi(x') \le -2</script><script type="math/tex; mode=display">
\begin{aligned}
\therefore \Delta\Phi & \le \phi(x') + \phi(z') - 2\phi(x) \\
& = (3\phi(x') - 3\phi(x)) + (\phi(x) + \phi(z') - 2\phi(x)) \\
& \le 3\phi(x') - 3\phi(x) - 2
\end{aligned}</script><p>因为 zig-zig 操作需要 <code>rotate</code> 两次，所以</p>
<script type="math/tex; mode=display">\hat{c}_{\mathrm{zigzig}} = \Delta\Phi + 2 \le 3\phi(x') - 3\phi(x)</script><p>同理可证 zag-zag 的摊还代价，因为 zag-zag 和 zig-zig 是对称的。</p>
<h3 id="zig-zag-zag-zig"><a href="#zig-zag-zag-zig" class="headerlink" title="zig-zag (zag-zig)"></a>zig-zag (zag-zig)</h3><p>当 $x$ 与父节点的儿子类型不同时，旋转两次 $x$ 节点。</p>
<p><img src="/pics/splay_zigzag.jpg" alt=""></p>
<p>则</p>
<script type="math/tex; mode=display">\Delta\Phi = \phi(x') + \phi(y') + \phi(z') - \phi(x) - \phi(y) - \phi(z)</script><script type="math/tex; mode=display">\because \phi(x') = \phi(z)</script><script type="math/tex; mode=display">\therefore \Delta\Phi = \phi(y') + \phi(z') - \phi(x) - \phi(y)</script><script type="math/tex; mode=display">\because \phi(x) \le \phi(y)</script><script type="math/tex; mode=display">
\begin{aligned}
\therefore \Delta\Phi & \le \phi(y') + \phi(z') - 2\phi(x) \\
& = (2\phi(x') - 2\phi(x)) + (\phi(y') + \phi(z') - 2\phi(x')) \\
\end{aligned}</script><script type="math/tex; mode=display">\because \frac{s(y')}{s(x')} > 0, \frac{s(z')}{s(x')} > 0, s(y') + s(z') \le s(x')</script><script type="math/tex; mode=display">\therefore \phi(y') + \phi(z') - 2\phi(x') \le -2</script><script type="math/tex; mode=display">\therefore \Delta\Phi \le 2\phi(x') - 2\phi(x) - 2</script><p>因为 zig-zag 操作需要 <code>rotate</code> 两次，所以</p>
<script type="math/tex; mode=display">\hat{c}_{\mathrm{zigzag}} = \Delta\Phi + 2 \le 2\phi(x') - 2\phi(x)</script><p>可以再放缩一下，便于下一步计算。</p>
<script type="math/tex; mode=display">\because \phi(x') - \phi(x) \ge 0</script><script type="math/tex; mode=display">\therefore \hat{c}_{\mathrm{zigzag}} \le 3\phi(x') - 3\phi(x)</script><p>同理可证 zag-zig 操作的摊还代价，因为 zag-zig 和 zig-zag 是对称的。</p>
<h3 id="一次-splay-操作"><a href="#一次-splay-操作" class="headerlink" title="一次 splay 操作"></a>一次 <code>splay</code> 操作</h3><p>回顾一下，我们有：</p>
<script type="math/tex; mode=display">
\hat{c}_{\mathrm{zig}} \le \phi(x') - \phi(x) + 1 \le 3(\phi(x') - \phi(x)) + 1 \\
\hat{c}_{\mathrm{zigzig}} \le 3(\phi(x') - \phi(x)) \\
\hat{c}_{\mathrm{zigzag}} \le 3(\phi(x') - \phi(x))</script><p>因此，我们将 $x$ 这个点旋转到根的时候，一路抵消，最后</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{c_i} & \le 3(\phi(\mathrm{root}) - \phi(x)) + 1 \\
& = 3\log_2 \frac{n}{s(x)} + 1 \\
& \le 3\log_2 n + 1 \\
& = O(\log n)
\end{aligned}</script><h3 id="所有操作"><a href="#所有操作" class="headerlink" title="所有操作"></a>所有操作</h3><script type="math/tex; mode=display">
\sum_{i = 1}^{m}\hat{c_i} = O(m\log n)</script><p>又因为</p>
<script type="math/tex; mode=display">
0 \le \Phi(D) \le n\log_2 n</script><p>所以</p>
<script type="math/tex; mode=display">
\Phi(D_0) - \Phi(D_n) = O(n\log n)</script><p>因此</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i = 1}^{n} c_i & = \sum_{i = 1}^{n}\hat{c_i} + \Phi(D_0) - \Phi(D_n) \\
& = O(m\log n) + O(n\log n) \\
& = O((n + m)\log n)
\end{aligned}</script><p>证毕。</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>THUSC2022 游记</title>
    <url>/2022/05/THUSC2022-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day"><a href="#Day" class="headerlink" title="Day -?"></a>Day -?</h1><p>过审了。今年的 THUSC 线上举行。</p>
<p>希望不要像去年一样打铁。</p>
<p>依稀记得，去年 day1 非常爆炸，就算 day2 力挽狂澜翻回了一些分，也没能上初二可怜的良好线。</p>
<p>希望今年能好一点。</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>上午开幕式，然后试机。</p>
<p>被监考老师表扬了双机位放的很好是我没想到的…</p>
<p>但是这都不重要！准备好下午的考试状态！</p>
<p>于是复习了一下 KMP、SA 以及一些 DS。</p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><h3 id="13-15"><a href="#13-15" class="headerlink" title="13:15"></a>13:15</h3><p>进入会议室，拍身份证进行身份核验。</p>
<p>核验完身份后又被移至了等候室。</p>
<h3 id="13-30"><a href="#13-30" class="headerlink" title="13:30"></a>13:30</h3><p>被重新移入了会议，开启 OBS 录屏。</p>
<h3 id="14-00"><a href="#14-00" class="headerlink" title="14:00"></a>14:00</h3><p>本来要开始考试的，但是因为有的会议室没有进行完身份核验，所以延迟了十分钟。</p>
<h3 id="14-10"><a href="#14-10" class="headerlink" title="14:10"></a>14:10</h3><p>又延迟了 10 分钟。</p>
<h3 id="14-20"><a href="#14-20" class="headerlink" title="14:20"></a>14:20</h3><p>开始考试！</p>
<p>看题！</p>
<ul>
<li>T1 看起来像个暴力 dp 题（题目明示做法），估计按题意去做然后优化就行了。</li>
<li>T2 不太会，也许可以暴力一下。</li>
<li>T3 通信题，第一眼一点思路都没有。</li>
<li>T4 感觉有一些暴力分比较好拿。</li>
</ul>
<p>于是我先开始写 T1 了。</p>
<h3 id="15-30"><a href="#15-30" class="headerlink" title="15:30"></a>15:30</h3><p>不错不错，T1 写完了个大记搜，刚调出来。</p>
<p>感谢 T1 的良心出题人（比后面的题不知高到哪里去了），在提示那里教了我们条件概率的知识，如果没有这个的话我估计就写不出来了。</p>
<p>交了一发，50 分，毕竟感觉这个很暴力还有很多可以优化的地方，继续加油吧。</p>
<h3 id="15-33"><a href="#15-33" class="headerlink" title="15:33"></a>15:33</h3><p>发现可以预处理某个时间段有哪些可能下雨的点，这样能省一些复杂度，写了一下。</p>
<h3 id="15-43"><a href="#15-43" class="headerlink" title="15:43"></a>15:43</h3><p>发现可以最短路优化，写了一下。</p>
<h3 id="15-46"><a href="#15-46" class="headerlink" title="15:46"></a>15:46</h3><p>交了一发。50pts 变成了 65pts。</p>
<p>不太会优化了，先去做后面的题。</p>
<h3 id="16-17"><a href="#16-17" class="headerlink" title="16:17"></a>16:17</h3><p>研究了一会 T2，发现有一个 $O(n^2\log^2 n)$ 的由暴力优化而来的二分 + 主席树做法。</p>
<p>果断开始写。</p>
<h3 id="16-39"><a href="#16-39" class="headerlink" title="16:39"></a>16:39</h3><p>写完了 T2。交了一发。</p>
<h3 id="16-41"><a href="#16-41" class="headerlink" title="16:41"></a>16:41</h3><p>刚刚交的 T2 终于测了出来，怎么感觉评测队列开始变长了？</p>
<p>T2 怎么 WA 掉了？？？我不是很理解。</p>
<h3 id="16-45"><a href="#16-45" class="headerlink" title="16:45"></a>16:45</h3><p>发现自己的 T2 中一个小错。</p>
<p>果断提交。</p>
<h3 id="16-47"><a href="#16-47" class="headerlink" title="16:47"></a>16:47</h3><p>现在队列可能已经长得不可接受了，于是我决定先去看看第四题。</p>
<h3 id="16-54"><a href="#16-54" class="headerlink" title="16:54"></a>16:54</h3><p>现在 16:45 的提交还没测出来。我决定开始写第四题的暴力 KMP。</p>
<h3 id="17-02"><a href="#17-02" class="headerlink" title="17:02"></a>17:02</h3><p>又看了眼 T2，还没测出来，继续写 T4。</p>
<h3 id="17-14"><a href="#17-14" class="headerlink" title="17:14"></a>17:14</h3><p>T4 暴力写挂了，还没调。去看了眼 T2 发现 T2 测出来了还是 wa？？？</p>
<p>于是又去看了几眼 T2，没查出什么问题。。。</p>
<h3 id="17-17"><a href="#17-17" class="headerlink" title="17:17"></a>17:17</h3><p>决定对 T2 写一个对拍。</p>
<p>先写个暴力。</p>
<p>暴力还没开始写，就发现自己的 T2 中一个 $m$ 打成了 $n$。</p>
<p>果断又交了一次 T2，然后没有继续写对拍，去调 T4 了。</p>
<h3 id="17-27"><a href="#17-27" class="headerlink" title="17:27"></a>17:27</h3><p>T4 暴力调出来了。交一发。</p>
<p>然后发现上一发 T2 还没测出来，估计要等一段时间了。</p>
<p>于是决定把 T2 拍上。</p>
<h3 id="17-32"><a href="#17-32" class="headerlink" title="17:32"></a>17:32</h3><p>T2 测出来了，还是 wa。继续写 T2 的暴力。</p>
<h3 id="17-38"><a href="#17-38" class="headerlink" title="17:38"></a>17:38</h3><p>T2 暴力写完了。去写 T2 的 gen 了。顺手交了一发暴力看看写没写对。</p>
<h3 id="17-42"><a href="#17-42" class="headerlink" title="17:42"></a>17:42</h3><p>拍上了。同时继续检查 T2。</p>
<h3 id="17-50"><a href="#17-50" class="headerlink" title="17:50"></a>17:50</h3><p>查不出来错。。。然后发现 T4 的暴力过了 30 分。</p>
<h3 id="17-58"><a href="#17-58" class="headerlink" title="17:58"></a>17:58</h3><p>去看 T4 的别的部分分了。</p>
<p>想写一下 $a_i \le 1$ 的部分分。</p>
<h3 id="18-05"><a href="#18-05" class="headerlink" title="18:05"></a>18:05</h3><p>$a_i \le 1$ 写完了，这时候 T2 暴力终于 running 了。</p>
<p>然后发现 T2 暴力 wa 了。崩溃了。怀疑是不是读错了题。</p>
<h3 id="18-12"><a href="#18-12" class="headerlink" title="18:12"></a>18:12</h3><p>完全不知道自己 T2 哪里错了。而且评测队列超长，估计赛后都测不出来。</p>
<p>把 <code>#define int long long</code> 的 <code>int</code> 全改成了 <code>long long</code> 又交了一发。但是肯定没用啊。</p>
<p>T4 还没测出来。去看看通信题。</p>
<h3 id="18-25"><a href="#18-25" class="headerlink" title="18:25"></a>18:25</h3><p>想了十几分钟还没有想出一个比较好的可以拿的部分分。没办法了，先去把这题的 4 分做法写了吧。</p>
<h3 id="18-34"><a href="#18-34" class="headerlink" title="18:34"></a>18:34</h3><p>4 分做法写完了。交了一发。</p>
<p>这时候 T4 还没有测出来。T2 的也没有（不过我确信一定会 wa）。</p>
<p>继续看看 T2 吧。。。</p>
<h3 id="19-00"><a href="#19-00" class="headerlink" title="19:00"></a>19:00</h3><p>我！终！于！知！道！了！</p>
<p>T2 子段必须非空！！！！！！</p>
<p>初始化 <code>ans</code> 应该为 <code>-inf</code>！！！</p>
<p>提交！！！不过这个点交可能看不到结果了。。</p>
<h3 id="19-14"><a href="#19-14" class="headerlink" title="19:14"></a>19:14</h3><p>发现了一个 T4 $a_i \le 1$ 时的错误，改掉了，交了一发。</p>
<h3 id="19-18"><a href="#19-18" class="headerlink" title="19:18"></a>19:18</h3><p>弃疗了，看了会 cppreference。</p>
<h3 id="19-20"><a href="#19-20" class="headerlink" title="19:20"></a>19:20</h3><p>比赛结束！</p>
<p>估分 $65 + 50 + 4 + 40 = 159$。目前能确定的是 T1 65 分和 T4 30 分。</p>
<p>突然感觉好悬啊…尤其是这个 T2，要是还是 wa 的话我就死了。</p>
<h3 id="19-30"><a href="#19-30" class="headerlink" title="19:30"></a>19:30</h3><p>交流了一下。</p>
<p>发现 T1 就是直接 dp，但是好像要多预处理一点东西？不过我预处理了这个啊，复杂度我感觉也是对的。</p>
<p>T2 有个超短的 50 分 dp 做法。。。果然我 dp 不行。</p>
<p>T3 rui_er 用随机拿到了 36 分，orz。</p>
<p>T4 没啥交流出的东西。</p>
<h3 id="20-12"><a href="#20-12" class="headerlink" title="20:12"></a>20:12</h3><p>终于，pretest 测完了。</p>
<p>$65 + 50 + 0 + 30 = 145$。最后那 4 分和 10 分还是挂了。</p>
<p>不过好在 T2 的 50 分拿到了…我的 T2 当时是我最害怕 wa 的。</p>
<p>明天工程题加油！想翻盘…</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><p>今天是工程题。想到了去年被 T4 依赖 T3 给害惨了的经历，决定这次要稳扎稳打，不要再被出题人坑了（伏笔）。</p>
<p>能翻盘吗？？</p>
<p>复习了一下二进制文件读写，就匆匆开考了。</p>
<h3 id="9-00"><a href="#9-00" class="headerlink" title="9:00"></a>9:00</h3><p>延时 10min 开始考试。传统艺能了属于是。</p>
<h3 id="9-10"><a href="#9-10" class="headerlink" title="9:10"></a>9:10</h3><p>开始考试！</p>
<h3 id="9-12"><a href="#9-12" class="headerlink" title="9:12"></a>9:12</h3><p>发现这次工程题和去年有很大不同。去年是让你实现一个大项目，填补其中的空缺。而今天是五个小项目，每个项目分别涉及一种知识。</p>
<ul>
<li>T1 是写一个简单 HTML 解析器，应该是比联合省选 D1T1 还好写的小模拟。</li>
<li>T2 好像是模拟一个爬虫的过程。</li>
<li>T3 是实现判断查询词与文档相关性的一个算法。</li>
<li>T4 是实现一个网页权重算法 PageRank。</li>
<li>T5 是实现一棵决策树用来文本分类，好像是机器学习啥的，很吓人。</li>
</ul>
<p>肯定先写 T1。</p>
<h3 id="9-17"><a href="#9-17" class="headerlink" title="9:17"></a>9:17</h3><p>研究完了 T1 的题面。</p>
<p>关于 T1 这样的类似标签嵌套状物的模拟题的实现套路我已经很熟练了，多亏了同学的一道丧心病狂的阴间模拟题对我的磨练。</p>
<p>我的模拟思路大概就是将输入全都读入进来之后维护一个字符指针，在这个读入的字符串上做递归，时刻传字符指针的引用就行了。</p>
<p>开写！</p>
<p>首先开局读入全文…想到了刚复习的 fread！虽然不是二进制文件读写，但是能一次读全文件的性质也很有用！</p>
<h3 id="9-41"><a href="#9-41" class="headerlink" title="9:41"></a>9:41</h3><p>写完了！稍微调了几秒钟就过了样例。交了一发。</p>
<p>为啥没 pretest？？？</p>
<p>发现了个小错，改掉了再交一发。</p>
<p>但是没 pretest 真的太虚了…</p>
<h3 id="9-45"><a href="#9-45" class="headerlink" title="9:45"></a>9:45</h3><p>提了个问题，“老师请问这场比赛是没有 pretest 吗”。</p>
<p>然后又感到了关于 T1 输出格式的问题…如果一段非空但是前后是空的的话要删掉前后吗…</p>
<p>于是又问了个问题。</p>
<h3 id="9-51"><a href="#9-51" class="headerlink" title="9:51"></a>9:51</h3><p>手造了几组样例，感觉没啥问题了。</p>
<p>去看 T2。</p>
<h3 id="10-04"><a href="#10-04" class="headerlink" title="10:04"></a>10:04</h3><p>将 T2 的题意彻底理解清楚了。直接模拟就可以了，挺水的。</p>
<p>不过这个逗号分隔字符串真的恶心人…我写了个用 <code>getline</code>，然后找到 <code>,</code> 的位置后用 <code>substr</code> 拆开逗号前后的部分。对于后边的字符串，开一个 <code>stringstream</code>，从这个 <code>stringstream</code> 中读入每个用空格隔开的字符串。</p>
<h3 id="10-35"><a href="#10-35" class="headerlink" title="10:35"></a>10:35</h3><p>T2 很快写完了，而且还是在中间时不时回头看看 T1（因为觉得不稳）的情况下。</p>
<h3 id="10-38"><a href="#10-38" class="headerlink" title="10:38"></a>10:38</h3><p>发现现在有 pretest 了，T2 wa 了。同时交了一发 T1，RE on pretest 3。决定先调 T2。</p>
<h3 id="10-40"><a href="#10-40" class="headerlink" title="10:40"></a>10:40</h3><p>发现了 T2 的错误。写完之后交了一发，过了。</p>
<p>然后又想了想 T1 为什么错。</p>
<h3 id="10-47"><a href="#10-47" class="headerlink" title="10:47"></a>10:47</h3><p>T1 还是改不对，怀疑 pretest 3 是假的，因为我对我的做法抱有自信。</p>
<p>问了出题人一个问题，“T1 pretest 3 是否错误”。</p>
<p>出题人：“很抱歉不能理解您的意思”。</p>
<p>。。。</p>
<h3 id="10-56"><a href="#10-56" class="headerlink" title="10:56"></a>10:56</h3><p>这时候发现了果然 T1 要删掉前后的空白字符，改了一下又交了一发，果然还是 RE on pretest 3。</p>
<h3 id="10-57"><a href="#10-57" class="headerlink" title="10:57"></a>10:57</h3><p>决定先放手，去写 T3 了，不敢在 T1 这个坑里浪费太多时间，重蹈去年的覆辙。</p>
<p>T3 我决定先看中文文档，实在不行再看英文的。</p>
<p>然后发现那个中文文档是保姆级的，直接代入式子就完事了…</p>
<p>只不过式子里有些地方有点歧义（比如 $\log$ 没有写底数、文章长度没有定义是单词个数还是字符个数等等），但是我觉得多试几次就能出来。</p>
<h3 id="11-00"><a href="#11-00" class="headerlink" title="11:00"></a>11:00</h3><p>开始写 T3 了。</p>
<p>写 T3 中间还穿插着一些对 T1 的试探…但是估计没啥希望…</p>
<h3 id="11-21"><a href="#11-21" class="headerlink" title="11:21"></a>11:21</h3><p>T3 的文档非常好理解，现在就写完了。</p>
<p>交了一下，wa 了。尝试改了改各种地方的不明确定义，最后发现是文章长度我写的字符个数，改成了单词个数试试。然后就过了。</p>
<h3 id="11-25"><a href="#11-25" class="headerlink" title="11:25"></a>11:25</h3><p>开始看 T4。</p>
<h3 id="11-34"><a href="#11-34" class="headerlink" title="11:34"></a>11:34</h3><p>看完了其中一个中文文档，感觉也是挺容易实现的一个算法。只是还是有点不明确的地方。</p>
<p>然后看了看另一个中文文档，发现那个文档比这个写的详细多了，许多细节的问题在这里得到了解答。</p>
<p>在草稿纸上整理了一下式子，准备开写！</p>
<h3 id="11-43"><a href="#11-43" class="headerlink" title="11:43"></a>11:43</h3><p>写完了。不得不说，这道题真的是今天的工程题中输入最最容易的题了…</p>
<p>样例一发过。交了一发，也一发过了。真不错。</p>
<p>下面就是一个至关重要的决策了。</p>
<ul>
<li>去尝试调 T1 的 4 分。</li>
<li>去做看起来根本看不懂而且量很大感觉做不完的 T5。</li>
</ul>
<p>我选择了后者。理由如下：</p>
<ul>
<li>T1 的 4 分我脑子中没有任何头绪。现在去调，也不知道能不能调出来，调出来了也只能多 4 分，性价比极低。</li>
<li>T5 足足有 26 分，而且说不定不一定看不懂呢。总是要尝试一下，虽然一个多小时的样子真的不知道写不写的完。但这肯定比去写 T1 更加值当。</li>
</ul>
<p>于是我做了一个本场比赛最正确的决定，放弃 T1 的 4 分。赛后也证明了 pretest 3 确实假了。而我浪费在上面的时间只有前前后后加起来半小时左右，相比之下很多人两个小时耗在上面最后没有去写 T5 痛失 AK 机会。</p>
<p>于是我开始看 T5 了。</p>
<h3 id="11-46"><a href="#11-46" class="headerlink" title="11:46"></a>11:46</h3><p>我先看的是那个博客文档。里面对决策树给出了一个不错的定义，配上女生找对象的实例促进了我的理解。（？）</p>
<p>但是那个博客文档的伪代码非常难懂，让人完全摸不着头脑。</p>
<p>于是我去看了看别的文档。</p>
<p>英文文档先不管了，发现有一个中文书。</p>
<h3 id="11-55"><a href="#11-55" class="headerlink" title="11:55"></a>11:55</h3><p>那本书里的伪代码真不错！一下就看懂了！</p>
<p>还有信息熵的式子！解释的比那个博客文档不知高到哪里去了，可以直接扒下来用！</p>
<p>但是这个伪代码看着简单，实现想必是十分复杂……</p>
<p>尤其是伪代码中一行带过的一步，这一步实际上十分重要也比较难写…</p>
<p>但是不能犹豫，我先简单规划了一下建树的实现。</p>
<h3 id="12-00"><a href="#12-00" class="headerlink" title="12:00"></a>12:00</h3><p>规划完了。大概是这么个想法：</p>
<ul>
<li>训练集合使用一个数组存下标的方式维护。dfs 在这个数组上进行。dfs 中传参数传数组中的一段区间 $[l, r]$。然后使用类似归并排序的方式，开一个临时数组，将需要划到左子树的训练文档下标放在临时数组的左侧，划到右子树的放到右侧，然后 copy 到原数组里，用 $[l, mid]$ 和 $[mid + 1, r]$ 递归下去。</li>
<li>当前的决策集合不是特别大（最多只有 6），可以在 dfs 参数中开一个 <code>set</code>，反正开的下。</li>
<li>此外就是需要无比细心的实现就是了…讲真我想到这一步我都感觉我写不完了，但总还是要尝试一下的…</li>
</ul>
<p>开写！</p>
<h3 id="12-46"><a href="#12-46" class="headerlink" title="12:46"></a>12:46</h3><p>居然写完了！感觉做题的时候把思路放清晰真的是一个很好的做法。</p>
<p>测测样例…果然挂了，中间 RE 了。</p>
<p>没关系，现在还有 24 分钟调试时间。</p>
<p>不过我对我调试 200 行的代码不太有信心就是了…</p>
<h3 id="12-50"><a href="#12-50" class="headerlink" title="12:50"></a>12:50</h3><p>发现自己对当前节点的处理出现了问题。果断改掉。</p>
<p>然后呢，还是没有输出。</p>
<h3 id="12-53"><a href="#12-53" class="headerlink" title="12:53"></a>12:53</h3><p>又发现自己对信息熵的计算出现了一些问题。</p>
<p>在计算信息熵时，我没有循环到类别总数，而是错误地循环到了决策总数。</p>
<p>改了改，发现有输出了，但是是错的。</p>
<h3 id="13-02"><a href="#13-02" class="headerlink" title="13:02"></a>13:02</h3><p>发现自己在计算使用每个决策后分别的信息熵时算了个寂寞…</p>
<p>于是改了改。</p>
<p>怎么又 RE 了？</p>
<h3 id="13-05"><a href="#13-05" class="headerlink" title="13:05"></a>13:05</h3><p>我发现自己得出的一些信息熵是 <code>nan</code>。</p>
<p>然后发现了出现某一类别的概率可能为 $0$ …然后对着 $0$ 求 $\log$，必死无疑。</p>
<p>把这个 $0$ 判了一下。</p>
<p>过样例了！</p>
<h3 id="13-06"><a href="#13-06" class="headerlink" title="13:06"></a>13:06</h3><p>提交。</p>
<p>过了！！！nice！！！！</p>
<p>然后去搞了搞 T1 的 pretest 3 作为娱乐。最后显然没有搞出来就是了。</p>
<h3 id="13-10"><a href="#13-10" class="headerlink" title="13:10"></a>13:10</h3><p>考试结束。</p>
<p>出考场，交流了一下，发现 T1 pretest 3 确实是假的。那我是不是 AK 了？</p>
<p>反正翻盘了是肯定的。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day ?"></a>Day ?</h1><p>优秀。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>有限微积分与求和式</title>
    <url>/2022/05/%E6%9C%89%E9%99%90%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%B1%82%E5%92%8C%E5%BC%8F/</url>
    <content><![CDATA[<p>有限微积分是一种处理普通和式的利器，其类比了我们平时见到的无限微积分的知识。</p>
<p>from 《具体数学》2.6。</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们知道，无限微积分中定义的微分算子 $\mathrm{D}$（求导）满足</p>
<script type="math/tex; mode=display">\mathrm{D}f(x) = \frac{\mathrm{d}}{\mathrm{d}x}f(x)=\lim_{h\to 0}\frac{f(x + h) - f(x)}{h}</script><p>有限微积分则是基于差分算子 $\Delta$。</p>
<script type="math/tex; mode=display">\Delta f(x) = f(x + 1) - f(x)</script><p>注意此处的差分定义可能与 OI 中常见的差分数组定义不同。</p>
<p>差分算子满足的一条美妙性质可以与微分算子媲美：</p>
<script type="math/tex; mode=display">\Delta(x^{\underline{m}}) = mx^{\underline{m - 1}}</script><p>与 $\mathrm{D}(x^m) = mx^{m - 1}$ 十分相似。</p>
<p>无限微积分中，有个东西叫做积分，是微分的逆运算：</p>
<script type="math/tex; mode=display">g(x) = \mathrm{D}f(x) \Longleftrightarrow \int g(x)\mathrm{d}x = f(x) + C</script><p>类似地，差分的逆运算显然是求和：</p>
<script type="math/tex; mode=display">g(x) = \Delta f(x) \Longleftrightarrow \sum g(x)\delta x = f(x) + C</script><p>我们称之为不定和式（类比不定积分）。</p>
<p>无限微积分存在定积分，若 $g(x) = \mathrm{D}f(x)$，那么：</p>
<script type="math/tex; mode=display">\int^{b}_{a}g(x)\mathrm{d}x = f(x)\big |_{a}^{b} = f(b) - f(a)</script><p>那么有限微积分应该也有定和式，若 $g(x) = \Delta f(x)$，那么：</p>
<script type="math/tex; mode=display">\sum\nolimits_{a}^{b}g(x)\delta x = f(x)\big |_{a}^{b} = f(b) - f(a)</script><p>这玩意太玄学了！不过，经过大眼观察，可以发现</p>
<script type="math/tex; mode=display">\sum\nolimits_{a}^{b}g(x)\delta x = \sum_{i = a}^{b - 1}g(i)</script><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><p>定和式显然满足定积分中的一些性质，如</p>
<script type="math/tex; mode=display">\sum\nolimits_{a}^{b}g(x)\delta x + \sum\nolimits_{b}^{c}g(x)\delta x = \sum\nolimits_{a}^{c}g(x)\delta x</script><script type="math/tex; mode=display">\sum\nolimits_{a}^{b}(f(x) + g(x))\delta x = \sum\nolimits_{a}^{b}f(x)\delta x + \sum\nolimits_{a}^{b}g(x)\delta x</script><p>这时候可能就会想到了，上面说了下降幂在有限微积分中可以类比连续情况下的普通幂，那么在求解关于下降幂的和式时，有没有一种简单方法？没错：</p>
<script type="math/tex; mode=display">\sum_{0\le k < n}k^{\underline{m}} = \sum\nolimits_{0}^{n}k^{\underline{m}} = \left.\frac{k^{\underline{m + 1}}}{m + 1}\right |_{0}^{n} = \frac{n^{\underline{m + 1}}}{m + 1}</script><p>这启发我们：在求解和式的时候，考虑有限微积分的可能性。</p>
<p>例如求解</p>
<script type="math/tex; mode=display">\sum_{k = 1}^{n}k^2</script><p>时，考虑到 $k^2 = k(k - 1) + k = k^{\underline{2}} + k$，可以得出</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{k = 1}^{n}k^2 & = \sum\nolimits_{1}^{n + 1}(x^{\underline{2}} + x)\delta x\\
& = \left.\left(\frac{x^{\underline{3}}}{3} + \frac{x^{\underline{2}}}{2}\right)\right|_{1}^{n + 1} \\
& = \frac{2n(n - 1)(n + 1) - 3n(n + 1)}{6} \\
& = \frac{n(n + 1)(2n + 1)}{6}
\end{aligned}</script><p>非常的无脑。只需要用人脑做普通多项式转下降幂多项式。</p>
<h2 id="更多差分"><a href="#更多差分" class="headerlink" title="更多差分"></a>更多差分</h2><p>首先，可以将下降幂推广到指数 $&lt; 0$ 的情况。</p>
<p>观察到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x^{\underline{3}} & = x(x - 1)(x - 2) \\
x^{\underline{2}} & = x(x - 1) \\
x^1 & = x \\
x^{\underline{0}} & = 1
\end{aligned}</script><p>那我们显然可以继续向下写：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x^{\underline{-1}} & = \frac{1}{x + 1} \\
x^{\underline{-2}} & = \frac{1}{(x + 1)(x + 2)} \\
x^{\underline{-3}} & = \frac{1}{(x + 1)(x + 2)(x + 3)}
\end{aligned}</script><p>因此我们可以给出负指数下降幂的定义：</p>
<script type="math/tex; mode=display">
x^{\underline{-m}} = \frac{1}{(x + 1)(x + 2)\cdots (x + m)}\quad(m > 0)</script><p>这种定义能使下降幂推广前的美好性质得到满足。</p>
<p>由此可见：</p>
<script type="math/tex; mode=display">
\sum\nolimits_{a}^{b} x^{\underline{m}}\delta x = \left.\frac{x^{\underline{m + 1}}}{m + 1}\right|_{a}^{b}, \quad m \neq -1.</script><p>那么问题来了，$x^{\underline{-1}}$ 的不定和式是什么呢？</p>
<p>换句话说，我们需要求一个满足 $\Delta f(x) = x^{\underline{-1}} = \frac{1}{x + 1}$ 的 $f(x)$。</p>
<p>那 $f(x)$ 不就是 $H_x$（调和级数）吗？</p>
<script type="math/tex; mode=display">\sum x^{\underline{-1}}\delta x = H_x + C</script><p>类似地，考虑在无限微积分中，$\int x^{-1}$ 的值。</p>
<script type="math/tex; mode=display">\int x^{-1}\mathrm{d}x = \ln x + C</script><p>因此，可以得出：调和级数 $H_x$ 是对 $\ln x$ 的有限模拟。</p>
<p>现在下降幂的不定和式就可以直接得出了：</p>
<script type="math/tex; mode=display">
\sum x^{\underline{m}}\delta x =
\begin{dcases}
\frac{x^{\underline{m + 1}}}{m + 1} + C, & m \neq -1\\
H_x + C, & m = -1
\end{dcases}</script><p>既然有了 $\ln x$ 在有限情况下的对应物，不难想到去找 $\mathrm{e}^x$ 的类似物。</p>
<p>回忆一下：$\mathrm{D}\mathrm{e}^x = e^x$。我们可以找一找满足 $\Delta f(x) = f(x)$ 的函数 $f(x)$ 作为 $\mathrm{e}^x$ 的有限模拟。</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x) & = \Delta f(x) \\
& = f(x + 1) - f(x)\\
\therefore f(x + 1) &= 2f(x) \\
\end{aligned}</script><p>因此，我们可以取 $f(x) = 2^x$ 作为离散指数函数。</p>
<p>类似地，$\Delta c^x$ 也非常好求。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta c^x & = c^{x + 1} - c^x \\
& = (c - 1)c^x
\end{aligned}</script><h2 id="分部求和"><a href="#分部求和" class="headerlink" title="分部求和"></a>分部求和</h2><p>首先，我们知道无限微积分中有个东西叫做链式法则：</p>
<script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}u}\cdot \frac{\mathrm{d}u}{\mathrm{d}x} = \frac{\mathrm{d}y}{\mathrm{d}x}</script><p>换句话说：</p>
<script type="math/tex; mode=display">
(f(g(x)))' = f'(g(x))\cdot g'(x)</script><p>但是，在有限微积分中并没有对应的链式法则，因为在这一体系中定义域仅为整数集的函数值域却是实数集，导致复合函数多数情况下没有定义。</p>
<p>不过，在无限微积分中的乘积法则</p>
<script type="math/tex; mode=display">\mathrm{D}(uv) = u\mathrm{D}v + v\mathrm{D}u</script><p>即</p>
<script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d}x}(uv) = u\frac{\mathrm{d}v}{\mathrm{d}x} + v\frac{\mathrm{d}u}{\mathrm{d}x}</script><p>可以导出分部积分法则：</p>
<script type="math/tex; mode=display">\int u\mathrm{D}v\ \mathrm{d}x = uv - \int v\mathrm{D}u\ \mathrm{d}x</script><p>在有限情况下有一个对应，即乘积差分法则：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta(u(x)v(x)) & = u(x + 1)v(x + 1) - u(x)v(x) \\
& = u(x + 1)v(x + 1) - u(x)v(x + 1) + u(x)v(x + 1) - u(x)v(x) \\
& = (u(x + 1) - u(x))v(x + 1) + u(x)(v(x + 1) - v(x)) \\
& = u(x)\Delta v(x) + v(x + 1)\Delta u(x)
\end{aligned}</script><p>emm，这种形式有点丑陋，我们引入一个<strong>移位算子</strong> $\mathrm{E}$ 满足</p>
<script type="math/tex; mode=display">
\mathrm{E}f(x) = f(x + 1)</script><p>那么就可以写出</p>
<script type="math/tex; mode=display">\Delta(uv) = u\Delta v + \mathrm{E}v\Delta u</script><p>对着它两边求和，我们可以得到分部求和法则：</p>
<script type="math/tex; mode=display">
\sum u\Delta v\ \delta x = uv - \sum \mathrm{E}v\Delta u\ \delta x</script><p>我们可以使用分部积分求解 $\int x\mathrm{e}^x\mathrm{d}x$，取 $u = x$，$\mathrm{D}v = \mathrm{e}^x$，那么 $\mathrm{D}u = 1$，$v = \mathrm{e}^x$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\int x\mathrm{e}^x \mathrm{d}x & = \int u\mathrm{D}v\ \mathrm{d}x \\
& = uv - \int v\mathrm{D}u\ \mathrm{d}x \\
& = x\mathrm{e}^x - \int \mathrm{e}^x\mathrm{d}x \\
& = x\mathrm{e}^x - \mathrm{e}^x + C
\end{aligned}</script><p>类似地，我们可以用分部求和法则求解 $\int x\mathrm{e}^x\mathrm{d}x$ 的有限模拟 $\sum x2^x\mathrm{d}x$。</p>
<p>取 $u = x$，$\Delta v = 2^x$，那么 $\Delta u = 1$，$v = 2^x$，$\mathrm{E}v = 2^{x + 1}$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum x2^x\delta x & = \sum u\Delta v\ \delta x\\
& = uv - \sum \mathrm{E}v\Delta u\ \delta x \\
& = x2^x - \sum2^{x + 1}\delta x \\
& = x2^x - 2^{x + 1} + C
\end{aligned}</script><p>这样，我们可以方便地求出和式 $\sum_{k = 0}^{n}k2^k$ 的值：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{k = 0}^{n}k2^k & = \sum\nolimits_{0}^{n + 1}x2^x\delta x \\
& = \left.x2^x - 2^{x + 1}\right|_{0}^{n + 1} \\
& = \left((n + 1)2^{n + 1} - 2^{n + 2}\right) - (0\times 2^0 - 2^{0 + 1}) \\
& = (n - 1)2^{n + 1} + 2
\end{aligned}</script><p>类似地，我们可以求出 $\sum_{k=0}^{n}H_k$ 的值。</p>
<p>取 $u = H_x$，$\Delta v = 1$，那么 $\Delta u = x^{\underline{-1}}$，$v = x$，$\mathrm{E} v = x + 1$。</p>
<p>则</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum H_x\delta x & = \sum u\Delta v\ \delta x\\
& = uv - \sum \mathrm{E}v\Delta u\ \delta x \\
& = xH_x - \sum (x + 1) \cdot x^{\underline{-1}}\delta x\\
& = xH_x - \sum (x + 1) \cdot \frac{1}{x + 1}\delta x \\
& = xH_x - \sum 1\ \delta x\\
& = xH_x - x + C
\end{aligned}</script><p>那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{k = 0}^{n}H_k &= \sum\nolimits_{0}^{n + 1}H_x\delta x \\
& = \left.xH_x - x\right|_{0}^{n + 1} \\
& = (n + 1)H_{n + 1} - (n + 1)
\end{aligned}</script>]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>THUPC2022 初赛游记</title>
    <url>/2022/03/THUPC2022-%E5%88%9D%E8%B5%9B%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Day"><a href="#Day" class="headerlink" title="Day -?"></a>Day -?</h2><p>组建了一支战队，全是我们班同学：</p>
<ul>
<li>@<a href="https://www.luogu.com.cn/user/89127" target="_blank" rel="noopener">$\mathtt{2x6 \underline{\ \ } 81}$</a></li>
<li>@<a href="https://www.luogu.com.cn/user/121911" target="_blank" rel="noopener">$\mathtt{sqrt \underline{\ \ } 7}$</a></li>
<li>@<a href="https://www.luogu.com.cn/user/76156" target="_blank" rel="noopener">$\mathtt{henrytb}$</a></li>
</ul>
<p>队伍名称是 <code>啊拉擦擦，巴里里巴里里</code>。</p>
<a id="more"></a>
<p>我校同年级的另一支队伍：</p>
<ul>
<li>@<a href="https://www.luogu.com.cn/user/122461" target="_blank" rel="noopener">$\mathtt{rui \underline{\ \ } er}$</a></li>
<li>@<a href="https://www.luogu.com.cn/user/55959" target="_blank" rel="noopener">$\mathtt{AC \underline{\ \ } Automation}$</a></li>
<li>@<a href="https://www.luogu.com.cn/user/242702" target="_blank" rel="noopener">$\mathtt{registerGen}$</a></li>
</ul>
<p>队伍名称是 <code>世一大附中老同志</code>。</p>
<p>此外我校还有两队，这里不再赘述。</p>
<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>果然是土豆 OJ。</p>
<p>旋转的土豆很可爱。</p>
<p>测试赛 T1 A + B，T2 一眼哈希。</p>
<p>事先约好了，第二天三个人聚在一块看题而不是分别看。</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>押了一个输出 <code>peace</code> 的 M 题决定比手速。</p>
<h3 id="赛时"><a href="#赛时" class="headerlink" title="赛时"></a>赛时</h3><p>结果比赛开始后发现根本没有 M 题。</p>
<p>然后就开始看题了！</p>
<p>我和 $\mathtt{sqrt \underline{\ \ } 7}$ 紧密团结在 $\mathtt{2x6 \underline{\ \ } 81}$ 周围一起看题。</p>
<ul>
<li>A 题似乎可做。</li>
<li>B 题像个 DP。</li>
<li>C 题完全不会。</li>
<li>D 题似乎可做。</li>
<li>E 题像个 DS。</li>
<li>F 题是什么鬼？</li>
<li>G 题不是太会。</li>
<li>H 题看不懂题。</li>
<li>I 题像网络流。</li>
<li>J 题是大模拟。</li>
<li>K 题是小模拟。</li>
</ul>
<p>看完题了，$\mathtt{sqrt \underline{\ \ } 7}$ 飞速想出了 K 题的做法，并且十分钟一发过了这道题（而 $\mathtt{rui \underline{\ \ } er}$ 他们队这题挂了 7 发，耗时一个半小时）。然后一个小时在尝试做一道事实证明是不可做的题。</p>
<p>我发现 J 事实上可做，于是去做 J 了。</p>
<p>$\mathtt{2x6 \underline{\ \ } 81}$ 去想 A 题。</p>
<p>一小时左右之后，$\mathtt{2x6 \underline{\ \ } 81}$ 写完了 A 题，并且一发过了。于是 $\mathtt{2x6 \underline{\ \ } 81}$ 和 $\mathtt{sqrt \underline{\ \ } 7}$ 开始一起想 D 题。</p>
<p>这时我还在使劲写着 J 题，中间还误入过歧途，好在很快想出了正确的做法。</p>
<p>比赛开始 2 小时 23 分钟后，我终于通过了 J 题（并引来了 $\mathtt{rui \underline{\ \ } er}$ 的跟题）。</p>
<p>然后我去看 I 题的最小割建模。想了 20 分钟左右没有结果，看了看榜发现除了 A、D、J、K 以外最可做的题应该是 B 题，于是去想 B 题。</p>
<p>B 题应该是 DP。</p>
<p>这时，$\mathtt{sqrt \underline{\ \ } 7}$ 过来和我一起想 B 题，留下 $\mathtt{2x6 \underline{\ \ } 81}$ 一个人写 D（D 题他们已经得出了最多用两个寄存器的结论）。</p>
<p>考虑到和的期望等于期望的和，于是需要考虑分别算贡献。</p>
<p>一开始 $\mathtt{sqrt \underline{\ \ } 7}$ 没有发现计算自身贡献比是算自己通向别人的更好做。我提醒了他，然后我们立刻提出了一个 DP 思路，开始写代码。</p>
<p>后来我们发现，这个 DP 思路有点问题。那时，我脑子已经转不动了，发现教室里有点缺氧，于是开窗通了通风。这是我们最艰难的时刻，比赛仅剩一个小时时间，B 和 D 都陷入了僵局。而 <code>世一大附中老同志</code> 已经过了 4 题。</p>
<p>这时，$\mathtt{sqrt \underline{\ \ } 7}$ 想出了一个新的 DP 思路！我立刻予以验证，该思路可行！我们立刻开始写写写。</p>
<p>在比赛还剩下 40 分钟时，$\mathtt{2x6 \underline{\ \ } 81}$ 将 D 题通过！我们吹响了反攻的号角。</p>
<p>写完代码后样例输出 0，我和 $\mathtt{sqrt \underline{\ \ } 7}$ 立即开始调试。过样例！把所有 <code>double</code> 换成 <code>long long</code>，把除法改成乘逆元……提交！</p>
<p>怎么 T 了？</p>
<p>四次方算法，逆元没有预处理，多带了只 $\log$ ！</p>
<p>终于，在比赛结束前 20 分钟，我们通过了 B 题，以 5 题 4 发罚时的成绩完成了这场比赛，和去年相比有了很大的进步。</p>
<p><img src="/pics/3.png" alt=""></p>
<h3 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h3><p>晚上，我和 $\mathtt{sqrt \underline{\ \ } 7}$ 讨论 B 题时，发现 B 题官方题解判了自环。</p>
<ul>
<li>我：这题居然有自环？？？</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：哈哈哈哈哈</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：哈哈哈哈哈哈哈哈哈</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：我觉得我们能 A 这道题简直是奇迹</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：我问了你你说不会自己到自己</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：然后我就再也没想自环的事</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：没想到根本不影响</li>
<li>我：是不是还好我说了那一句（</li>
<li>我：要不然多想一堆事</li>
<li>我：说不定还错了（</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：太奇怪了</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：太奇怪了</li>
<li>我：事实上自环不判我们做法还是对的</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：我现在真的很惊讶</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：我们那个玩意</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：它居然对了</li>
<li>我：我也很惊讶</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：根本没想那么多…</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：全靠直觉</li>
<li>我：至关重要的决策：开窗通风</li>
<li>$\mathtt{sqrt \underline{\ \ } 7}$：哈哈哈哈</li>
</ul>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2022 游记</title>
    <url>/2022/01/WC2022-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>初三了，在肝文化课，讲课全都没听。</p>
<h1 id="2022-1-26"><a href="#2022-1-26" class="headerlink" title="2022/1/26"></a>2022/1/26</h1><p>考试前一天。希望不要打铁。</p>
<p>去年冬令营的打铁经历在眼前流过，不堪入目，惨不忍睹。</p>
<p>希望今年能正常发挥，保铜争银。</p>
<a id="more"></a>
<h1 id="2022-1-27"><a href="#2022-1-27" class="headerlink" title="2022/1/27"></a>2022/1/27</h1><p>考试日还是来了，准备好迎接吧。</p>
<h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><h3 id="8-30，考试开始"><a href="#8-30，考试开始" class="headerlink" title="8:30，考试开始"></a>8:30，考试开始</h3><p>看题！</p>
<p>两道传统一道交互。</p>
<p>终于又有非传统了是吗。</p>
<ul>
<li>T1 是括号。怎么又是括号？被恶心到了。</li>
<li>T2 看起来像 DS/大分块，合理猜测是 lxl 题。</li>
<li>T3 粗略地看了一下，感觉有比较多的得分空间。</li>
</ul>
<p>然后就在想 T1。</p>
<h3 id="9-00"><a href="#9-00" class="headerlink" title="9:00"></a>9:00</h3><p>T1 尝试分析这堆匪夷所思的操作后无果，转去写 $25$ 分的无限 $5,6$ 操作。</p>
<h3 id="9-15"><a href="#9-15" class="headerlink" title="9:15"></a>9:15</h3><p>写完了，开始弄 T2。</p>
<p>先写个 $10$ 分暴力吧！</p>
<h3 id="9-30"><a href="#9-30" class="headerlink" title="9:30"></a>9:30</h3><p>发现 T2 有 $O(n\sqrt n\log n)$ 的 naive 莫队，期望得分 $20$。</p>
<p>去写了一下，测了大样例果然跑了几十秒，但是正确性没问题。</p>
<h3 id="10-00"><a href="#10-00" class="headerlink" title="10:00"></a>10:00</h3><p>继续琢磨 T2 的特殊性质，发现 $|a_i-i|\le 10$ 很好做。</p>
<p>因为这样我们询问的区间 $[l,r]$ 内，值域为 $[l+10,r-10]$ 的一定都在区间内。</p>
<p>预处理一下，然后两边暴力就行了。特别地，如果区间太短，直接暴力。</p>
<h3 id="10-30"><a href="#10-30" class="headerlink" title="10:30"></a>10:30</h3><p>暂时没什么好的想法了，给 T2 这一堆东西写了一坨对拍。</p>
<h3 id="10-50"><a href="#10-50" class="headerlink" title="10:50"></a>10:50</h3><p>感觉会 T2 $m=\frac{n(n-1)}{2}$ 的情况了。</p>
<p>大概就是按照莫队扩展的思路，对所有询问的结果进行预处理。</p>
<p>写完之后又拍了几遍 T2 的所有部分分。到现在为止 T2 对我的水平来说的剩余价值基本上榨干了。</p>
<h3 id="11-30"><a href="#11-30" class="headerlink" title="11:30"></a>11:30</h3><p>开始搞 T3。</p>
<p>认真读题，读了十几分钟。</p>
<p>我怀疑这个是出题人玩了什么类似的猜词游戏之后跑来出的。</p>
<p><code>char *</code> 好评，我不太会用 string 的特性。</p>
<p>然后就开始瞎写一通了。</p>
<h3 id="13-00"><a href="#13-00" class="headerlink" title="13:00"></a>13:00</h3><p>写了一个半小时，出来了一个极其垃圾的东西。</p>
<p>预处理了满足一些限制条件的单词列表。</p>
<p>然后就对着它乱搞，开始先随一个，出来 gold, silver 之后开始从表里瞎找满足条件的，但是没有采用随机（失策了），而是直接选取了满足条件的字典序最小的第一个。</p>
<p>弄出来了，然后调了一会 RE。然后发现 grader.cpp 很拉。</p>
<h3 id="13-15"><a href="#13-15" class="headerlink" title="13:15"></a>13:15</h3><p>这时我感觉有点悬，毕竟我只选了第一个。</p>
<p>但是现在改成随不太好改，只好变成在第一个和最后一个中随机选一个。</p>
<h3 id="13-20"><a href="#13-20" class="headerlink" title="13:20"></a>13:20</h3><p>魔改了一通 grader.cpp，改成把八千多个单词都测了。</p>
<p>发现只选第一个时，期望得分是 $38$ 左右。</p>
<p>第一个和最后一个中随机选一个时，期望得分是 $43$ 左右。</p>
<p>于是就这么着交上去了。</p>
<h3 id="13-30"><a href="#13-30" class="headerlink" title="13:30"></a>13:30</h3><p>考试结束！</p>
<p>估分：$25+60+43=128$。</p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>进行了一些交流。</p>
<p>听说 T3 好像随便写写模拟就能七八十分。</p>
<p>然后发现同机房的同学的 T3 都比我优秀很多。</p>
<p>感觉可能要打铜了。</p>
<p>rui_er T2 没写一个部分分有点亏。</p>
<p>2x6_81 T1 没写 25 分，T2 没写一些部分分有点亏。</p>
<p>AC_Automation 还是强，前两题也是 $25+60$，T3 比我高出 $30$ 分左右。</p>
<h2 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h2><p>听了听讲题。</p>
<ul>
<li>T1 居然要放到树上？从来没听说过括号串能变成树。括号建树，闻所未闻。</li>
<li>T3 居然是启发式搜索？考场上完全没往这方面去想。</li>
<li>T2 果然是 lxl 题，好像要回滚莫队或者值域分块，我都不会…</li>
</ul>
<p>另外评论区全是他们过了 T2 云云。感觉我只有铜牌了。</p>
<h1 id="2022-1-28"><a href="#2022-1-28" class="headerlink" title="2022/1/28"></a>2022/1/28</h1><p>昨晚打了场 CF，所以起得很晚。</p>
<h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2><p>闭幕式开始了。</p>
<p>先是 CCF 宣传片，然后是各个 CCF 领导们的讲话。</p>
<p>评论区：金牌、银牌、铜牌、铁牌、椰树牌（</p>
<p>结果在某个讲话中间公布了分数线…</p>
<p>Au $150$，Ag $100$，Cu $40$。</p>
<p>整个人顿时紧张了起来：我该不会 Ag 了吧？</p>
<p>然后就在各种担心自己挂分，越来越没有心思听领导讲话了。</p>
<p>终于等到了颁奖的时刻。</p>
<p>首先是铜牌，看见名单中公布的分数从低向高爬升，离 100 越来越近，我意识到，只要最后这一小块地方没有我，我就银牌了。</p>
<p>公布的分数越来越高，我也越来越紧张，心跳越来越快。终于念到了铜牌的最后一页，没有我！我得到银牌了！</p>
<p>我长舒了一口气。</p>
<p>到银牌 $111$ 分的时候，出现了我的名字。</p>
<p>从去年打铁的惨痛经历、CSP 与 NOIP 双爆炸以来，我终于在今年冬令营的赛场上真正地发挥出了自己应有的水平。</p>
<p>同机房的同学们也大都拿到了银牌。</p>
<p>在这个时刻，我反而没有激动，而是在想：那些分挂到哪里了？</p>
<p>出来了小分，我 $10+60+41=111$。</p>
<p>第三题在波动范围内，很正常。</p>
<p>第一题怎么没了 $15$ 分？</p>
<p>后来才发现，原来所有写了这些 $25$ 分的全都变成了 $10$ 分，应该是出题人数据挂了。</p>
<p>那么也就是说，我这次冬令营没有挂分。</p>
<p>机房同学们也拿到了好成绩：</p>
<ul>
<li>2x6_81 $0+25+81=106$ 分 Ag。</li>
<li>rui_er $10+40+68=118$ 分 Ag。</li>
<li>AC_Automation $10+50+73=133$ 分 Ag。</li>
<li>AliceLi $10+35+38=83$ 分 Cu。</li>
</ul>
<p>第一次拿 Ag，虽然只是冬令营，但是也是感触颇深。这也是我们的学校（弱校）的第一批 Ag。感觉我们在和我们的学校一起齐头并进地进步着，这可能是强校学生感受不到的吧。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>莫反习题整理</title>
    <url>/2022/01/%E8%8E%AB%E5%8F%8D%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>如题。本文主要整理莫反习题的做法以及一些推式子技巧。</p>
<a id="more"></a>
<h1 id="P2522-HAOI2011-Problem-b"><a href="#P2522-HAOI2011-Problem-b" class="headerlink" title="P2522 [HAOI2011] Problem b"></a>P2522 [HAOI2011] Problem b</h1><p>题目让我们求</p>
<script type="math/tex; mode=display">\sum_{i=a}^{b}\sum_{j=c}^{d}[\gcd(i,j)=k]</script><p>我们只需要会求</p>
<script type="math/tex; mode=display">\sum_{i=1}^{x}\sum_{j=1}^{y}[\gcd(i,j)=k]</script><p>然后容斥一下就好了。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{x}\sum_{j=1}^{y}[\gcd(i,j)=k]
& = \sum_{i=1}^{x/k}\sum_{j=1}^{y/k}[\gcd(i,j)=1] \\
& = \sum_{i=1}^{x/k}\sum_{j=1}^{y/k}\sum_{d|i,d|j}\mu(d) \\
& = \sum_{i=1}^{x/k}\sum_{j=1}^{y/k}\sum_{d}\mu(d)[d|i][d|j] & \cdots\cdots\text{①} \\
& = \sum_{d}\mu(d)\sum_{i=1}^{x/k}[d|i]\sum_{j=1}^{y/k}[d|j] \\
& = \sum_{d=1}^{\min\{\lfloor x/k\rfloor ,\lfloor y/k\rfloor \}}\mu(d)\left\lfloor\frac{x}{kd}\right\rfloor\left\lfloor\frac{y}{kd}\right\rfloor
\end{aligned}</script><p>技巧：在不会跳步的时候，建议使用 ① 处方法，使用艾弗森括号代替 $\sum$ 下的条件进行求和顺序的交换。</p>
<h1 id="P3455-POI2007-ZAP-Queries"><a href="#P3455-POI2007-ZAP-Queries" class="headerlink" title="P3455 [POI2007] ZAP-Queries"></a>P3455 [POI2007] ZAP-Queries</h1><p>同 P2522。</p>
<h1 id="P2257-YY的GCD"><a href="#P2257-YY的GCD" class="headerlink" title="P2257 YY的GCD"></a>P2257 YY的GCD</h1><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)\text{ is prime}]
& = \sum_{p\text{ is prime}}\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=p] \\
& = \sum_{p\text{ is prime}}\sum_{i=1}^{n/p}\sum_{j=1}^{m/p}[\gcd(i,j)=1] \\
& = \sum_{p\text{ is prime}}\sum_{i=1}^{n/p}\sum_{j=1}^{m/p}\sum_{d|i,d|j}\mu(d) \\
& = \sum_{p\text{ is prime}}\sum_{d}\mu(d)\left\lfloor\frac{n}{dp}\right\rfloor\left\lfloor\frac{m}{dp}\right\rfloor \\
& = \sum_{q}\left\lfloor\frac{n}{q}\right\rfloor\left\lfloor\frac{m}{q}\right\rfloor\sum_{p|q,p\text{ is prime}}\mu(\frac{q}{p}) & \cdots\cdots\text{①}
\end{aligned}</script><p>观察到</p>
<script type="math/tex; mode=display">
f(x) = \sum_{p|x,p\text{ is prime}}\mu(\frac{x}{p}) \\</script><p>是积性函数。对其进行线性筛然后整除分块处理原式即可。</p>
<p>技巧： ① 处，考虑到下取整除法的分母是 $dp$，于是令 $q=dp$ 转而枚举 $q$，便于进行整除分块。</p>
<h1 id="SP5971-LCMSUM-LCM-Sum"><a href="#SP5971-LCMSUM-LCM-Sum" class="headerlink" title="SP5971 LCMSUM - LCM Sum"></a>SP5971 LCMSUM - LCM Sum</h1><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n}\operatorname{lcm}(i,n)
& = n\sum_{i=1}^{n}\frac{i}{\gcd(i,n)} \\
& = n\sum_{d|n}\frac{1}{d}\sum_{i=1}^{n}i[\gcd(i,n)=d] \\
& = n\sum_{d|n}\frac{1}{d}\sum_{i=1}^{n/d}id[\gcd(i,\frac{n}{d})=1] \\
& = n\sum_{d|n}\sum_{i=1}^{n/d}i\sum_{k|i,k|\frac{n}{d}}\mu(k) \\
& = n\sum_{d|n}\sum_{i=1}^{n/d}i\sum_k[k|i][dk|n]\mu(k) \\
& = n\sum_{d|n}\sum_{k|\frac{n}{d}}k\mu(k)\sum_{i=1}^{n/kd}i \\
\text{令 }f(x) & = \frac{x(x+1)}{2},\text{ 则} \\
\text{原式}
& = n\sum_{d|n}\sum_{k|\frac{n}{d}}k\mu(k)f(\frac{n}{kd}) \\
& = n\sum_{q|n}f(\frac{n}{q})\sum_{k|q}k\mu(k) \\
\text{令 }g(x) & = \sum_{k|x}k\mu(k),\text{ 则} \\
\text{原式}
& = n\sum_{q|n}g(q)f(\frac{n}{q})
\end{aligned}</script><p>观察到 $g$ 是积性函数，线性筛出它。</p>
<p>答案是卷积形式，用类似埃氏筛的方法预处理出它。</p>
<h1 id="P1829-国家集训队-Crash-的数字表格-JZPTAB"><a href="#P1829-国家集训队-Crash-的数字表格-JZPTAB" class="headerlink" title="P1829 [国家集训队] Crash 的数字表格 / JZPTAB"></a>P1829 [国家集训队] Crash 的数字表格 / JZPTAB</h1><p>不妨设 $n\le m$。</p>
<p>令 $S(x)=\frac{x(x+1)}{2}$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n}\sum_{j=1}^{m}\operatorname{lcm}(i,j)
& = \sum_{i=1}^{n}\sum_{j=1}^{m}\frac{ij}{\gcd(i,j)} \\
& = \sum_{d=1}^{n}\frac{1}{d}\sum_{i=1}^{n}\sum_{j=1}^{m}ij[\gcd(i,j)=d] \\
& = \sum_{d=1}^{n}d\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}ij[\gcd(i,j)=1] \\
& = \sum_{d=1}^{n}d\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}ij\sum_{k|i,k|j}\mu(k) \\
& = \sum_{d=1}^{n}d\sum_{k=1}^{n/d}k^2\mu(k)\sum_{i=1}^{\frac{n}{dk}}i\sum_{j=1}^{\frac{m}{dk}}j \\
& = \sum_{d=1}^{n}d\sum_{k=1}^{n/d}k^2\mu(k)S(\left\lfloor\frac{n}{dk}\right\rfloor)S(\left\lfloor\frac{m}{dk}\right\rfloor) \\
& = \sum_{g=1}^{n}gS(\left\lfloor\frac{n}{g}\right\rfloor)S(\left\lfloor\frac{m}{g}\right\rfloor)\sum_{k|g}k\mu(k)
\end{aligned}</script><p>因为</p>
<script type="math/tex; mode=display">
f(x)=\sum_{k|x}k\mu(k)</script><p>是积性函数，我们线性筛出它即可。</p>
<h1 id="P3327-SDOI2015-约数个数和"><a href="#P3327-SDOI2015-约数个数和" class="headerlink" title="P3327 [SDOI2015]约数个数和"></a>P3327 [SDOI2015]约数个数和</h1><p>不妨设 $n\le m$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n}\sum_{j=1}^{m}d(ij)
& = \sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1] \\
& = \sum_{i=1}^{n}\sum_{j=1}^{m}\sum_x\sum_y[x|i][y|j][\gcd(x,y)=1] \\
& = \sum_{x=1}^{n}\sum_{y=1}^{m}[gcd(x,y)=1]\left\lfloor\frac{n}{x}\right\rfloor\left\lfloor\frac{m}{y}\right\rfloor \\
& = \sum_{x=1}^{n}\sum_{y=1}^{m}\sum_{d|x,d|y}\mu(d)\left\lfloor\frac{n}{x}\right\rfloor\left\lfloor\frac{m}{y}\right\rfloor \\
& = \sum_{d}\mu(d)\sum_{x=1}^{n/d}\sum_{y=1}^{m/d}\left\lfloor\frac{n}{dx}\right\rfloor\left\lfloor\frac{m}{dy}\right\rfloor \\
& = \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\left\lfloor\frac{n}{dx}\right\rfloor\sum_{y=1}^{m/d}\left\lfloor\frac{m}{dy}\right\rfloor
\end{aligned}</script><p>使用整除分块预处理</p>
<script type="math/tex; mode=display">
f(x)=\sum_{i=1}^{x}\left\lfloor\frac{x}{i}\right\rfloor</script><p>因此，</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n}\sum_{j=1}^{m}d(ij)
& = \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\left\lfloor\frac{n}{dx}\right\rfloor\sum_{y=1}^{m/d}\left\lfloor\frac{m}{dy}\right\rfloor \\
& = \sum_{d=1}^{n}\mu(d)f(\left\lfloor\frac{n}{d}\right\rfloor)f(\left\lfloor\frac{m}{d}\right\rfloor)
\end{aligned}</script><p>整除分块处理每个询问即可。</p>
<h1 id="P3312-SDOI2014-数表"><a href="#P3312-SDOI2014-数表" class="headerlink" title="P3312 [SDOI2014]数表"></a>P3312 [SDOI2014]数表</h1><p>先不考虑 $\le a$ 的限制条件。</p>
<p>设 $f(d)$ 表示 $d$ 的约数和。</p>
<p>不妨设 $n\le m$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{d|i,d|j}d
& = \sum_{d=1}^{n}f(d)\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[\gcd(i,j)=1] \\
& = \sum_{d=1}^{n}f(d)\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}\sum_{k|i,k|j}\mu(k) \\
& = \sum_{d=1}^{n}f(d)\sum_{k=1}^{n}\mu(k)\left\lfloor\frac{n}{dk}\right\rfloor\left\lfloor\frac{m}{dk}\right\rfloor \\
& = \sum_{q=1}^{n}\left\lfloor\frac{n}{q}\right\rfloor\left\lfloor\frac{m}{q}\right\rfloor\sum_{d|q}f(d)\mu\left(\frac{q}{d}\right)
\end{aligned}</script><p>令</p>
<script type="math/tex; mode=display">
g(x)=\sum_{d|x}f(d)\mu\left(\frac{x}{d}\right)</script><p>对于每个询问，只有 $\le a$ 的 $f(d)$ 才会被统计到。</p>
<p>那么，我们预处理出所有的 $f(x)$ 并进行排序，然后将询问离线按 $a$ 排序。</p>
<p>每次 $a$ 增加的时候，对影响到的 $g(x)$ 累加贡献。</p>
<p>我们需要快速单点修改 $g(x)$，并快速得到 $g(x)$ 的前缀和。</p>
<p>使用树状数组维护 $g(x)$ 即可。</p>
<h1 id="P4449-于神之怒加强版"><a href="#P4449-于神之怒加强版" class="headerlink" title="P4449 于神之怒加强版"></a>P4449 于神之怒加强版</h1><p>不妨设 $n\le m$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n}\sum_{j=1}^{m}\gcd(i,j)^k
& = \sum_{d}d^k\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=d] \\
& = \sum_{d}d^k\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[\gcd(i,j)=1] \\
& = \sum_{d}d^k\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}\sum_{g|i,g|j}\mu(g) \\
& = \sum_{d=1}^{n}d^k\sum_{g=1}^{n/d}\mu(g)\left\lfloor\frac{n}{dg}\right\rfloor\left\lfloor\frac{m}{dg}\right\rfloor \\
& = \sum_{h=1}^{n}\left\lfloor\frac{n}{h}\right\rfloor\left\lfloor\frac{m}{h}\right\rfloor\sum_{d|h}d^k\mu\left(\frac{h}{d}\right)
\end{aligned}</script><p>观察到</p>
<script type="math/tex; mode=display">
f(x)=\sum_{d|x}d^k\mu\left(\frac{x}{d}\right)</script><p>是积性函数。于是我们用线性筛、快速幂预处理出它。然后整除分块处理每个询问即可。</p>
<h1 id="P3768-简单的数学题"><a href="#P3768-简单的数学题" class="headerlink" title="P3768 简单的数学题"></a>P3768 简单的数学题</h1><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n}\sum_{j=1}^{n}ij\gcd(i,j) & = \sum_{d}d\sum_{i=1}^{n}\sum_{j=1}^{n}ij[\gcd(i,j)=d] \\
& = \sum_{d}d^3\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}ij[gcd(i,j)=1] \\
& = \sum_{d}d^3\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}ij\sum_{g|i,g|j}\mu(g) \\
& = \sum_{d=1}^{n}d^3\sum_{g}g^2\mu(g)\sum_{i=1}^{n/dg}i\sum_{j=1}^{n/dg}j
\end{aligned}</script><p>记 $S(x)=\sum_{i=1}^{x}i\sum_{j=1}^{x}j = \frac{x^2(x+1)^2}{4}$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{d=1}^{n}d^3\sum_{g}g^2\mu(g)\sum_{i=1}^{n/dg}i\sum_{j=1}^{n/dg}j & = \sum_{d=1}^{n}d^3\sum_{g}g^2\mu(g)S(\left\lfloor\frac{n}{dg}\right\rfloor) \\
& = \sum_{k=1}^{n}S(\left\lfloor\frac{n}{k}\right\rfloor)\sum_{d|k}d^3\left(\frac{k}{d}\right)^2\mu\left(\frac{k}{d}\right) \\
& = \sum_{k=1}^{n} k^2 S(\left\lfloor\frac{n}{k}\right\rfloor)\sum_{d|k}d\mu\left(\frac{k}{d}\right) \\
& = \sum_{k=1}^{n} k^2 S(\left\lfloor\frac{n}{k}\right\rfloor) \varphi(k)
\end{aligned}</script><p>注意到</p>
<script type="math/tex; mode=display">f(x)=x^2\varphi(x)</script><p>是积性函数。</p>
<p>观察数据范围，线性筛 $f$ 不行，需要杜教筛。</p>
<hr>
<p>对于杜教筛：令 $f(x)=x^2\varphi(x)$，$s(x)=\sum_{i=1}^{x}f(x)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n (f*g)(i) & = \sum_{i=1}^{n}\sum_{d|i} g(d)f(i/d) \\
& = \sum_{d=1}^{n} g(d)\sum_{i=1}^{n/d}f(i)\\
& = \sum_{d=1}^{n} g(d)s(n/d) \\
\therefore s(n)g(1) & = \sum_{i=1}^{n}(f*g)(i)-\sum_{d=2}^{n}g(d)s(n/d)\\
\end{aligned}</script><p>令 $g(x)=x^2$，则</p>
<script type="math/tex; mode=display">
\begin{aligned}
(f*g)(x) & = \sum_{d|x}f(d)g(x/d)\\ 
& = x^2\sum_{d|x}\varphi(d) \\
& = x^3 \\
\therefore \sum_{i=1}^{x}(f*g)(i)&=\frac{x^2(x+1)^2}{4}
\end{aligned}</script><h1 id="P3704-SDOI2017-数字表格"><a href="#P3704-SDOI2017-数字表格" class="headerlink" title="P3704 [SDOI2017]数字表格"></a>P3704 [SDOI2017]数字表格</h1><p>不妨设 $n\le m$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\prod_{i=1}^{n}\prod_{j=1}^{m}f_{\gcd(i,j)} & = \prod_{d}f_d^{\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=d]} \\
& = \prod_{d=1}^{n}f_{d}^{\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[\gcd(i,j)=1]} \\
\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[\gcd(i,j)=1] & = \sum_{i=1}^{n/d}\sum_{j=1}^{m/d}\sum_{g|i,g|j}\mu(g) \\
& = \sum_{g=1}^{n/d}\mu(g)\left\lfloor\frac{n}{gd}\right\rfloor\left\lfloor\frac{m}{gd}\right\rfloor \\
\therefore \prod_{i=1}^{n}\prod_{j=1}^{m}f_{\gcd(i,j)} & = \prod_{d=1}^{n}f_d^{\sum_{g=1}^{n/d}\mu(g)\left\lfloor\frac{n}{gd}\right\rfloor\left\lfloor\frac{m}{gd}\right\rfloor} \\
& = \prod_{k=1}^{n}\prod_{d|k}f_d^{\left\lfloor\frac{n}{k}\right\rfloor\left\lfloor\frac{m}{k}\right\rfloor\mu(\left\lfloor\frac{k}{d}\right\rfloor)} \\
& = \prod_{k=1}^{n}\left(\prod_{d|k}f_d^{\mu(\left\lfloor\frac{k}{d}\right\rfloor)}\right)^{\left\lfloor\frac{n}{k}\right\rfloor\left\lfloor\frac{m}{k}\right\rfloor}
\end{aligned}</script><p>用类似埃氏筛的方法预处理</p>
<script type="math/tex; mode=display">
g(x)=\prod_{d|x}f_d^{\mu(\left\lfloor\frac{x}{d}\right\rfloor)}</script><p>即可。询问用整除分块。</p>
<p>注意对指数 $\left\lfloor\frac{n}{k}\right\rfloor\left\lfloor\frac{m}{k}\right\rfloor$ 取模时使用费马小定理 $a^{p-1}\equiv 1\ (\bmod\ p)$。</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>水题选做</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2021游记</title>
    <url>/2021/11/NOIP2021%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day"><a href="#Day" class="headerlink" title="Day -?"></a>Day -?</h1><p>以约 $\frac{1}{2.7\times 10^4}$ 的概率在 B 站抽中了一个价值 $988$ 元的手办。</p>
<p>RP—（记住这要考）。</p>
<a id="more"></a>
<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>疯狂背板子（最后一个都没有用上）。</p>
<p>带了一点饮料和水，没带吃的。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>去了八十中，回想了去年在这里撞大运卡过 1= 线的经历，觉得今年不会这样了（flag）。</p>
<p>开考前监考老师不停提醒开始考试前不要写任何代码、最好不要使用 windows 系统（重点）。我配置了下 vscode，感觉电脑有点卡（此时还没有意识到问题的严重性）。</p>
<p>解压密码 <code>IronHeart@413A</code>？？盲猜是个游戏名。</p>
<hr>
<p>开始考试。过了眼题面。</p>
<ul>
<li>T1 第一眼口胡了个长得像欧拉筛的诡异筛法，个人感觉过不了。</li>
<li>T2 不会，不过一眼看出来一定是个 dp。</li>
<li>T3 目前不会，过会可以推推性质。</li>
<li>T4 肯定不会，但是暴力分非常简单而且有 $32$ 分的巨额分数。</li>
</ul>
<p>写了写 T1。写的时候电脑不停地卡顿，不过好在等个十几秒就能接着写。</p>
<p>写完了，花了半个小时左右。</p>
<p>编译编译。</p>
<p>虚拟机卡死了。</p>
<p>等了十几秒，没有好。</p>
<p>等了五分钟，没有好。</p>
<p>等了十分钟，没有好。</p>
<p>这时我意识到了这次卡顿的严重性（吗？），于是使用各种方法尝试强制重启虚拟机，又过了 5 分钟终于重启了。</p>
<p>重启了，经过了一些卡顿之后终于编译好了，然后测样例，然后测大样例，发现这个诡异筛法大样例跑得飞快，就扔了 T1。</p>
<p>打算登上程序回收系统交题。</p>
<p>？？？我虚拟机重启后网络连不上程序回收系统了？？？（出考场发现别的重启虚拟机的同学都没有这个问题）</p>
<p>然后举手叫监考老师（现在看来是极其错误的决定，当时要是直接出去用 windows 交就好了，可惜我还是秉承了不要用 windows 的原则）。监考老师认为我的“重启方式不对”，让我再按照他说的方法重启一次。</p>
<p>重启了一次，没用。</p>
<p>重启了两次，没用。监考老师还是不死心。</p>
<p>重启了三次，没用。监考老师只好让我先接着做，等他叫另一个老师过来。</p>
<p>这个插曲严重打乱了我的想题思路，后面也没想出什么本质性/突破性的东西了。</p>
<p>电脑之后一直是死机-重启-过一会继续死机的循环。</p>
<p>扔了 T2（打算过会写暴力），然后开始搞 T3。</p>
<p>在纸上推了推式子，写了一些情况，一开始没发现什么，只搞出了 $n=4$ 的做法。</p>
<p>后来又观察了下题面，发现了开局 $a_i$ 是单调不降的，我想到了差分。</p>
<p>于是又写了些情况，发现进行操作后，差分数组只是除了第一位其它都被打乱了顺序而已，元素本身是不变的。然后 $n!$ 暴力诞生了。</p>
<p>这时候，来了一位老师，他对我的虚拟机进行了很多次重启，对网络配置进行了一通操作，但是没有任何用处。过了十几分钟后他也死心了，让我看看能不能复制出 windows 系统交题，结果发现可以。早知道最开始不要找老师就好了，谁叫老师一开始不让用 windows。</p>
<p>我还觉得可以接着想 T3，于是尝试找差分数组的分配顺序有没有规律。</p>
<p>伴随卡顿与几次重启输出了一些中间变量，手造了一些样例，发现一定是一段递减然后一段递增。</p>
<p>于是 $n\log n\cdot 2^n$ 的暴力出现，具体就是枚举每个元素在递减段还是递增段出现。</p>
<p>然后就没看出什么性质，在极其卡顿的机器上写完了这个暴力。期望得分 $48$ 分。</p>
<p>这时来了个老师问我要不要延时，但是最多能延 $3\sim 5$ 分钟（理由是电脑卡顿、老师修电脑的时候我还可以想题，但实际上严重打乱了我的思维，对我的影响远超过 $3\sim 5$ 分钟）。我只好跟她说能延多少是多少吧。</p>
<p>写了 T2 暴力，没过大样例，调了一小会，重启了一次，结果发现时间就只剩下半个小时，不够写（很悬）T4 暴力了。心态逐渐爆炸。</p>
<p>时间就是这么快。</p>
<p>这时候又来了个老师，跟我说“特派员说北京最好不要延时，你这种最多延 $5$ 分钟造成不了什么大影响，所以还是算了吧。”然后我延时就没了。</p>
<p>最后 $20$ 分钟是折磨的 $20$ 分钟，我明明知道 T4 暴力摆在那里，多么好拿，但就是不能写，因为写了也写不完，在策略上不如去调 T2 暴力，最后也没调出来。</p>
<p>彻底去世了。</p>
<p>估分 $100+(0\sim 30)+48+0$。一等随缘。</p>
<p>考试结束之后，被这个电脑折磨透顶了的我充满这满腔的怒火，向旁边的同校同学使劲抱怨。同校同学们有的没被电脑坑，有的也被坑了但远远没我惨。回忆了一下，当时整个考场从始至终都是我举手找监考老师的声音。</p>
<p>初三了，接下来好好搞文化课吧，别连高中都考不上了。</p>
<hr>
<p>出考场，发了个 pyq。</p>
<p><img src="/pics/2.png" alt=""></p>
<p>本次的体验好比在中考考场上场场考试都流鼻血滴到答题纸上导致在写完一半题的情况下换答题纸。</p>
<p>并且写一句话就要换根笔，答题纸翻个面就要花两分钟（from sqrt_7）。</p>
<p>自闭了。</p>
<hr>
<p>出来看估分。</p>
<p>LG：$100+5+48+0=153$。</p>
<p>小图灵：$100+25+48+0=173$。</p>
<p>infoj：$100+0+48+0=148$。</p>
<p>死得透透。感谢八十中的电脑。</p>
<hr>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day ?"></a>Day ?</h1><p>出分了。</p>
<p>$100+5+48+0=153$。</p>
<p>小图灵估的一等分数线是 $162$。二等了。</p>
<hr>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day ??"></a>Day ??</h1><p>线比预料的低，一等线 $150$，卡线一等了。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S2 2021 游记</title>
    <url>/2021/10/CSP-S2-2021-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>一发过了个树剖板子，但是没什么用。</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>去北师大附实验了，带了一大瓶矿泉水、一罐可乐和两个手撕面包。</p>
<hr>
<p>进入考场，右边是同校高二神仙，rp++。</p>
<p>老师一开始敲错了解压密码。</p>
<p>看题！</p>
<ul>
<li>T1 感觉挺简单的，应该能随便搞出来。</li>
<li>T2 看起来不太会，数据范围像区间 dp。</li>
<li>T3 构造。我不会构造！</li>
<li>T4 smwy。</li>
</ul>
<p>先写 T1。本来想分别预处理国内和国外有多少个廊桥的时候分别能停多少飞机的，但是想了一种方法，假了。</p>
<p>于是误入歧途。</p>
<p>我感觉这是个单峰，于是写了个三分。</p>
<p>本来三分是过不了大样例的，但是我是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(r-l&gt;<span class="number">7</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">rep(i,l,r) ...</span><br></pre></td></tr></table></figure>
<p>然后就过了大样例，然后我就扔了 T1。</p>
<p>然后是 T2。看起来是个一眼区间 dp。按题意分类讨论即可。</p>
<p>写了 1h，没过样例 1。调了一会过了样例 1，又没过样例 2。发现自己 <code>ASBSC</code> 的情况数重了，于是加了一个 dp 数组。过了样例 2。</p>
<p>测第一个大样例…过了！看来我 A 了。</p>
<p>测第二个大样例…怎么挂了？？？？？</p>
<p>调了一会，调不过去。去写了个 C 的 28 分暴力然后接着调 B。</p>
<p>然后调啊调。到考试结束都没调出来。去世了。</p>
<p>一出考场，发现一个惊喜：T1 单峰是假的。然后接下来的一个晚上脑子里都是驼峰形状的函数。</p>
<p>T2 做法做复杂了。我处理 <code>ASB</code> 的时候使用了特别复杂的转移方法，很容易写挂（虽然我现在还不知道哪里写挂了）。事实上再加一个 dp 数组处理 <code>SB</code> 的情况就好了。</p>
<blockquote>
<p>I AM ASB.</p>
</blockquote>
<p>T3 听说就是个贪，血亏。</p>
<p>T4 最小割有很多分，没写，血亏。</p>
<p>这次把时间都砸在了 T2 上，结果 T1 和 T2 都挂了，后面的题看都没看，爆炸了，一等没了。</p>
<p>等 NOIP 有机会翻盘吧。</p>
<p>估分：$(0\sim 100)+(0\sim 100)+28+0=???$。</p>
<p>infoj：$40+70+28+0=138$。没脸见人了。</p>
<hr>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>洛谷：$40+50+28+0=118$。更没脸见人了。</p>
<p>自闭了。</p>
<p>Hydro：$45+50+28+0=123$。炸得稀烂。</p>
<hr>
<h1 id="Day"><a href="#Day" class="headerlink" title="Day ?"></a>Day ?</h1><p>调整了一下心态，然后 1h 杀穿了 CSP-S2 的前三题（T1、T2 知道正解，T3 是现想的）。</p>
<p>然后又自闭了。</p>
<hr>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day ??"></a>Day ??</h1><p>出分了。</p>
<p>$70+55+28+0=153$。</p>
<p>姑且能捞到多少分是多少分吧。1= 还是保住了，但考得很狼狈，已远远不是目标。</p>
<p>NOIP2021 RP++。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S1 2021 游记</title>
    <url>/2021/09/CSP-S1-2021-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>看了眼洛谷模拟的题，感觉挺难的，初赛应该“不会考这么难”。</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>第？次来到首师附。</p>
<hr>
<p>进考场，拿到试卷先通读了一遍：</p>
<ul>
<li>单选挺简单的</li>
<li>第一个阅读应该还可以，第二个没仔细看好像是两个分治，第三个是编码？？？</li>
<li>完形填空第一个挺最短路的，第二个直接四毛子？？？</li>
</ul>
<hr>
<p>开始答题了。</p>
<h2 id="单项选择"><a href="#单项选择" class="headerlink" title="单项选择"></a>单项选择</h2><p>第 $5$ 题：考场上降智了，选了 $4n-2$。</p>
<p>第 $7$ 题：为啥我之前记得我做过一道也是用“非连通”来坑人的题？这次没被坑。</p>
<p>第 $11$ 题：写出式子了之后先不停的乘了几下，然后发现直接费马小定理就好了…</p>
<p>第 $13$ 题：没用排列组合，写了个 $dp$ 式子手推了几项发现是 fib，最后减去全不选的一种方案刚好是 $54$ 种。</p>
<p>第 $15$ 题：观察发现是个 DAG，直接人脑 $dp$ 即可。</p>
<h2 id="阅读理解"><a href="#阅读理解" class="headerlink" title="阅读理解"></a>阅读理解</h2><h3 id="第-1-大题"><a href="#第-1-大题" class="headerlink" title="第 1 大题"></a>第 1 大题</h3><p>$r=\arccos 0.5=\frac{\pi}{3}$。</p>
<p>然后看见 $r\times 4$ 就知道和球体有关系了。</p>
<p>看了眼特判，发现是求球体体积交。</p>
<p>第 $16\sim 18$ 题都是和语言有关的题（考 int 和 double 类型倒来倒去），很水。</p>
<p>第 $19$ 题根据代码里的公式手算就行了。</p>
<p>第 $20$ 题发现是一个大球套小球，那更简单了直接算小球体积就行了。</p>
<p>第 $21$ 题直接选体积交。</p>
<p>这个大题还算简单。</p>
<h3 id="第-2-大题"><a href="#第-2-大题" class="headerlink" title="第 2 大题"></a>第 2 大题</h3><p><code>solve1</code> 里面那个结构体用 $h,j,m,w$ 这样的变量名导致我一开始没看懂，先去看 <code>solve2</code>。</p>
<p>然后发现 <code>solve2</code> 就是个 naive 的分治求最大子段和。主定理一下，是 $O(n\log n)$。</p>
<p>然后发现 <code>solve1</code> 干的是同样的事情，只不过变量名太阴间了… $h$ 是前缀 $\max$，$j$ 是总的 $\max$，$m$ 是后缀 $\max$，$w$ 是总和…</p>
<p>主定理一下，<code>solve1</code> 是 $O(n)$。</p>
<p>判断题挺水的，不说了。</p>
<p>单选第 $27$ 题我直接选了 $24$，然后就去世了。</p>
<p>后来发现我在做最后一道判断题的时候都发现了输入的第一个数是 $n$，到这里就忘记了…</p>
<h3 id="第-3-大题"><a href="#第-3-大题" class="headerlink" title="第 3 大题"></a>第 3 大题</h3><p>手算 base64 好评，明年来个 SHA256 吧。</p>
<p><code>int(char(0xff))</code> 又是什么？反正我看见 <code>0xff</code> 就选了 $255$。</p>
<p>另外赛后听说 <code>decode</code> 可能会出来换行符？？？</p>
<p>而且我 ASCII 记错了，$33$ 题算出来的是 <code>G</code>… 记错了还能算出来选项中的一个结果就离谱…</p>
<p>这什么垃圾题，差评了。</p>
<h2 id="完形填空"><a href="#完形填空" class="headerlink" title="完形填空"></a>完形填空</h2><h3 id="第-1-大题-1"><a href="#第-1-大题-1" class="headerlink" title="第 1 大题"></a>第 1 大题</h3><p>算完 base64 后逐渐暴躁。</p>
<p>揣摩了一下这个代码的意图，“连蒙带猜”最后全都选对了。</p>
<p>这题大概就是个魔改最短路，还算挺良心的。</p>
<h3 id="第-2-大题-1"><a href="#第-2-大题-1" class="headerlink" title="第 2 大题"></a>第 2 大题</h3><p>CCF 手把手教你四毛子。</p>
<p>开始做这道题的时候只剩半个小时了，很慌。</p>
<p>笛卡尔树：后悔之前没学这玩意了。不过根据 CCF 告诉我们的它的性质我硬生生口胡出来了建树过程。第一空第二空选对了。</p>
<p>LCA 转欧拉序 RMQ：这个之前学过，所以知道第三空应该选深度。</p>
<p>然后后面的三道题…连蒙带猜（这回是真的连蒙带猜）只对了一个。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次初赛难度跟洛谷的模拟比丝毫不逊色。</p>
<p>估分 $80\sim 83$，去世了。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 年 8 月水题选做</title>
    <url>/2021/08/2021-%E5%B9%B4-8-%E6%9C%88%E6%B0%B4%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<p>决定重新开坑这个系列。</p>
<p>然而马上就初三了估计只有 8 月份的了。</p>
<a id="more"></a>
<h1 id="8-11"><a href="#8-11" class="headerlink" title="8/11"></a>8/11</h1><p><a href="https://www.luogu.com.cn/problem/AT4512" target="_blank" rel="noopener">$\color{green}{\text{AT4512}}$</a></p>
<p>好神仙的构造题…</p>
<p>首先有一种 naive 解是第 $i$ 行全都填 $i$。</p>
<p>但是这样只能做 $k\le 500$ 的情况。</p>
<p>考虑换一种新解。</p>
<script type="math/tex; mode=display">
\begin{matrix}
1&2&3&4&5\\
2&3&4&5&1\\
3&4&5&1&2\\
4&5&1&2&3\\
5&1&2&3&4\\
\end{matrix}</script><p>看起来还是只能做 $k\le 500$ 的情况。但是这个解法可以拓展。</p>
<p>观察到对于每一个数，其周围一定是两个 $a$ 和两个 $b$，而且这两个 $a$ 的行奇偶性一定不一样，这两个 $b$ 的行奇偶性也不一样。</p>
<p>那么就可以把这种解的其中一个数的奇数行的位置都换成一个新数。</p>
<p>换任意个数都可以。</p>
<p>例如</p>
<script type="math/tex; mode=display">
\begin{matrix}
6&7&8&9&10\\
2&3&4&5&1\\
8&9&10&6&7\\
4&5&1&2&3\\
10&6&7&8&9\\
\end{matrix}</script><p>这样的话就可以做 $k\le 1000$ 的情况了。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1364D" target="_blank" rel="noopener">$\color{green}{\text{CF1364D}}$</a></p>
<p>首先考虑一棵树的情况。显然树上不存在环，然后我们可以将树按照深度奇偶性染色，每一种颜色的构成一个独立集。从大的里面选 $\left\lceil\frac{k}{2}\right\rceil$ 个就可以了。</p>
<p>变成了一个图，我们可以类似地先搜出一个生成树。如果存在一条非树边连接的两个点深度之差 $&lt;k$ 的话那么显然可以找出一个大小不超过 $k$ 的环。</p>
<p>否则，在树上有非树边连接的两点之间在树上的距离一定是 $\ge k$ 的。那么我们从任意一个深度 $&gt;k$ 的点出发，往上跳，隔一个选一个，选出一个大小为 $\left\lceil\frac{k}{2}\right\rceil$ 的独立集即可。这样可以保证选出的点中一定没有非树边连接。</p>
<h1 id="8-13"><a href="#8-13" class="headerlink" title="8/13"></a>8/13</h1><p><a href="https://www.luogu.com.cn/problem/P1935" target="_blank" rel="noopener">$\color{green}{\text{P1935}}$</a></p>
<p>发现这道题是与周围类型不同的时候有额外收益。如果是相同的话那就很好办，不同怎么做呢？</p>
<p>将格子黑白染色，黑格子反着连边，这样就可以转化为相同了。</p>
<h1 id="8-14"><a href="#8-14" class="headerlink" title="8/14"></a>8/14</h1><p><a href="https://www.luogu.com.cn/problem/P3195" target="_blank" rel="noopener">$\color{green}{\text{P3195}}$</a></p>
<p>决策单调性优化 dp 的经典板子题，二分+队列维护即可。</p>
<h1 id="8-15"><a href="#8-15" class="headerlink" title="8/15"></a>8/15</h1><p><a href="https://www.luogu.com.cn/problem/P3809" target="_blank" rel="noopener">$\color{green}{\text{P3809}}$</a></p>
<p>终于学会 SA 了。。。</p>
<p>之前一直不懂板子的代码，现在算是搞懂了（但是难背死了）。</p>
<p><a href="https://www.luogu.com.cn/problem/P2408" target="_blank" rel="noopener">$\color{green}{\text{P2408}}$</a></p>
<p>SA 最简单的应用之一。使用 height 数组直接求解即可。</p>
<p><a href="https://www.luogu.com.cn/problem/P4555" target="_blank" rel="noopener">$\color{green}{\text{P4555}}$</a></p>
<p>manacher 的简单应用。对于每个 <code>#</code> 存一下它向左的最长回文串和向右的最长回文串。</p>
<p>具体来说，先用 manacher 处理出每个 <code>#</code> 能扩展的最长的极大回文子串，然后扫一遍更新即可。</p>
<h1 id="8-16"><a href="#8-16" class="headerlink" title="8/16"></a>8/16</h1><p><a href="https://www.luogu.com.cn/problem/P5495" target="_blank" rel="noopener">$\color{green}{\text{P5495}}$</a></p>
<p>莫反前置知识。从枚举约数优化到枚举素数，然后做高维前缀和。</p>
<h1 id="8-17"><a href="#8-17" class="headerlink" title="8/17"></a>8/17</h1><p><del>今天是虵滴生日</del></p>
<p><a href="https://www.luogu.com.cn/problem/P3803" target="_blank" rel="noopener">$\color{green}{\text{P3803}}$</a></p>
<p>学了一发 FFT。</p>
<p><a href="https://www.luogu.com.cn/problem/P3701" target="_blank" rel="noopener">$\color{green}{\text{P3701}}$</a></p>
<p>由于某些原因，在今天（8.17，蛏蜒节）写这道题。</p>
<p>这道题显然是一道最大流，考虑如何建图。</p>
<p>观察到寿命即为一个人可以用的次数，于是我们从 s 向 byx 的人连他们寿命的边，注意长者需要 +1s，于是需要把膜法师的人数续进命里。类似地从诗乃的人向 t 连类似的边。</p>
<p>然后考虑两边人之间比赛的连边情况，可以枚举一波然后如果 byx 的这个人可以赢诗乃的这个人，从 byx 的人向诗乃的人连 1 边，表示这个人可以用 1 个寿命获得一个赢的次数。</p>
<p>然后跑最大流就完了。注意只有 $m$ 场比赛，所以要特判一下答案 $&gt;m$ 的情况。</p>
<p>代码：<a href="https://paste.ubuntu.com/p/mCV5rkhxj2/" target="_blank" rel="noopener">戳我</a></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>atcoder</tag>
        <tag>luogu</tag>
        <tag>题解</tag>
        <tag>水题选做</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1174E Ehab and the Expected GCD Problem</title>
    <url>/2021/06/%E9%A2%98%E8%A7%A3-CF1174E-Ehab-and-the-Expected-GCD-Problem/</url>
    <content><![CDATA[<p>毒瘤 dp 题。</p>
<p>首先显然可以莽一波结论。</p>
<a id="more"></a>
<p>可以发现，当排列的第一个数 $a_1=\prod p_i^{c_i},p_i\ \text{is prime}$ 时，题目中所求排列的权值最大值为 $\sum c_i$。</p>
<p>这是因为在第二个数及以后，前缀 $\gcd$ 只会减小，不会增加，而且最好的情况是每次减小一个质因子。可以证明只要有一个确定的第一个数，该最好情况一定可以实现。</p>
<p>那么我们可以考虑找出使 $\sum c_i$ 最大的一个数 $a_1$。</p>
<p>再来猜一波：这个 $a_1$ 的可能性不会太多，它的质因子得小。因为如果有比较大的质因子的话，它的指数 $c_i$ 就会被压榨，会比质因子更小的情况劣。</p>
<p>那么质因子得有多小呢？我们先猜：这个 $a_1=2^x$。</p>
<p>这种情况确实很优，但不久后我们还会发现，$2^x\cdot 3^y$ 似乎也很可以。</p>
<p>但是到 $2^x\cdot 3^2$ 之后就爆炸了，因为有一个比它小但质因数分解后的指数和比它大的数 $2^{x+3}$。</p>
<p>因此，质因子 $3$ 的次数不能大于 $1$。</p>
<p>那么能不能有比 $3$ 大的质因子呢？显然不能。因为 $5&gt;2^2$，用了 $5$ 及以上的不如用一堆 $2$ 来代替。</p>
<p>那么我们可以得出结论：$a_1$ 只能等于 $2$ 的若干次方，或者 $2$ 的若干次方乘上 $3$。</p>
<p>那么就可以愉快设 dp 状态了：令 $f_{i,j,k}$ 表示到了该排列的第 $i$ 个数，当前前缀 $\gcd=2^j\cdot 3^k$ 时，有多少种情况。</p>
<p>转移可以分三类讨论：</p>
<ul>
<li>若加入一个数后 $\gcd$ 不变，那么 $f_{i+1,j,k}$ 需要加上 $f_{i,j,k}\cdot\left(\left\lfloor\frac{n}{2^j\cdot 3^k}\right\rfloor-i\right)$。因为 $\gcd$ 不变，那么加入的数一定是当前 $\gcd$ 的倍数，需要注意前面的所有数一定都是当前 $\gcd$ 的倍数，不可以选已经选过的数，于是情况数需要 $-i$。</li>
<li>若加入一个数后 $\gcd$ 变少了 $2$ 倍，那么 $f_{i+1,j-1,k}$ 需要加上 $f_{i,j,k}\cdot\left(\left\lfloor\frac{n}{2^{j-1}\cdot 3^k}\right\rfloor-\left\lfloor\frac{n}{2^{j}\cdot 3^k}\right\rfloor\right)$。由于 $\gcd$ 变少两倍，那么新加入的数一定得是 $\frac{\gcd}{2}$ 的倍数，但它不能是 $\gcd$ 本身的倍数，因为这样的话 $\gcd$ 就不会改变了。而在 $\frac{\gcd}{2}$ 的倍数和 $\gcd$ 本身的倍数中，都考虑了一遍已经加入过的数，抵消掉了，因此不会加入重复的数。</li>
<li>若加入一个数后 $\gcd$ 变少 $3$ 被，那么 $f_{i+1,j,k-1}$ 需要加上 $f_{i,j,k}\cdot\left(\left\lfloor\frac{n}{2^{j}\cdot 3^{k-1}}\right\rfloor-\left\lfloor\frac{n}{2^{j}\cdot 3^k}\right\rfloor\right)$。由于 $\gcd$ 变少两倍，那么新加入的数一定得是 $\frac{\gcd}{3}$ 的倍数，但它不能是 $\gcd$ 本身的倍数。类似地，在 $\frac{\gcd}{3}$ 的倍数和 $\gcd$ 本身的倍数中，也抵消掉了重复的数。因此这么干是对的。</li>
</ul>
<p>代码实现上因为 $3$ 只有可能是 $0$ 次方或 $1$ 次方，可以用三目运算符判断更加方便。</p>
<p>PS：这题十分卡常，还卡 <code>long long</code> 数组（如果 <code>dp</code> 数组用 <code>long long</code> 的话会炸）的空间。我是用火车头 $+$ C++17 才过的（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码就不放火车头了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1000005</span>][<span class="number">21</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qaq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;x)*(y?<span class="number">3</span>:<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> hav3=log2(n/<span class="number">3</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nhav3=log2(n);</span><br><span class="line">    dp[<span class="number">1</span>][nhav3][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(hav3==nhav3) dp[<span class="number">1</span>][nhav3<span class="number">-1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">        rep(j,<span class="number">0</span>,nhav3) &#123;</span><br><span class="line">            rep(k,<span class="number">0</span>,<span class="number">1</span>) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j][k]=<span class="number">1l</span>l*(<span class="number">1l</span>l*dp[i+<span class="number">1</span>][j][k]+dp[i][j][k]*(<span class="number">1l</span>l*n/qaq(j,k)%mod-i+mod)%mod+mod)%mod;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>) dp[i+<span class="number">1</span>][j<span class="number">-1</span>][k]=<span class="number">1l</span>l*(<span class="number">1l</span>l*dp[i+<span class="number">1</span>][j<span class="number">-1</span>][k]+dp[i][j][k]*(<span class="number">1l</span>l*n/qaq(j<span class="number">-1</span>,k)%mod-n/qaq(j,k)%mod)%mod+mod)%mod;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;<span class="number">0</span>) dp[i+<span class="number">1</span>][j][k<span class="number">-1</span>]=<span class="number">1l</span>l*(<span class="number">1l</span>l*dp[i+<span class="number">1</span>][j][k<span class="number">-1</span>]+dp[i][j][k]*(<span class="number">1l</span>l*n/qaq(j,k<span class="number">-1</span>)%mod-n/qaq(j,k)%mod)%mod+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈整除分块</title>
    <url>/2021/06/%E6%B5%85%E8%B0%88%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>今天研究了下这玩意，查了几篇 blog，感觉脑子里乱七八糟的，于是自己写篇 blog 尝试总结一下。</p>
<p>前面的几个例子摘自<a href="https://blog.csdn.net/weixin_43627118/article/details/104024380" target="_blank" rel="noopener">这里</a>，但是式子是自己手推的。</p>
<a id="more"></a>
<h1 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h1><h2 id="整除分块能干啥？"><a href="#整除分块能干啥？" class="headerlink" title="整除分块能干啥？"></a>整除分块能干啥？</h2><p>考虑形如 $\sum_{i=1}^{n} \left\lfloor\frac{n}{i}\right\rfloor$ 这样的式子。</p>
<ul>
<li>我会 $O(n)$！</li>
</ul>
<p>但是，使用整除分块能让计算这个东西的速度提升至 $O(\sqrt{n})$。</p>
<p>考虑 $n=10$ 的情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$i$</th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$2$</th>
<th style="text-align:center">$3$</th>
<th style="text-align:center">$4$</th>
<th style="text-align:center">$5$</th>
<th style="text-align:center">$6$</th>
<th style="text-align:center">$7$</th>
<th style="text-align:center">$8$</th>
<th style="text-align:center">$9$</th>
<th style="text-align:center">$10$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\left\lfloor\frac{n}{i}\right\rfloor$</td>
<td style="text-align:center">$10$</td>
<td style="text-align:center">$5$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
</tr>
</tbody>
</table>
</div>
<p>诶，怎么有这么多重复的 $\left\lfloor\frac{n}{i}\right\rfloor$？</p>
<p>事实上，随着 $i$ 的增长，这种重复项会越来越多。</p>
<p>于是我们只需要快速统计每种项出现了几次即可。</p>
<p>我们对于每个 $\left\lfloor\frac{n}{i}\right\rfloor$ 重复的段分开考虑。</p>
<p>$n=10$ 的情况中，这些段分别是 $[1,1],[2,2],[3,3],[4,5],[6,10]$。</p>
<p>我们可以扫一遍这个段的左端点，然后通过某种神奇方式快速知道这个段的右端点，扫下一个段的时候直接将左端点赋值为这个段的右端点 $+1$ 即可。</p>
<p>那么怎么知道左端点为 $l$ 的区间的右端点 $r$ 是什么呢？</p>
<p>根据我们定义的这种区间的性质：</p>
<script type="math/tex; mode=display">\forall i\in[l,r],\left\lfloor\frac{n}{i}\right\rfloor=\left\lfloor\frac{n}{l}\right\rfloor</script><p>也就是说，$r$ 是最大的使 $\left\lfloor\frac{n}{i}\right\rfloor=\left\lfloor\frac{n}{l}\right\rfloor$ 的数 $i$，即</p>
<script type="math/tex; mode=display">r=\max\left\{i,\left\lfloor\frac{n}{i}\right\rfloor=\left\lfloor\frac{n}{l}\right\rfloor\right\}</script><p>因此</p>
<script type="math/tex; mode=display">r=\left\lfloor\frac{n}{\left\lfloor\frac{n}{l}\right\rfloor}\right\rfloor</script><p>（这个可以手玩几组样例试试）</p>
<p>也就是说，我们知道 $l$ 之后就能快速知道对应的 $r$ 进行求解。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    ans+=(r-l+<span class="number">1</span>)*(n/l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们考虑更加一般性的问题，例如求</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}\left\lfloor\frac{n}{ai+b}\right\rfloor</script><p>其中 $n,a,b$ 为给定常数。</p>
<p>我们还是按照老套路，考虑枚举一个 $l$，快速求解满足 $\left\lfloor\frac{n}{ai+b}\right\rfloor=\left\lfloor\frac{n}{al+b}\right\rfloor$ 的最大的 $i$，即为 $r$。</p>
<p>这个 $r$ 怎么求呢？</p>
<p>根据上一个例子，我们有</p>
<script type="math/tex; mode=display">ar+b=\left\lfloor\frac{n}{\left\lfloor\frac{n}{al+b}\right\rfloor}\right\rfloor</script><p>因此</p>
<script type="math/tex; mode=display">r=\left\lfloor\frac{\left\lfloor\frac{n}{\left\lfloor\frac{n}{al+b}\right\rfloor}\right\rfloor-b}{a}\right\rfloor</script><p>再考虑一个问题，求</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}\left\lfloor\frac{n}{i^2}\right\rfloor</script><p>那么知道 $l$ 的情况下，可以得出</p>
<script type="math/tex; mode=display">r^2=\left\lfloor\frac{n}{\left\lfloor\frac{n}{l^2}\right\rfloor}\right\rfloor</script><p>因此，</p>
<script type="math/tex; mode=display">r=\left\lfloor\sqrt{\left\lfloor\frac{n}{\left\lfloor\frac{n}{l^2}\right\rfloor}\right\rfloor}\right\rfloor</script><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="CQOI2007-余数求和"><a href="#CQOI2007-余数求和" class="headerlink" title="[CQOI2007] 余数求和"></a>[CQOI2007] 余数求和</h3><p>先放一个 <a href="https://www.luogu.com.cn/problem/P2261" target="_blank" rel="noopener">link</a>。</p>
<script type="math/tex; mode=display">
\begin{aligned}
  G(n,k) &=\sum_{i=1}^{n}k\bmod i \\
    &= \sum_{i=1}^{n}(k-i\left\lfloor\frac{k}{i}\right\rfloor)\\
    &= nk-\sum_{i=1}^{n}i\left\lfloor\frac{k}{i}\right\rfloor
\end{aligned}</script><p>因此，我们只需求</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}i\left\lfloor\frac{k}{i}\right\rfloor</script><p>简单推一推，对于区间 $[l,r]$，答案是</p>
<script type="math/tex; mode=display">\left\lfloor\frac{k}{l}\right\rfloor\cdot \frac{(l+r)(r-l+1)}{2}</script><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=n*k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k/l) r=min(k/(k/l),n);</span><br><span class="line">    <span class="keyword">else</span> r=n;</span><br><span class="line">    ans-=(l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>*(k/l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，需要注意的细节有</p>
<ul>
<li>$k$ 值可能 $&lt;n$，故可能存在有一个区间答案为 $0$ 的情况。</li>
<li>计算出的 $r$ 值可能 $&gt;n$，故需要与 $n$ 取 $\min$。</li>
</ul>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>5月20日校内模拟赛题解</title>
    <url>/2021/05/5%E6%9C%8820%E6%97%A5%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="36dea281f7291c9fb6fffc7eb7a69d650282e350c8b1995a0a87e7aa3fed651b">391410d5f1b582dbf2b6303298a6cd372863f6851327fd4b3880f1614c568258f3cb5ac72dec97e8c31abbdc5e4948d29bdf37f265f9b73434e4dbf74c9800085a364227012ad8a119c021a1eed2efecb53d321874ad970d6e907de0e6caf9374918d4ee1dcc3ca2f71f6edb00df692aee16ffdbd3df7cfc716cfbf814f41de3203558f0bdbf5e2062846ea3db99a42333de86b3f86d182a1e6521fd8392852e0956e7c77cdc77b9bd99144221bca71bd459b9a8088241a2dc9b13bd54d6695c3a8c5c7ed9615f0aa24afa1a16ee76c627540354fc8c21391c60c6d4f859bf5df2a1319d57cf57d020847174fc9c58db0b61e598f92d3c1c10f47c43c4fd8d8c8c3c89e6956e6156432425c10153bdaf92683c21a4e3d70758ac6f87e8c0ed70df8b17ca881e48c2bf80f3faf34a6878aac10d370ba76af728a10d8d0a00ad08a584be4eb28d0b14a613ecdd064455c1b0e9ad340319914a9e561d57a74af0e5c8aa8b634461236cd461dab0b8d04d92a1563e2b317ab2b8b6edb39f9ce7c3956f8a43c3acd355d7b082a07def47c305bec1c02c0504d79300816dc8a225ed8ac000bbf3cec8b75d0a15b7217544e5ad1de4b6a53d2ea8d72832eb51b9e24b99055a0a2ba31b483c0293933ed2af2e11cd1889158be255c0f631e987edbc99d04ae5c14d16337aaaead18735064c0cb140ac4077c62057b9cf31e90e94501ff8e6e9a9d4f75abd143e28cfd607a0b694cc14b5e119ce930a68a59dbd842b5a0419da412efbc8f4daf5f6162e3d6aa7e9baee35b327aefa8cbefacf26d0c368912dc85c77ac6d53e569736d11c1f97e1fae878890c57678b1bc55222dd253909a33377b1f025b0bad240b90bb118af93475a88a6bc42ddf9aac06fc96a96f7bef1e5bad5c2060cacb5425fe7965a7ceebc85245592ef2f93b61ecdaafe87c4b807944f6478c127e0a4eb5e6ad239ac6b4586d9384f476bbdac409fa556c7782d8974a4fa82962334a35663d6f6d7c0acacb02a6cffb45c0ec477ccec28825317c15f68be3e67c33beffa64a100c1a05ded7df6ba5918c9ff4c9b767397ee49925402c4b36f47fce3062a695df9793ee0f8be3cafd7de43ead6b5fc9d988e25e37de308a802a73e1649534daa8845aa074935cb2648fccc991e0ff75e5faab96f936595d753c6398f62f57bbc07f7b494c6af0aa7e2ab1080401ad65b49b5a5797636bc398ee315ecaaaed878c3f9d7a13e4eb1d07763afd2cfab4313ae9588c04079a5e13a9d67a09d3861db297803d1fca972924d7cf0966da4eaa0b362e1c500b258b9b29d63e149c46d5e2921b6b9befb248640243555888c29b34b4a45389b8342d3eb8cf9164e1104ecc1841979145d441295f74f69db2a96d349681b8f88d404e65f1757f9f3de0cbe30416d490a8cddfc6974eef760b20c9134c7e2e940428000283bf0cf5337fd386c5435c02167bfb2517e8c1b1b948d21aee84837bdcfbd428129f0a1c9b55f2c740c9785ac89ece9ed7e432c67285957bd0a5379d8544d3cc4d5aa1252e9699d8032d02144c4fc54e2864a94ac8de3f9696e8a4aa1cda3d08d09a9581910549b369fc3e0716bb1a36224b0cfde2c4fc20488b86fdd09222741ee6d10da11df4c6d366dd6c30f3eb53c1d978878ef7ba14b8db9ffa67f9005ddcf39eb9125ba553b5e139e2a69bcb8e795ffb939f89e16f7358012b092661e8415f88f68761af2bb152bca2d369fcf2084a79b0148245af33f29395b68289753088bdd355933936cf3a8b01d068be517fbd833addcb09a6619f4e1f7a6978bb12e493b32c91b0ea6bd25591b147c259b5ae801cef050b7628fef72b6f766cc0a04034d2c1c48b0a0f8c99149dc147ca467dc7b582cf94d16584504983ac6a1ce52d8c0ebe6912f2874920a88b7ff2aea36b610b48f3773243b7a23b16197a4e067ea4fb1dcd3006b0a4f648236a10f6b6da083b0af66cc809b82638f957000c814b251903bbe3d263710cd87abc2115ce10001c2820fc4d88df7a5ae9c7dd09598e764a9a569126198c159368b2d29e00ceacb905f001c35ee643b127a8d803691358e9cef56a227c91f10e0e3e30e1e423440722aa38538efac73974a68b8bc72bc65434f98b99422a2d057f1da7ead5aeb6a33f9d4fd33ce3c984142b2b926f127c71e788d18df317d7432a88602c47784fe2fdb595317c99f186282408837621cc5f25adc899ff3190a65e2187b5a91ea7a85a536a003fb12676d8fb82bcb13284e3165c57baba9befb172073dde591a37d49399ae3948a1141555d02707fc80d74b5897edef24a18477633ef8e3f9abac9ce1235c0766427c5e6d537cf75d8825f66e9ca2a2f5c58fdcfca6e12d550f5d58605bf80c0818976b87f9721eb2c226a839572c56378fabe6c4715dc5054325f11ba537c0fc1cde141e638a7945f8d1c3c44a82bc5477b7a73ef393139ad2f32bf36645e0f553905e11e19f60731e0698cf6ee1b90b7e0e555c0b7bef1ac77e94331208630da8bd6eca23cdc029389ccc1e8a17b314acbb3b2983cfdae1616bdaac2a23a034119d57fbec0abeb153c6887fb922214a1de6e3759908fe7aed4ba38bfe1e76f1979f3054ebae608b7f21fa521e43e8f6edb616d6aeaf530d6559a2fe4baee8afadae19dd16db5b8e35d25b30ce1dcd8e16cbb4cfdc3b8cb3e622ee852b1df9ff1c7a85da482498c6e1433bb0179cae54599426b54b74712ba7120c54df6596e3363957d1f21c031d84ccd26e42ed88ac33f3d28505c18b11177588c68290fcc9da8f21b63ac6c846299adb79a4ff8006c2c5f5dad870dad2163762f4acf66e16f4eda253cb6f284484fd751765d9949802a5455b0df414b1720b1b1bfdfc4d266a92063ba81a357d9d62d0539c6234c9e0759743ba3eb356d520a3c44d1dc5a0719f7acc265584011ebf76c9c5c71a610a9abf8d4bf0d78a45fc01f2567e5d1769a39c9b08b129a0089857c8795515971d2d482f4ebf9a1a56d4bc49c43d417d27843629af2d0471423bdbcf34cbcc3bce9f4be0d2062b91b45f7c9b243d0e4b70ceb94d911e3d4a423aec85fe16c128e4471908b04166e97c99daf6f476245b074c5fe8fc8a284f44bd7fdf98fce5baf637e9a752dce62c9191a3ada21acd5cb1da5c87ee6020e2a7fb4db76ba211a0fce2f9b6861b94bb4f2c526a40bf1cd69a387bb5d843197f36f4ee55944f3c470d37d5ad861e6c083abe5b5934832a24cfc07f47a3434bb998ba9af6dce1a45a1f75d52a5295d30a8d9b179f915d5d34a01e4cb73a151031a0cdeb0acab7b93f02568601c92be13b0f89b3aa7f5135c8c54b3ca463bf772ad0e6aaf2b9edceb2e0d35db3978818c6de7d938edb0e89fe8e1ac384c5223c5814e4abf98ef343cab7ffd4b5441bfeeada39c00ebe8ed7300a0933ffb0e5d196a0c4e5fb47ef83203aa980c0b994553d3fa777d468d4aebacb295a7e0bbc2083d239a0ee40d17f851de6af7041cbe07d96f1a30d4df766c77a2b1de3426d6a334ff5861927091b2733035dbc75221fd1547cf0e3754432d6e666dfea0056bbe519dfcf35160c075245f33343f7004275898a19a35fe17dee6faf4b0464f840844decd90c9851dccb253f47832a7fdbdeab0c0f63f0d368024c29ce415040fcfa43460a14244848e16489383afa45540ec9544475fb5c13d8e9ef523d65f3eb1a9e3bae1a5f78d227f52d45bdfc3d43cc4a39c1e7e956a87c9e09789ee932d5c65bb9444bdba472a418b0f114a7cefa23d9b4e153d8173f554ca2c160348861bea0845903c52755cb369d404cf34849baf5240518f57b57342bcf3cf3eb2f80196516623df6da896c3c118d1e1c389eeb084ec1c6ade2f6cd0b3888badad0da6bf864ec1e9d78028cdcd09ac5491e20fe360e9bbc485acc962142ecb4e765f964c85bb4483d2cd83124dc7fbfd00506b11c9d31d653f9785af14f61d85bd033b15a78ae1219b68207c1352cc96f83387a969a767f60b5cee41fa409f70cb960a2faaf67e1fe0e8e09f2db86ce5c1f50b22769877aa6c21de57031f7e476dfa2174ea482dd02688149054927bfe8a4516b9c689b3a1a2b7642331841fe144506031ca26aefc91de735b57c9ec822659625a50fb4f04de91c48461436815af9d0b6b5109cc4bbaeca21f2f206d70e809d0525fd615dcafd909e270b6bdc165f3ce775092db3ef18a68281fcc9f378469cd0f85d37f51509f828a24ead8f24e8e97adee2ed66de71f547fc885ad402b7ae38826440048b456de67c877b0abb9e553c5a751f9fc4c57c10a224007e15fbbcd5cab09f28aa291b7dce1bc21c2ff907fde9966750fa37cc7a8ccae3ed41ff1de3f80f5dbcc0a6103c70cfa99c2f1f210ea534f65782372fa04749d1240fca639ed102e6fb4bf51d4a49b9f106dce3738025107e36ea716698c76b57781ba7c4bb3bade2709f9caf01ed9a1d31ceec5783f324823088bafc51e16e73b190f37ccd7f7d32a715e594a239af87a97ad2f63bdab33d8cbb504452f4a1f13b133a4e2c6ccddafa5c42cba83ff300f1418cd39e116f55314e725c9748156cb9ebede220c213d67afd1d863490978fc690da0f4a513c09057b430d50365088c0c59c723739361d212a66f2a986ca59ca1e43c2ada8e85f9b208cc99301233d4c239157b1c2dcbe6cad04dcc25fac37bdaa3968be5fde073aa18be97f0337138bb7809acfd31abd4f6d89148ca36e97d7a48c66761df9abf6f86c74feb55ce9e6404b2c523b18d8f34de4814306cb0de89b51ad6ba04f636915cd3d9b6b2752fc3b309877f7cc00ff8fd9f87715ff2746566ff5bbd09eff9c46949164b462e23a368674e90dabe3e0a215ed30b5919265486feffe7cc9e07053da25919d5ddbb80427632473d4e5e9b0f1f05c28f2487f10562f185a214b95fe1a0de5faf9003d91508ef77c506ba372c5a147071fd5ec2ae742e5581a22785e884e1e2c515f1a26060044673a4d9a90f6366ef4cd27e89cbdace1d8d88d4327edda1c86d6c74c3793f7fdfbb6aebcf20692c7a4160c8356b4aee05c04816be27e979ad99d54656fc9d25469a14f97a6c6dc502cd55ea4a2498e32d67a42cbb0af88d724ae75070947de09059b601b270b76c293cd5e371d401874e3e4a2c01a605fab7bf577e4d1034ac20b574a4fa490ce46e1a6d3c5270bdddf35fef6202c6cf3d4ec6c04f913a552c3ec25c474233ebc566c7944c3d99662c50b914ebf56f118552804d1fd5f05728eb158922dea7bec4285295cce78e7986d7b5957122713063d60ae14f86f31d35d3daefd37cbf597052ce778b46c88af6d53905da03a9d73fc99f2dcde12427093caa47b727f1d6c4d1672c939fc1ffbc594fd9a3fe673dff9da92cd6f2d9057ee0b374531037e182133857baf9871106fd27c2aea83852d293919e1ba8c22492b5299d12efb393032db5f832dcedd4352051ca2f40f90b3232e7adfccd0c7b2bfd5c6edd220b9a2a65ed0245f866a6c5f10e929cfe37b376c2db26f7d38995b5f89122fe2ded300931c79d68bf37d6c0e942fb760708c1e33dd797e07507dcbef1603df4c0c609afb1d8cceb3c32903259574473d0475c47a2962a4e5e1ffc678a3467dc56d759e1de7d6b67b4ad16ed730c5bdb2def66a4ee45fce2eaf80e386ef92a55c097c1499cf75f2f302a5958360e4c79364890576d97cb4d49730ef9fb9dfb1d58dee5cee8438bd191cfe65a4823b76f059b001fca3168222d6050d63795c95cfec6c58b4418dac2678a3b1fa0cfd3d4543a53401a5ce6914fe7564a5fb0c4ad815ff5ec3528dbff4878c33a526d967c0b43418342b2dfd268264ec436c96d81f3d80a2c5f03b5a744c6a3cc541ab2ddd278f972bb1db1306f9cc27adf3210d1fe8b3f0686b158672e7b7e8dcc67ebf458e3c05f63a63abe0f8e35a0ebe34e4b873d8469f097e247fded7ae4fa35791f0aa4bd55ea287cc2154bb13fcccd0e507af3007c8764baed11e8b3fdcbfce2d0ba2f1e2a24b1f96747d649e3a4e31a1f68f0ab16bffbc89d3ac991d1c7dd2efb6f9de7422ad5f65161d76a585a13d56f79f8e8ab1c6f3ffe6f8bc4d34afddc84cdd6bc076f3721e32b656f4f987461c206a184100194a62f2afffeb30b962fa5661c93fc3a66714416aa08190d56730ad0bca0761d80be44f9ac33370da6fd257ee9c4e56dba14716f8059d2341e085abdf324b0138e6b6a0032dc1dc07ea480eff2d7b00a1803aea43e6525d4acbe64c0eab7aa1c018c29edb024da3daee08a4d0173a4b878e42692aea9a88c3a004f8e87cbefb9378172b56a1dfe3737e34d3f893e4a289a18db8c13ce5255448cfab4f6a65c9d9ac327bc5dc865867f1b33dd01ffdc59f5eca5bf2051822db80535538235d6bc74425d438f1c6277b34709e2185fa4d64d1b6fd5791c78e321864de3311ffeac3df49bae8b32e08553a171f169cbc2e39974bac8619636827b9bfac630c26a086815db73d19d8aa50b6235e5062e0db0e7bf28bb19677ebb3969098593fc4bca6b0a1c2c9c58e7f7c3b001070c3f2bc0509d3b15f3f7098ca08493cada61c7dc2b3eff8a69369cc35113179ad7437ce83fa94fcb27c82d0318e90f65441b99044250d3f5dd2a533c0906e5c79a0dde05c53235e2a2b932abbc47db60ec3926a534e09d40168d47e8c3558eb0a5459aeac5f0363b6c2a4e19ba3d5df232201b2c99b10012488f7620efff1b9d222264dc26875a328cd8fdbf704e43e891f5a1b0537d8f511ae0c8b8468c2a2f0ee79a949479c45a1006a22966d2469eb93dfae98dd5f42d9601e62d92de25e9945ce41c4a9d3e877d2fe06279ad48bb6befeda101621d49d5aab9ca29867892e8a40d31efb37425c592ef32d090d72479ff2b97b6b1c17005defe4022ad44873a4a1fa578349bed6b2ccb4182dc075c26ad6b7828130967f96410a9f431e248112959ec9bf985422b1868d132de49ae7af31f839c1ecb2ca148e68b8162829bad50cebf4f3e183d1d4064da83797406b4b62ba6e444fecd1a2690f72ed17fce8880a4626adbf3313ecc6845c065ec787b3f02eac1c87ef393980c8316667760d07bbd7be57d0d364fcd1774445988cb775f77448394d7d2b9b3b0785c8f48ab7a2a0c2cdf752a02b278f576704e801d58c905c04823125e876249cc6a9b33b7a1d3d673bd37bd9ffcaee043d6c5dacbd633c8d600e73b9ffe79f2e8e1fe6fc69d7cc175099944917a9672343ee0e0f82ef3403440c7675b9a1920bc40ea7ce8de8dd6ba6e9b3f718d0412bdc072ac957ed14371d05f9f996c98a870d4a0e37ed66dd477c70995bd71bcdbdb0436c51b1a71c64cce8eca9bde23f53da7c3180c9fd0b4a385b46be88bf0b318e5c1b5d7c07ad328291922731f601941b50206e07c48e7ee03bc4965b5c53a9298969c9f8e06159b597aa20148dc3d251e08d1def22dd8d4a4aebd346e6c6d35a4d01c37c15e15bdec352416b14b329544d33e0f4eb507f9b2accb73bdd55b7d4660b783a6ca3f22a8de3af7eaef4f0dbf4654a4e24c0dc2f91684b49012efd46887a0f4179aa9232d40aed9590b9745f46da27cb045a333b58a6383e5742b96f0d5f9ddc8cda080890a389f19fabc1b6274b3fbe69289b9d2448be9ee58d93cd7da6aedfb486ffd76b0a46a0fc5ee69d7067cc14c829b9139ecbb0980538593f704664ba6cafd1597eabe11f384597a5287fa5e021d6e6050e0684013d8d64acc77482bcfd8b0adcd1d49aa3dcd7e7918c9b3f6ba6472f722c4a8b4f28a3ce46ba139e0ddf28c8ea991804efc27b6fb6351d3f17b52c64c3a38a0ee887be73f712644db950c4b08c150bc19e7da74bc28d4e487f462557ebe39b88811d5034bbe6c4b9f18c5f68beef8d4210878cfb14aec7a488825fda554f8c36810448cb30fdb2ad4c74dcdb07f497dd9a831f6214fa00e2f368fae0b55a864d02b20a897d20e922b897490a0e18d09aad479547f6b43772b757d98efa34782629ecc57fa711ab2b1c1fd2e173e4399489328f02ebd386003a99fe35d75deca3ac1d694544497626ab6e184dda8d06c838c2fa858758662ed3d4308b87a0edace48694a91d8dd3b7591bb3b5cf5134182ffa9ed3f3589d4a863b2afbe5d47e77b6dae260ce2b25e770942959e06c744ad0cf7d396e48c7e0102e32a3ad7a9ed86da1e365ba39891896f5af9f607c682bd1d1c23ea22d357f36d05fd24419ef81df92cccd7f80557b2edad521444f30a1e7cbec169c7cb4de7b6da373c80e3d75db882b9c4b2c92311e7a6786f56bdfe76e0076b056622c825097c95efe5b44b14171430ef98edcb8009365fc514db66b6bbd0005e6b00006ed4d2d92c8232cbaad0a21643bf8f86e1d25487aa9e0a1f9a9d26a0b21268bd6c5707ce31a6445822703a957d52f6949eddc8807b757d2f51dd88940cd86727d12915d0c577f4ecff1f8eb4f6b3de222c8d9fc6f244b232ef4c0c7e68449f14eb4870a219768d52a6ba2dbf8e391a8e4ea2e171153d03feecc22f321dcc0c2cc8f93e8b6e4830406facec28a39beed4f1e0fc15d9951b6e399579b108064cce3e5dab42e4429b7fc16754912391a885233802fa7c52dd446bd6d0d96dfeb401e5ca76ae685ff29f9c592ef6e5f237b49c9d2746a8ac56e04afd694883e41145c75bc341eb7bce009633ad066b956a9ee03bc5e9eb706d02054cc713e91caba0cc2ca968ad6335c3ad3c184f5c1fe2e8c827cfa989f20e8590f6e948a6a7f69283922e37ddb9f95446c8c96df22e2571f34f5e4dcf3c1026d3304e08e8968916c3f95ec63fd1f2d1d93013544f09e9d9ffbdc1328f679fc6f37c7143f353d62f1a1f109c8e053441bd0a9459b5e67ea8771ce85a5e17fe26c095e68f77af0f21aa851071ee698d741d3482c8b729c8083a723a57e49e383b502c31b5e0e708feaa63e1b9dcb25f22cd089db22d3d489bd05db2c87edfe7904aa17a575dbefcae4ddb4ecd6e3d2a03ca25ebb012f3a8b9e380d865bc3f81b2ebcdeff1356f09ba42e1b74b50a6671233250a5875694f5fdbd17b70ca701133504648f5a9b6610bbff9559e0e88529e7bd823d4e2f9215c9f65239ebce960e38c0528977e7a2dc1e06aadeb6fbf2222b197ad08e3a57a1ad8002cf30bb22373f954144457a91e3a259dbac4d7bb89ea12a3ab796f0cb17cd6406b7af85748b27371eadad6f379a76abb4c0e73d34077fb99840a080a9b1288dbd2ad5475b83cb3f1dc841a64976c14e790a9851155ac60f309b97bdb23ef4bbca25c0ba109f97e54f90d69c35fb26095dc9b4ff16a0d06c931ef21cd80ad26441d14b3f4fc76c7c8c868efaf941bed451e814877951bb4020012a05e21bcef6a1fb9dc3c920cd9c561216dcc08355f2b112a6b7dc750b4e132ce290f50d1a6eb4c827bbd34180801996591c16c397959e1b075e8c13d3247c8f94e915f3747550553e8ab0af64ad6d479052d1e317324ffbcc98d0d5178f1964db7f636aabfd90951fa712ac6c1bb7c3cb586af2c5d9245cf769423992dbd74821db3591ce79d8d1de7d3ad33db4321fb34530e38ddacdee16fd381608696ad44949af2214df6c9d47be481535f28e24c932b79a4e9d87fd9a09418bc7df914a7efcb34c930aed2b22ee564022d989f07269ad321665dfd02b7176c241d0cde39ed68be722dc09195f79cf303cc7fb91416da9d4fb003e2144880fae37b71495a941e870f649c82d47366f4fe3ff890478b2fc25822957cdfee893fa645baa934da6f9c027258e6f8e1eda838d8c30c76d53b4f56cb0dbe84a798d0f8220b058b0df5aca5dc8be99680c34d4f21907e4035237c137034a50905e94fe38b9fb701334525522c44c0b1d3c9c471279bd1e16561f2c0cafe38675290dd1c99551e3fcafaa5c3b095fac17e937ce5ee4720a69eec0cd643c827ca6b517e86f179492f050d23974c2bdb016dca55d7a3486db655b97136c7ffba98fa83ecf9825125eaa0618aaf134bb2fecfb7f19807fc203a4432f2390b2c9f583d231e9ec2a6bf29f53177400031053ccb661f1dbb71ae69891eeed26198c9e1527c8629799e55275397877d351c06897951f686ca4d42db92d22ee9921dd3e3bcfd8124dd4fbe90cda053d64c893b50a30eed966eca2fd66dea573c2196a1c58f6442e88b95070ab90944f790685ae596c6770c925d9df2ba5a7fd4aa61454a51a41776d7a70489d4ad6fd222d62fbcaad7523047410ba45e2620fed29ee79e373f1725b660cfd903459888a2ad5f5633c67e9dc124351a2dafecd7818418594f7e2b532056c6821c0e3373ce9cc466bc6c12fcd6be538882763e93e7a0ad26509da2903ab9af295f8b8fda2d04b05cc8188ec978fda80b57691a0aadacaebf1282919cb907e35b54814a4e96b2f8292527676cc6c5607eefdc5d2f10654455d5ca9e286b34fff414e66dbd7e34d1adab3d290d6c4e5148f452ab2950664b2f2dd3b430f93bec984be021f3eb01bfaa27ed40c60d9ffb5d77526d0545d4144d4de8005d3bb05f893a04d3571193222a26829df7b2dd3680b6f61b64935beb1304bb31a6874b685162c73d0c1af38fa8c9de9148b2a660c97dac30a15a797a628912984773e34996e045dced4f6bf27bff847e745589371e91e5320888241f412046dd472ce395e08df0ae7102c77a1c9e0e2629950d0cc1adde27e36f0dea7c35bb9ee42c24603fc8af372532c6e41f64b18e78faa10b883cce6bc1e33a98ca568f9e6ebe5915d5daa624c50f895af2432383aa9be7013fd70fc34dcd759570c4a10fd77c5a45f9093c56c6a66f5efdce37735db6cbb82e33044c04b7a3ddfe97ed95f1bb8225b464f03001b90bdbb2fd02e0e234a3df1a80bc8ae0f75d4bc4c1d07ee960b262748131c97f83b58956a1438a5f62087b8a1382104ae8e7fde4296e113a9e9aaa58046601537d6567508418c8dfb5d5d4a33e9c586d80ef1ec94752338e10e0c5ab8aa32d4bce5aaeae78e5841abb30dfe149c00ee277f42c8298e6daf6d599252c1358db67b2e77c010a06c8ac1aa4e67402f0681af244a3a6e81832339d615ce296079fc67c19fa3220bb1578df6c78a0d027730913a342efcdcd94f189d8bb7a8ceef75f3f0c909578c21afa2c54f3fc3bd71247c73ccc67f8fe1c6c8c9b3a68eb243254894699e91f43f37e494225912c88f94fa6304540854fadb94eeddfa01aada991853ffaf7a7043565ee670773ae8527c151112b63a22e5d61468e7b84377b4921e2738eff9c14c1101e479c6607f0eac39a81842407216255bbc9a2da3374059c1bf7d161ccdedbf6b07a950a1120801a74b4ed7a186eedadd5a35581ffe3a41475a0884d473e55d291ecaf7d299f7f6081049b176e86b1a75c917623602061a372d9b4fe3b1a1be42bc1d247fadbfad77d08a3151df548b4335a224485cbe81c602e05a195f2d37</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>BJOI2021 游记</title>
    <url>/2021/03/BJOI2021-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>人还是很菜的，就是来打打酱油。</p>
<p>NOIp 成绩卡线进了 BJOI，那就来看看吧。。</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>看了看通知，貌似是 3.20，3.21，3.27，3.28 四天有模拟赛，然后 4 月份正式考试。</p>
<h1 id="Day-1-3-20"><a href="#Day-1-3-20" class="headerlink" title="Day 1 (3.20)"></a>Day 1 (3.20)</h1><p>上午模拟赛。9:00~12:30。</p>
<p>T1 一眼看出来了，十几分钟敲完了。</p>
<p>T2 感觉不太会，先去码 T3。</p>
<p>T3 直接大力上 DS，写了一棵平衡树和一棵动态开点线段树，感觉能有 $80$ pts。</p>
<p>然后去看 T2，感觉这 $80$ 分是一个很傻的 dp。</p>
<p>写了写，自己手玩了几下，感觉没啥问题。</p>
<p>这时是 11:30，很幸运 DS 没怎么调试就过了样例和手玩的一些点。</p>
<p>然后小恐龙了一下，不小心忘关声音了引发全机房的笑声。。。</p>
<p>想了想觉得要写个对拍，于是开始写。</p>
<p>先写 T3 的：我用平衡树和动态开点线段树互相拍，拍了几百组没错，那应该没事了。</p>
<p>然后拍 T1：诶诶诶怎么错了？？？</p>
<p>我不停地缩小 gen 的数据范围，然后开始手玩。</p>
<p>诶为什么我暴力写挂了？？？</p>
<p>改了一下暴力，拍了几百组没出错，感觉没问题了。</p>
<p>估分 $100+80+80=260$。</p>
<p>然后去小恐龙，拿到了我自己的历史最高分：</p>
<p><img src="https://i.loli.net/2021/03/20/T6cjuy95NAmGptE.png" alt=""></p>
<hr>
<p>中午吃了个饭，感觉味道还不错。</p>
<hr>
<p>下午发榜，讲题。</p>
<p>我 T3 怎么挂成 $50$ 了？？</p>
<p>但这样怎么还有全场并列 rk8，我校 rk1？？？</p>
<p>就离谱，看起来这次考简单了，大家都会 $260$ 的样子，但是就是比谁挂分挂的少。</p>
<p>如果考难了我直接暴毙，毕竟还有好多省选的知识点没学。。。</p>
<p>而且感觉这次有些神仙在演戏。。</p>
<p><img src="https://i.loli.net/2021/03/20/yRo5XGPNlFMwf8n.png" alt=""></p>
<p>（图片里的 rk1 是 std）</p>
<p>讲题时：</p>
<p>第一题</p>
<p>老师：这位同学你来讲讲这个部分分是怎么写的</p>
<p>同学：老师我是挂成这个部分分的</p>
<p>第二题</p>
<p>老师：这位同学你来讲讲这个部分分是怎么写的</p>
<p>同学：老师我是挂成这个部分分的</p>
<p>第三题</p>
<p>老师：这位同学你来讲讲这个部分分是怎么写的</p>
<p>同学：老师我是挂成这个部分分的</p>
<p>老师：。。。</p>
<p>这说明了这场比赛的挂分之惨。。DS 还是不要随便莽。。</p>
<p>听讲评的总结：T1 本来就会，T2 听了有点懵，T3 听了不懂。</p>
<p>估计之后的题不会这么简单了。。。</p>
<p>发 result.html 后：我 T3 Treap 数组开小了，<code>score-=15</code>。</p>
<p>至今不知道另外 $15$ 分怎么挂的。</p>
<hr>
<p><strong>upd：</strong> 另外 $15$ 分挂在动态开点线段树 <code>pushdown</code> 空节点。</p>
<hr>
<h1 id="Day-2-3-21"><a href="#Day-2-3-21" class="headerlink" title="Day 2 (3.21)"></a>Day 2 (3.21)</h1><p>心态爆炸的一天。</p>
<p>T1 一看：要建个图！</p>
<p>于是尝试了各种建图跑网络流、二分图匹配、最小点覆盖、最大独立集……的方法。</p>
<p>然后没想出来，直接心态爆炸，写了个暴力就滚了。</p>
<p>T2 T3 因为心态爆炸，连暴力都没打。</p>
<p>最终得分：$20$。并列 rk 57，我校 rk4（我校菜）。直接暴毙了。</p>
<p>绵羊 $90$ 分 orz。他 T1 写了个堆优的 prim 结果比不加堆优还慢/fad</p>
<p>等等，prim？？？</p>
<p>你告诉我这玩意是最小生成树？？？？？？？？？？？</p>
<p>我建图方法都想好了，然后直接滚去网络流……</p>
<p>我是**</p>
<hr>
<h1 id="Day-3-3-27"><a href="#Day-3-3-27" class="headerlink" title="Day 3 (3.27)"></a>Day 3 (3.27)</h1><p>第一题什么阴间题啊，扔掉了。</p>
<p>第二题果断先暴力，$12$ pts。</p>
<p>然后去搞第三题。</p>
<p>首先理解错了题意，以为这个函数需要是连续的，推了亿会式子之后发现这玩意定义域是 $\mathbb{Z}$。</p>
<p>于是果断爆搜啊（枚举每个点的纵坐标）！然后随便手搞了几组数据，调了一些错。纵坐标我枚举到了 $yp+C$ 来保证正确性（这就是找出来的错之一），复杂度不太对劲，但显然跑不满。说不定能拿到 $20$ pts。</p>
<p>然后发分，我 $0+12+20=32$，rk37，我校 rk1？？？</p>
<p>而且 T3 $20$ 分的全场竟然只有 $3$ 个？？？</p>
<p>离谱，是不是大家枚举没枚举够啊。。。</p>
<p>然后发现 T1 的某些部分分很傻，白给了。。（例如 $m=2$ 的部分分）</p>
<hr>
<h1 id="Day-4-3-28"><a href="#Day-4-3-28" class="headerlink" title="Day 4 (3.28)"></a>Day 4 (3.28)</h1><p>EI 场必有数数题。</p>
<p>结果你 ** 给我 $3$ 道数数？？？？</p>
<p>首先看 T1。</p>
<p>瞪了一会，想起了幼儿园排列组合的插空法，推了推式子，写了写逆元，切了。</p>
<p>然后去打了一下 T3 的最裸的暴力。</p>
<p>然后看了看 T2，想了个 $O(n^4)$ 的诡异 dp。</p>
<p>写完之后发现假了。</p>
<p>最终得分：$100+0+5=105$，并列 rk43，我校还是 rk1？？？？</p>
<p>另外两个写了 T1 正解的我校同学都挂了。他们逆元没处理到 $0$。。。</p>
<p>不过一绵羊挂成 $70$，registerGen 挂成 $50$，因为绵羊写了个按数据点分治（</p>
<hr>
<h1 id="Day-5-4-10-考试日"><a href="#Day-5-4-10-考试日" class="headerlink" title="Day 5 (4.10, 考试日)"></a>Day 5 (4.10, 考试日)</h1><p>直接自闭。</p>
<p>T1 先写了个假贪心，大样例虽然很水还是没有过第三个点。然后写了个暴力。</p>
<p>T2 先写了个高斯消元，然后啥也消不出来，最后写了下 $m=2$ 的点。考试结束前一小会 $n,m\le 3$ 的点稍微骗了下分（估计骗不到，毕竟这玩意随便卡）。</p>
<p>这是 $n=3,m=3$ 的特判（$n=2$ 的就不放了）：</p>
<p><img src="https://i.loli.net/2021/04/16/gGrzn4Yva9KLEl1.png" alt="离谱的骗分"></p>
<p>T3 只会打暴力。</p>
<p>估分：$20+30+16=66$。</p>
<p>出考场发现大家都多多少少打了一些其他的特殊性质。。感觉我人要没</p>
<hr>
<h1 id="Day-6-4-11-考试日"><a href="#Day-6-4-11-考试日" class="headerlink" title="Day 6 (4.11, 考试日)"></a>Day 6 (4.11, 考试日)</h1><p>还是自闭。</p>
<p>T1 先写了个暴力。然后想了半天搞出一个 $O(nm\log n)$ 的奇怪做法。于是开始写了之后发现它的空间也是 $O(nm\log n)$ 的，显然开不下，于是暴毙了。</p>
<p>T2 打爆搜，$O(n!\times m)$，结果发现连 $n=8$ 都过不去，真奇怪。。</p>
<p>T3 先写了个 tarjan，然而还是没什么用。于是还是向暴力低头。</p>
<p>估分：$25+25+10=60$。</p>
<p>出考场之后发现绵羊 T1 写了一条链的情况，结果和我放在树上 $O(nm\log n)$ 的做法一毛一样。。。但是写在一条链上简单很多，我是**。</p>
<p>T2 可以不带 $m$。。。枚举全排列之后贪心即可。。。而且带 $m$ 的同学也没一个跑的比我慢。。。我是**。</p>
<p>而且 T3 的 $m=n-1$ 的点一定是树。。。我没看见 $1$ 一定能到其它所有点。。。我是**。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次省选就当观光了吧。</p>
<p>人人打的分都比我多。</p>
<p>坐等出分。</p>
<p>另外某些民间数据纯随的真的水。。。我 T1 直接 $100$。。。</p>
<p>就离谱，然而 CCF 显然不会干这种事。</p>
<p>总估分：$20+30+16+25+25+10=126$。</p>
<hr>
<h1 id="出分"><a href="#出分" class="headerlink" title="出分"></a>出分</h1><p>挂分了，挂了 $-90$ 分。</p>
<p>实际得分：$90+50+16+25+25+10=216$。</p>
<p>T1 真就直接过，然而最后一个点被卡常，洛谷上最后一个点 $&gt;900\mathrm{ms}$，所以懒得申诉了。</p>
<p>T2 的骗分真就过了呗。。。这显然随便卡啊。。。</p>
<p>CCF 用脚造数据。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次 Div3 AK</title>
    <url>/2021/02/%E8%AE%B0%E4%B8%80%E6%AC%A1-Div3-AK/</url>
    <content><![CDATA[<p>这是人生第一次 AK Div3。</p>
<p>比赛链接在<a href="https://codeforces.com/contest/1490" target="_blank" rel="noopener">这里</a></p>
<a id="more"></a>
<p>这是最后的榜：</p>
<p><img src="https://i.loli.net/2021/02/18/PCT2w19y5roLbZf.png" alt="image.png"></p>
<p>可以发现：我对简单题的思考有很大的欠缺；而且罚时动不动爆炸，经常心急。</p>
<p>下面一道题一道题说。</p>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>题目中定义“密集的”序列是序列的任意相邻两数中，大的除以小的小于等于 $2$。</p>
<p>发现题目范围中 $a_i\le 50$，我们对于那些不满足题意的相邻两数暴力的在中间加数即可。具体来讲就是不停的加入 $\min\{a_i,a_{i+1}\}\times 2^k$，直到 $\frac{\max\{a_i,a_{i+1}\}}{\min\{a_i,a_{i+1}\}\times 2^k}\le 2$ 为止。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n,a[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx=max(a[i],a[i+<span class="number">1</span>]),mn=min(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">while</span>((mx+mn<span class="number">-1</span>)/mn&gt;<span class="number">2</span>) &#123;</span><br><span class="line">                mn*=<span class="number">2</span>,ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>我们循环按题意模拟两边即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        <span class="keyword">int</span> c[<span class="number">3</span>];</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>) c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            c[x%<span class="number">3</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,anss=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> x=n/<span class="number">3</span>;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">if</span>(c[i]!=x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i]&lt;x) ;</span><br><span class="line">            <span class="keyword">else</span> ans+=c[i]-x,c[(i+<span class="number">1</span>)%<span class="number">3</span>]+=c[i]-x,c[i]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">if</span>(c[i]!=x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i]&lt;x) ;</span><br><span class="line">            <span class="keyword">else</span> ans+=c[i]-x,c[(i+<span class="number">1</span>)%<span class="number">3</span>]+=c[i]-x,c[i]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        anss=min(anss,ans);ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>因为 $1\le x\le 10^{12}$，因此 $a,b$ 不会超过 $\sqrt[3]{10^{12}}=10^4$。</p>
<p>所以我们枚举 $1\sim 10^4$ 这些数的三次方。把这些三次方数扔进一个 <code>set</code> 里。</p>
<p>然后对于每一个询问，我们遍历一遍 <code>set</code>，看看这个数减去遍历到的数是不是在那个 <code>set</code> 里面。如果是的话，这个数就可以表示成 $a^3+b^3$ 的形式。如果遍历了一遍都不是的话，就不行。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i,<span class="number">1</span>,<span class="number">10000</span>) s.insert(i*i*i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=s.begin();ii!=s.end();++ii) &#123;</span><br><span class="line">            <span class="keyword">int</span> qwq=(*ii);</span><br><span class="line">            <span class="keyword">if</span>(qwq&gt;=n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> rem=n-qwq;</span><br><span class="line">            <span class="keyword">if</span>(s.count(rem)) &#123;flg=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flg) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>题目给了一棵二叉树的中序遍历，让我们求出所有节点的深度。</p>
<p>这不大水题吗？？考虑分治，每次找到范围内最大的数拎成根，更新答案，然后从这里劈两半继续往下处理即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>],ans[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;ans[l]=dep;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,id;</span><br><span class="line">    rep(i,l,r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mx) mx=a[i],id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[id]=dep;</span><br><span class="line">    solve(l,id<span class="number">-1</span>,dep+<span class="number">1</span>);</span><br><span class="line">    solve(id+<span class="number">1</span>,r,dep+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        solve(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>首先一个人肯定有机会打败 $a$ 值 $\le$ 他的人（因为 $a$ 值相同的话是随机打败，总之有机会）。</p>
<p>因此我们先将 $a$ 数组排个序。</p>
<p>打败完了这么多人之后，我们设这个人位置为 $x$，他现在的 $a$ 值变成了所有 $a$ 值 $\le a_x$ 的人的 $a$ 值之和。</p>
<p>然后他打败了这么多人后还有机会接着向后打败，也就是说，如果现在这个人的 $a$ 值比后头一个人的 $a$ 值大，那么就可以往下继续滚雪球。但如果遇到当前 $a$ 值比后一个人的 $a$ 值小了，这个人就打败不了，后头的人也打败不了了。</p>
<p>也就是说我们肯定要先做个前缀和。</p>
<p>一个人要赢，肯定就是要打败所有人，意思就是他滚的雪球要滚到底。</p>
<p>所以我们从后往前推，如果说哪里遇到当前的前缀和比后一个人的 $a$ 值小了，那么就 <code>break</code> 掉，因为再往前的人都打败不了这个人了，雪球滚不下去。否则就继续循环。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">bool</span> ans[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">200005</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; summ,nxt;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        summ.clear();nxt.clear();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) ans[i]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) b[i]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].first);</span><br><span class="line">            a[i].second=i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+a[i].first;</span><br><span class="line">            summ[a[i].first]=sum[i];</span><br><span class="line">            <span class="keyword">if</span>(a[i].first!=a[i<span class="number">-1</span>].first) nxt[a[i<span class="number">-1</span>].first]=a[i].first;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[a[n].second]=<span class="number">1</span>;</span><br><span class="line">        nxt[a[n].first]=<span class="number">0</span>;</span><br><span class="line">        per(i,n<span class="number">-1</span>,<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(summ[a[i].first]&gt;=nxt[a[i].first]) ans[a[i].second]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> qwq=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i]) ++qwq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,qwq);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i]) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>一句话题意：给一个数组 $a$，我们要任意画一条线 $C$，使得出现次数比 $C$ 多的数的出现次数要删到 $C$，出现次数比 $C$ 少的数的出现次数要删到 $0$，问所有划线的方案中最少要删多少个数。</p>
<p>首先我们先离散化一下数组 $a$，这样 $a$ 数组中的数可以扔进一个桶 $bin$ 里。</p>
<p>然后我们对这个桶数组进行排序（也就是将所有数的出现次数排个序），然后跑个前缀和。</p>
<p>由于所有数最多出现 $n$ 次，因此我们画的线 $C$ 一定不超过 $n$。那么我们可以枚举 $C$，对于每个 $C$，在桶中二分找到第一个 $\ge C$ 的数。在这个数前面的就都删到 $0$，删除次数就是个前缀和；在这个数后面的就都删到 $C$，删除次数就是用前缀和相减再减去这些数的个数 $\times C$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>],b[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> bin[<span class="number">200005</span>],sum[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line">        sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> nn=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) a[i]=lower_bound(b+<span class="number">1</span>,b+nn+<span class="number">1</span>,a[i])-b;</span><br><span class="line">        rep(i,<span class="number">1</span>,nn) bin[i]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) bin[a[i]]++;</span><br><span class="line">        sort(bin+<span class="number">1</span>,bin+nn+<span class="number">1</span>);</span><br><span class="line">        rep(i,<span class="number">1</span>,nn) sum[i]=sum[i<span class="number">-1</span>]+bin[i];</span><br><span class="line">        <span class="keyword">int</span> anss=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        rep(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">            <span class="keyword">int</span> id=lower_bound(bin+<span class="number">1</span>,bin+nn+<span class="number">1</span>,i)-bin;</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span>(id&gt;nn) ans=sum[nn];</span><br><span class="line">            <span class="keyword">else</span> ans=sum[id<span class="number">-1</span>]+(sum[nn]-sum[id<span class="number">-1</span>]-(nn-id+<span class="number">1</span>)*i);</span><br><span class="line">            anss=min(anss,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p>题目用蜗牛爬井解释更好理解一点。</p>
<hr>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一只蜗牛在从一个井里往上爬。初始时它所在高度为 $0$。</p>
<p>他按照序列 $a$ 不停的爬着（序列 $a$ 长度为 $n$），每次爬的时候，他所在高度都 $+a_i$（$a_i$ 可能为负）。爬完 $n$ 次之后又从 $a_1$ 继续爬。</p>
<p>有 $m$ 次询问，每次问蜗牛爬到高度 $x$ 最少需要爬多少次，如果蜗牛会一直爬下去不停下，输出 <code>-1</code>。</p>
<hr>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑把蜗牛在一次循环内能到达的正数所需的最短时间扔进一个 <code>map</code> 内。换句话说，我们想知道蜗牛在一次循环中到达 $x$ 最少需要爬多少次，只需在这个 <code>map</code> 上 <code>lower_bound</code> 一下 $x$ 就可以了。</p>
<p>然后显然还需要存一次循环总共蜗牛会移动多少，记为 $k$。</p>
<p>那么我们对于每个询问，先在 <code>map</code> 中找一下第一轮能不能到。</p>
<p>能就直接输出，不能的话分两种情况：</p>
<ol>
<li><p>如果 $k\le0$，那么蜗牛一定会永无停息地爬，输出 <code>-1</code>。</p>
</li>
<li><p>如果 $k&gt;0$，我们可以找到一个循环的次数 $w$ 使得 <code>map</code> 中最高的 <code>key</code> $+w\times k\ge x$ 。这个时候就是 $x$ 第一次被达到的时候。</p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tim;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;_);_;--_) &#123;</span><br><span class="line">        tim.clear();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>,mx=<span class="number">0</span>,mxid=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">            row+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(row&gt;mx) mx=row,mxid=i,tim[mx]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator ii=tim.lower_bound(x);</span><br><span class="line">            <span class="keyword">if</span>(ii==tim.end()&amp;&amp;row&lt;=<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"-1 "</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ii==tim.end())&#123;</span><br><span class="line">                <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator lst=tim.end();--lst;</span><br><span class="line">                <span class="keyword">int</span> ned=(x-lst-&gt;first+row<span class="number">-1</span>)/row;</span><br><span class="line">                ii=tim.lower_bound(x-ned*row);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ii-&gt;second+ned*n<span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ii-&gt;second<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>赛后总结</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF240F TorCoder</title>
    <url>/2021/01/%E9%A2%98%E8%A7%A3-CF240F-TorCoder/</url>
    <content><![CDATA[<p>考虑开 26 棵线段树。每棵线段树维护它对应的字母在这个字符串中的出现情况。</p>
<a id="more"></a>
<p>然后我们考虑，什么样的区间能转换成一个回文串呢？</p>
<p>这个区间中，出现的任何字母的出现次数<strong>要么都为偶数，要么只有一个奇数，其余都是偶数</strong>时，这个区间可以通过字母重排变为一个回文串。所以每棵线段树都需要支持区间求和以查询区间中特定字母的出现次数。</p>
<p>如果可以转换，怎么让这个区间重排之后字典序最小？</p>
<p>思想：字典序越小的字母，我们优先把它放前面就可以了。</p>
<p>具体来说，如果字母的出现次数中有一个奇数，那么先把出现了奇数次的这个字母单拎出来扔到中间。然后，为了保证字典序最小，我们从 $a$ 到 $z$ ，从两边到中间放即可。对于每个字母，一边放一半。因此我们的每棵线段树需要支持区间赋值的操作。</p>
<p>具体见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> sum,tag;</span><br><span class="line">&#125;t[<span class="number">26</span>][N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    t[tr][p].sum=t[tr][p&lt;&lt;<span class="number">1</span>].sum+t[tr][p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[tr][p].tag!=<span class="number">-1</span>) &#123;</span><br><span class="line">        t[tr][p&lt;&lt;<span class="number">1</span>].tag=t[tr][p].tag;</span><br><span class="line">        t[tr][p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag=t[tr][p].tag;</span><br><span class="line">        t[tr][p&lt;&lt;<span class="number">1</span>].sum=(t[tr][p&lt;&lt;<span class="number">1</span>].r-t[tr][p&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*t[tr][p].tag;</span><br><span class="line">        t[tr][p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum=(t[tr][p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-t[tr][p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*t[tr][p].tag;</span><br><span class="line">        t[tr][p].tag=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[tr][p].l=l;t[tr][p].r=r;</span><br><span class="line">    t[tr][p].sum=<span class="number">0</span>;t[tr][p].tag=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        t[tr][p].sum=(s[l]-<span class="string">'a'</span>)==tr;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(tr,p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    build(tr,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    pushup(tr,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=t[tr][p].l&amp;&amp;t[tr][p].r&lt;=r) &#123;</span><br><span class="line">        t[tr][p].tag=val;</span><br><span class="line">        t[tr][p].sum=(t[tr][p].r-t[tr][p].l+<span class="number">1</span>)*val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(tr,p);</span><br><span class="line">    <span class="keyword">int</span> mid=(t[tr][p].l+t[tr][p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) modify(tr,p&lt;&lt;<span class="number">1</span>,l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) modify(tr,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,val);</span><br><span class="line">    pushup(tr,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=t[tr][p].l&amp;&amp;t[tr][p].r&lt;=r) <span class="keyword">return</span> t[tr][p].sum;</span><br><span class="line">    pushdown(tr,p);</span><br><span class="line">    <span class="keyword">int</span> mid=(t[tr][p].l+t[tr][p].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=query(tr,p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) ans+=query(tr,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"output.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;n,&amp;m,s+<span class="number">1</span>);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">25</span>) build(i,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">int</span> tim[<span class="number">26</span>],odd=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nedod=<span class="number">-1</span>;</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">25</span>) tim[j]=query(j,<span class="number">1</span>,l,r);</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">25</span>) <span class="keyword">if</span>(tim[j]&amp;<span class="number">1</span>) ++odd,nedod=j;</span><br><span class="line">        <span class="keyword">if</span>(odd&gt;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">25</span>) modify(j,<span class="number">1</span>,l,r,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(odd) --tim[nedod],modify(nedod,<span class="number">1</span>,(l+r)&gt;&gt;<span class="number">1</span>,(l+r)&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> nl=l,nr=r;</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">25</span>) <span class="keyword">if</span>(tim[j]) &#123; <span class="comment">// 从两边向中间放，一边放一半</span></span><br><span class="line">            modify(j,<span class="number">1</span>,nl,nl+tim[j]/<span class="number">2</span><span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            nl+=tim[j]/<span class="number">2</span>;</span><br><span class="line">            modify(j,<span class="number">1</span>,nr-tim[j]/<span class="number">2</span>+<span class="number">1</span>,nr,<span class="number">1</span>);</span><br><span class="line">            nr-=tim[j]/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        rep(j,<span class="number">0</span>,<span class="number">25</span>) <span class="keyword">if</span>(query(j,<span class="number">1</span>,i,i)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,j+<span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF323C Two permutations</title>
    <url>/2021/01/%E9%A2%98%E8%A7%A3-CF323C-Two-permutations/</url>
    <content><![CDATA[<p>话说这题怎么评到黑的？？</p>
<a id="more"></a>
<p>我们可以把第二个排列中的数在第一个排列中出现的位置都处理出来。</p>
<p>然后对于每个询问，答案就变成了第二个序列中 $[l_2,r_2]$ 这个区间内，在第一个序列中位置处于 $[l_1,r_1]$ 的数的个数。</p>
<p>我们以第二个排列的下标为版本，以对应的第一个排列中的位置为下标建立一棵可持久化线段树。</p>
<p>具体就是扫一遍这个序列，对于序列中的每一个数都在前一个数的基础上新建一个版本，以这个数为下标在这个版本上 $+1$。然后答案就是版本 $r_2$ 与版本 $l_2-1$ 中询问 $[l_1,r_1]$ 这两个区间的区间和做差。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],tmp[N],m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,ls,rs;</span><br><span class="line">&#125;t[N*<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> rt[N];</span><br><span class="line"><span class="keyword">int</span> lst=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x+lst<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> q,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    p=++tot;</span><br><span class="line">    t[p].ls=t[q].ls;</span><br><span class="line">    t[p].rs=t[q].rs;</span><br><span class="line">    t[p].val=t[q].val+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;=mid) modify(t[p].ls,t[q].ls,l,mid,val);</span><br><span class="line">    <span class="keyword">else</span> modify(t[p].rs,t[q].rs,mid+<span class="number">1</span>,r,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) <span class="keyword">return</span> t[p].val;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid) ans+=query(t[p].ls,l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;qr) ans+=query(t[p].rs,mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        tmp[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        a[i]=tmp[b[i]];</span><br><span class="line">        modify(rt[i],rt[i<span class="number">-1</span>],<span class="number">1</span>,n,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1,l2,r1,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        l1=f(l1),l2=f(l2),r1=f(r1),r2=f(r2);</span><br><span class="line">        <span class="keyword">if</span>(l1&gt;r1) swap(l1,r1);</span><br><span class="line">        <span class="keyword">if</span>(l2&gt;r2) swap(l2,r2);</span><br><span class="line">        lst=query(rt[r2],<span class="number">1</span>,n,l1,r1)-query(rt[l2<span class="number">-1</span>],<span class="number">1</span>,n,l1,r1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lst);</span><br><span class="line">        ++lst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>USACO 2021 Jan 总结</title>
    <url>/2021/01/USACO-2021-Jan-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这次是我第一次打 USACO qaq</p>
<p>于是参加了铜组和银组（铜组 AK 提前晋级）。</p>
<a id="more"></a>
<h1 id="USACO-2021-Jan"><a href="#USACO-2021-Jan" class="headerlink" title="USACO 2021 Jan"></a>USACO 2021 Jan</h1><h2 id="Bronze"><a href="#Bronze" class="headerlink" title="Bronze"></a>Bronze</h2><p>铜组的题都很水啦。。</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>直接模拟。将 Farmer John 听到的字符串扫一遍，如果有相邻的两个字母在牛版字母表中逆序，就重新开一个新的字母歌。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s 为牛的字母表，t 为 FJ 听到的字符串</span></span><br><span class="line">rep(i,<span class="number">0</span>,<span class="number">25</span>) &#123;</span><br><span class="line">    to[s[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>,now=<span class="number">-1</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,l) &#123;</span><br><span class="line">    <span class="keyword">if</span>(to[t[i]-<span class="string">'a'</span>]&lt;=now) &#123;</span><br><span class="line">        now=to[t[i]-<span class="string">'a'</span>];</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125; <span class="keyword">else</span> now=to[t[i]-<span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>先统计奇数和偶数的个数。</p>
<p>由于题目要求一奇一偶交替，于是我们可以先把奇数和偶数中个数最少的那个先用完。</p>
<p>然后只剩下一堆奇数或者一堆偶数了。</p>
<p>如果剩下一堆偶数，那么可以把这堆偶数搓成一团放在下一个。答案 $+1$。</p>
<p>如果剩下一堆奇数，由于题目要保证所有的牛都划分完，所以我们分奇数个数$\mod 3$ 的三种情况讨论即可。具体见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=min(ji,ou);</span><br><span class="line">ji-=ans,ou-=ans;</span><br><span class="line"><span class="keyword">if</span>(ou) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ji%<span class="number">3</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="number">2</span>+(ji/<span class="number">3</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ji%<span class="number">3</span>==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="number">2</span>+(ji/<span class="number">3</span>)*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="number">2</span>+((ji<span class="number">-2</span>)/<span class="number">3</span>)*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>考虑乘法原理。</p>
<p>我们把牛从高到低考虑，因为如果先考虑低牛的话，低牛可能会占用高牛的必须位置，但是先考虑高牛就不会影响到低牛的方案数。</p>
<p>然后就是裸的乘法原理了。对于每头牛，将答案乘以这头牛的方案数即可。别忘了乘完之后下一头牛的方案数要 $-1$，因为这头牛占用了下一头牛的一个可能情况（只是可能情况，而不是必须位置）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>,now=<span class="number">0</span>;</span><br><span class="line">per(i,n,<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> id=lower_bound(b+<span class="number">1</span>,b+n+<span class="number">1</span>,a[i])-b;</span><br><span class="line">    id=n-id+<span class="number">1</span>; <span class="comment">// 有多少个牛棚塞得下这头牛</span></span><br><span class="line">    ans*=id-now; <span class="comment">// -now 是因为更高的牛一定占用了其中的 now 个牛棚</span></span><br><span class="line">    ++now; <span class="comment">// 下一头牛方案数 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Silver"><a href="#Silver" class="headerlink" title="Silver"></a>Silver</h2><p>这次银组还是比较有含金量的。</p>
<h3 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h3><p>我们先模拟一轮，看每头牛分别能到哪里，对每头牛开一个 <code>set</code>。</p>
<p>模拟完一轮之后，我们可以找到这个序列中所有的环。</p>
<p>然后将这些环中的 <code>set</code> 合并即可。</p>
<p>一个节省代码量的小 trick：将两个 <code>set</code> 合并可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a.insert(b.begin(),b.end()); <span class="comment">// 意为将 b 合并进 a</span></span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k,<span class="keyword">bool</span> first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!first&amp;&amp;u==k) <span class="keyword">return</span> ;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    s[k].insert(s[u].begin(),s[u].end());</span><br><span class="line">    dfs(cow[u],k,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k,<span class="keyword">bool</span> first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!first&amp;&amp;u==k) <span class="keyword">return</span> ;</span><br><span class="line">    ans[u]=s[k].size();</span><br><span class="line">    dfs2(cow[u],k,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) cow[i]=i,s[i].insert(i);</span><br><span class="line">    rep(i,<span class="number">1</span>,k) &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        swap(cow[a],cow[b]);</span><br><span class="line">        s[cow[b]].insert(b);</span><br><span class="line">        s[cow[a]].insert(a);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">        dfs(i,i,<span class="number">1</span>);</span><br><span class="line">        dfs2(i,i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h3><p>我们可以先 dp 求出前缀的答案和后缀的答案。</p>
<p>具体可以开一个桶，转移的时候分两种情况讨论即可。</p>
<p>然后对一个挖掉的区间 $[l,r]$，答案就是 $pre_{l-1}+suf_{r+1}$。</p>
<p>详见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]&gt;s[i<span class="number">-1</span>]) f[i]=f[i<span class="number">-1</span>]+<span class="number">1</span>,vis[s[i]-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+(!vis[s[i]-<span class="string">'A'</span>]);</span><br><span class="line">        per(j,s[i<span class="number">-1</span>]-<span class="string">'A'</span>,s[i]-<span class="string">'A'</span>+<span class="number">1</span>) vis[j]=<span class="number">0</span>;</span><br><span class="line">        vis[s[i]-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">0</span>,<span class="number">25</span>) vis[i]=<span class="number">0</span>;</span><br><span class="line">per(i,n,<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]&gt;s[i+<span class="number">1</span>]) g[i]=g[i+<span class="number">1</span>]+<span class="number">1</span>,vis[s[i]-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        g[i]=g[i+<span class="number">1</span>]+(!vis[s[i]-<span class="string">'A'</span>]);</span><br><span class="line">        per(j,s[i+<span class="number">1</span>]-<span class="string">'A'</span>,s[i]-<span class="string">'A'</span>+<span class="number">1</span>) vis[j]=<span class="number">0</span>;</span><br><span class="line">        vis[s[i]-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">1</span>,q) &#123;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[l<span class="number">-1</span>]+g[r+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>只会一半分的 $N\le 10$ 做法qwq</p>
<p>具体来说就是，我们确定了一行一列之后，其它的格子都可以直接确定。</p>
<p>那么爆搜这一行一列即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qwq=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==n+<span class="number">1</span>) &#123;</span><br><span class="line">        rep(i,<span class="number">2</span>,n) rep(j,<span class="number">2</span>,n) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=now[i<span class="number">-1</span>][j<span class="number">-1</span>]+now[i][j<span class="number">-1</span>]+now[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(!tmp||tmp==<span class="number">3</span>) &#123;anss-=qwq;<span class="keyword">return</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp==<span class="number">1</span>) anss+=a[i][j],now[i][j]=<span class="number">1</span>,qwq+=a[i][j];</span><br><span class="line">            <span class="keyword">else</span> now[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,anss);</span><br><span class="line">        anss-=qwq;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==n+<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>) x=<span class="number">1</span>,y=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span>) &#123;</span><br><span class="line">        now[x][y]=<span class="number">1</span>;</span><br><span class="line">        anss+=a[x][y];</span><br><span class="line">        dfs(x+<span class="number">1</span>,y);</span><br><span class="line">        now[x][y]=<span class="number">0</span>;</span><br><span class="line">        anss-=a[x][y];</span><br><span class="line">        dfs(x+<span class="number">1</span>,y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        now[x][y]=<span class="number">1</span>;</span><br><span class="line">        anss+=a[x][y];</span><br><span class="line">        dfs(x,y+<span class="number">1</span>);</span><br><span class="line">        now[x][y]=<span class="number">0</span>;</span><br><span class="line">        anss-=a[x][y];</span><br><span class="line">        dfs(x,y+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) rep(j,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Bronze 没啥好说的，轻松 AK。</p>
<p>Silver C 没想出来正解，不过估计能上 Gold 了。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title>一元二次方程的整根问题</title>
    <url>/2021/01/%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E7%9A%84%E6%95%B4%E6%A0%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>二次跑得比一次快。</p>
<center>————lxj</center>

</blockquote>
<a id="more"></a>
<h2 id="一元二次方程的整根问题"><a href="#一元二次方程的整根问题" class="headerlink" title="一元二次方程的整根问题"></a>一元二次方程的整根问题</h2><p>对于一元二次方程的整根问题，有以下 5 种主要方法。</p>
<p>其中前两种为中考要求。</p>
<h3 id="利用判别式列不等式求范围"><a href="#利用判别式列不等式求范围" class="headerlink" title="利用判别式列不等式求范围"></a>利用判别式列不等式求范围</h3><p>例：一元二次方程 $x^2-4x+m=0$ 有整根，求所有满足条件的正整数 $m$。</p>
<p>解：$\because \Delta=16-4m\ge 0$，$\therefore m\le 4$。</p>
<p>经检验，$m=3,4$ 时符合题意。故 $m=3$ 或 $m=4$。</p>
<p>这种方法主要用于 $\Delta\ge 0$ 就可以卡出很小的 $m$ 的范围的情况。</p>
<h3 id="可以直接求根"><a href="#可以直接求根" class="headerlink" title="可以直接求根"></a>可以直接求根</h3><p>例：一元二次方程 $mx^2-(m+2)x+2=0$ 两根均为整根，求所有满足条件的正整数 $m$。</p>
<p>解：因式分解可得 $(mx-2)(x-1)=0$。</p>
<p>$\therefore x_1=\frac{2}{m},x_2=1$。</p>
<p>$\therefore m=\pm 1,\pm 2$。</p>
<h3 id="判别式是二次式：令-Delta-k-2"><a href="#判别式是二次式：令-Delta-k-2" class="headerlink" title="判别式是二次式：令 $\Delta=k^2$"></a>判别式是二次式：令 $\Delta=k^2$</h3><p>例：$x^2-ax+a=0$ 的两根都为整根，求整数 $a$ 的值。</p>
<p>解：$\Delta=a^2-4a\ge 0$。</p>
<p>令 $a^2-4a=k^2(k$为非负整数$)$。</p>
<p>$\therefore (a-2)^2-k^2=4$。$\therefore (a+k-2)(a-k-2)=4$。</p>
<p>然后枚举 $4$ 的约数即可。</p>
<h3 id="韦达定理"><a href="#韦达定理" class="headerlink" title="韦达定理"></a>韦达定理</h3><p>例：$x^2-ax+a=0$ 的两根都为整根，求整数 $a$ 的值。</p>
<p>解：$\Delta=a^2-4a\ge 0$。</p>
<p>此时，</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
x_1+x_2=a \\ 
x_1x_2=a
\end{matrix}\right.</script><p>故 $x_1x_2-x_1-x_2=0$。</p>
<p>两边同时 $+1$，因式分解可得 $(x_1-1)(x_2-1)=1$。</p>
<p>然后枚举 $1$ 的约数即可。</p>
<h3 id="主元法"><a href="#主元法" class="headerlink" title="主元法"></a>主元法</h3><p>例：$x^2-ax+a=0$ 的两根都为整根，求整数 $a$ 的值。</p>
<p>解：变形可得 $a=\frac{x^2}{x-1}=x+1+\frac{1}{x-1}$。</p>
<p>$\therefore (x-1)|1$。</p>
<p>还是枚举 $1$ 的约数。</p>
<p>也就是说可以将 $a$ 的表达式化为部分分式求解。</p>
<p>另外，主元法如果求出 $a$ 的表达式中分子次数比分母小的情况了，且规定了 $a$ 为正整数的话，因为“二次跑得比一次快”（二次的增长速度比一次快很多），所以用分子 $\ge$ 分母这个不等式可以卡出很小的范围，方便一个一个讨论。</p>
]]></content>
      <categories>
        <category>whk</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>二次方程</tag>
        <tag>整根问题</tag>
      </tags>
  </entry>
  <entry>
    <title>一次函数的平移及对称点问题</title>
    <url>/2021/01/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0%E7%9A%84%E5%B9%B3%E7%A7%BB%E5%8F%8A%E5%AF%B9%E7%A7%B0%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>博客真是个好东西呢，复习数学也可以在这里总结（</p>
<a id="more"></a>
<h2 id="一次函数与图像平移"><a href="#一次函数与图像平移" class="headerlink" title="一次函数与图像平移"></a>一次函数与图像平移</h2><p>众所周知，一次函数的图像是一条直线。</p>
<p>以函数 $y=2x+3$ 为例：</p>
<p><img src="https://i.loli.net/2021/01/16/TBz2dvPljGaCQXY.png" alt=""></p>
<p>我们把它向下平移一格？</p>
<p><img src="https://i.loli.net/2021/01/16/ySrXALEVRuFejtT.png" alt=""></p>
<p>平移后的函数为 $y=2x+2$。</p>
<p>向上一格？$y=2x+4$。</p>
<p>平移 $k$ 格？$y=2x+(k+3)$</p>
<p>也就是说，我们得到了上下平移的规律：<strong>上加下减</strong>。</p>
<p>左右平移呢？</p>
<p>还是以 $y=2x+3$ 为例，把它向左一格？</p>
<p><img src="https://i.loli.net/2021/01/16/jOy9MRnLbCBtFPD.png" alt=""></p>
<p>平移后的函数为 $y=2x+5$，即 $y=2(x+1)+3$。</p>
<p>向右一格？$y=2(x-1)+3$。</p>
<p>平移 $k$ 格？$y=2(x-k)+3$。</p>
<p>也就是说，我们得到了左右平移的规律：<strong>左加右减</strong>。</p>
<h3 id="左加右减，上加下减就是一次函数平移的规律。"><a href="#左加右减，上加下减就是一次函数平移的规律。" class="headerlink" title="左加右减，上加下减就是一次函数平移的规律。"></a>左加右减，上加下减就是一次函数平移的规律。</h3><p>关于这个是为什么，我简单口胡了个解释。</p>
<p>因为 $y$ 是函数上一个点的 $y$ 坐标，所以往 $y$ 上面加就是往纵坐标上面加。因此上加下减。</p>
<p>左加右减稍微难理解一点。其实可以理解成如果要把一个直线向左平移，对于原直线上的一个点，它平移后的点肯定也向左平移了。但是平移后仅仅是向左平移，纵坐标是不变的。因此想要维持纵坐标不变，需要在横坐标上把平移的消耗给加回来。因此左加右减。</p>
<h2 id="函数的图像与轴对称"><a href="#函数的图像与轴对称" class="headerlink" title="函数的图像与轴对称"></a>函数的图像与轴对称</h2><p>我们探讨一个点关于一条直线的对称点问题。</p>
<p>这玩意好毒瘤啊。。</p>
<h3 id="当直线与坐标轴平行时"><a href="#当直线与坐标轴平行时" class="headerlink" title="当直线与坐标轴平行时"></a>当直线与坐标轴平行时</h3><p>设 $A(x_0,y_0)$，直线为 $x=a$。</p>
<p>则对称点 $B(2a-x_0,y_0)$。</p>
<p>例如：</p>
<p><img src="https://i.loli.net/2021/01/16/qKP7MLzuavsY3cA.png" alt=""></p>
<p>由于 $A$ 到直线的距离等于 $B$ 到直线的距离且 $AB$ 与该直线垂直，而且到直线的距离由于直线与坐标轴平行非常好求，因此我们可以快速得到 $B$ 点的坐标。</p>
<p>同理，当直线为 $y=b$ 时，对称点 $C(x_0,2b-y_0)$。</p>
<h3 id="当直线与坐标轴成-45°-角时"><a href="#当直线与坐标轴成-45°-角时" class="headerlink" title="当直线与坐标轴成 $45°$ 角时"></a>当直线与坐标轴成 $45°$ 角时</h3><p>这个东西的结论比较特殊。</p>
<p>设 $A(x_0,y_0)$，直线为 $y=x+b$。</p>
<p>则对称点为 $B(y_0-b,x_0+b)$。</p>
<p>例如：</p>
<p><img src="https://i.loli.net/2021/01/16/ciQCFdKHw2DL7bx.png" alt=""></p>
<p>若直线为 $y=-x+b$，则对称点为 $C(-y_0+b,-x_0+b)$。</p>
<p>例如：</p>
<p><img src="https://i.loli.net/2021/01/16/yOcELSaoCeWMqQm.png" alt=""></p>
<p>关于这两个东西的证明，我们可以自 $A$ 向该直线作一条垂线，然后倍长它就可以了。</p>
<p>为什么把这两个从一般情况中单拿出来呢？因为这两个东西有比较好的结论，而且有一种很好的记法。</p>
<p>记法：对于 $A(x_0,y_0)$ 与直线 $y=kx+b(k\in\{-1,1\})$，对称点可以写成 $B(\frac{y_0-b}{k},kx_0+b)$。</p>
<p>有人可能会说，这算什么好记？那么我们可以把 $x=x_0$ 与 $y=y_0$ 分别代入进去看看：</p>
<p>若 $x=x_0$，$y=kx+b=kx_0+b$。</p>
<p>若 $y=y_0$，$y_0=kx+b$，$\therefore x=\frac{y_0-b}{k}$。</p>
<p>分别代进去之后，求出的 $x$ 与 $y$ 刚好是该对称点的 $x,y$ 坐标！</p>
<h3 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h3><p>这个东西就不用去记了，计算方法我刚刚也说过：可以自 $A$ 向该直线作一条垂线，然后倍长它就可以了。</p>
<p>但是很烦人就对了…</p>
<p>这里给出结论：对于 $A(x_0,y_0)$ 与直线 $l:y=kx+b$，可以得出 $A$ 关于 $l$ 的对称点</p>
<script type="math/tex; mode=display">B(\frac{(1-k^2)x_0+2ky_0-2kb}{1+k^2},\frac{2kx_0+(k^2-1)y_0+2b}{1+k^2})</script><p>所以我说不用去记…</p>
]]></content>
      <categories>
        <category>whk</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>一次函数</tag>
      </tags>
  </entry>
  <entry>
    <title>FHQ-Treap</title>
    <url>/2021/01/FHQ-Treap/</url>
    <content><![CDATA[<p>期末考试前写这玩意，我危。</p>
<a id="more"></a>
<h1 id="FHQ-Treap"><a href="#FHQ-Treap" class="headerlink" title="FHQ-Treap"></a>FHQ-Treap</h1><h2 id="为啥不旋转了？"><a href="#为啥不旋转了？" class="headerlink" title="为啥不旋转了？"></a>为啥不旋转了？</h2><p>转来转去不可爱！难写难调（较非旋 Treap 而言），结构还不稳定，不能可持久化！</p>
<h2 id="怎么分裂-合并？"><a href="#怎么分裂-合并？" class="headerlink" title="怎么分裂/合并？"></a>怎么分裂/合并？</h2><p>FHQ-Treap 维护值域大概是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//split 函数的作用是将一棵 FHQ-Treap 分裂成权值 &lt;=val 和 &gt;val 的两部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) &#123;x=y=<span class="number">0</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    pushdown(now); <span class="comment">//别忘记 pushdown!</span></span><br><span class="line">    <span class="keyword">if</span>(t[now].val&lt;=val) &#123;</span><br><span class="line">        x=now;</span><br><span class="line">        split(t[now].r,t[x].r,y,val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y=now;</span><br><span class="line">        split(t[now].l,x,t[y].l,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//merge 函数的作用是将两棵左边权值严格比右边小的 FHQ-Treap 按堆权合并成一棵树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(t[x].rnk&lt;t[y].rnk) &#123;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        t[x].r=merge(t[x].r,y);</span><br><span class="line">        pushup(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pushdown(y);</span><br><span class="line">        t[y].l=merge(x,t[y].l);</span><br><span class="line">        pushup(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，FHQ-Treap 还可以用来维护序列。</p>
<p>具体来说，我们不再按照 <code>val</code> 分裂，而是选择按照 <code>size</code> 分裂。这样可以满足其映射的序列的下标满足二叉搜索树性质。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//split 函数的作用是将一棵 FHQ-Treap 分裂成下标 &lt;=k 与 &gt;k 的两部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) &#123;x=y=<span class="number">0</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    pushdown(now); <span class="comment">//别忘记 pushdown!</span></span><br><span class="line">    <span class="keyword">if</span>(t[t[now].l].sz&lt;k) &#123;</span><br><span class="line">        x=now;</span><br><span class="line">        split(t[now].r,t[x].r,y,k-t[t[now].l].sz<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y=now;</span><br><span class="line">        split(t[now].l,x,t[y].l,k);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//merge 函数的作用是将两棵左边下标严格比右边小的 FHQ-Treap 按堆权合并成一棵树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(t[x].rnk&lt;t[y].rnk) &#123;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        t[x].r=merge(t[x].r,y);</span><br><span class="line">        pushup(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pushdown(y);</span><br><span class="line">        t[y].l=merge(x,t[y].l);</span><br><span class="line">        pushup(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他操作？"><a href="#其他操作？" class="headerlink" title="其他操作？"></a>其他操作？</h2><p>可以轮番调用 <code>split</code> 和 <code>merge</code> 来解决。</p>
<p>维护序列可以打标记。</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态开点线段树</title>
    <url>/2020/12/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>今天学校讲了这玩意。算是正式步入省选了。</p>
<p>觉得还不是太熟悉，有必要写一写这篇 blog。</p>
<a id="more"></a>
<h1 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h1><h2 id="Why-to-动态开点？"><a href="#Why-to-动态开点？" class="headerlink" title="Why to 动态开点？"></a>Why to 动态开点？</h2><p>下标太大、节点太多，炸空间。</p>
<p>离散化又需要离线，太麻烦。</p>
<p>于是我们动态地开点，不需要开的点就不开，减少空间开销。</p>
<p>这是开一个点的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=++tot;</span><br><span class="line">    t[p].l=l;t[p].r=r; <span class="comment">//我习惯把 l 和 r 存进结构体里，但是在动态开点线段树中貌似没什么用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// something you want to maintain</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><code>pushup</code> 按照普通线段树写法模仿，把 <code>p&lt;&lt;1</code> 与 <code>p&lt;&lt;1|1</code> 换成 <code>t[p].ls</code> 和 <code>t[p].rs</code> 即可。</p>
<p><code>pushdown</code> 同理。</p>
<p>插入下标为 $[L,R]$ 的区间？这里以最大值为例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=add(l,r);</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;t[p].mx=t[p].tag=x;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    pushdown(p);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; <span class="comment">//特别地，若下标有负数，应使用 l+(r-l&gt;&gt;1)</span></span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) modify(t[p].ls,l,mid,L,R,x);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R) modify(t[p].rs,mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询？这里也以最大值为例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> t[p].mx;</span><br><span class="line">    pushdown(p);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>; <span class="comment">//特别地，若下标有负数，应使用 l+(r-l&gt;&gt;1)</span></span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) ans=max(ans,query(t[p].ls,l,mid,L,R,x));</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R) ans=max(ans,query(t[p].rs,mid+<span class="number">1</span>,r,L,R,x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反正和线段树很像。就是每次到一个点就把它新建一下就行了。</p>
<p>注意有初值的话最大值得用 ST 表处理一波初值。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="CF915E-Physical-Education-Lessons"><a href="#CF915E-Physical-Education-Lessons" class="headerlink" title="CF915E Physical Education Lessons"></a>CF915E Physical Education Lessons</h2><p><del>珂朵莉树好题</del></p>
<p>动态开点。因为 $n$ 太大了，但 $q$ 很小，所以需要开的点很少。</p>
<p>动态开点线段树维护区间和、区间赋值即可。</p>
<h2 id="P5459-BJOI2016-回转寿司"><a href="#P5459-BJOI2016-回转寿司" class="headerlink" title="P5459 [BJOI2016]回转寿司"></a>P5459 [BJOI2016]回转寿司</h2><p>由于这题 $a_i$ 可以为负，于是不能用双指针扫。</p>
<p>考虑使用前缀和。则本题就是要统计满足 $L\le sum_{r}-sum_{l-1}\le R$ 的区间 $[l,r]$ 的个数。</p>
<p>考虑固定 $l$，求有多少种 $r$。</p>
<p>此时的 $r$ 需要满足 $L+sum_{l-1}\le sum_r\le R+sum_{l-1}$。</p>
<p>可以开一个动态开点的权值线段树。从后往前扫一遍，每次加入它自己的 $sum_i$ 之后问线段树中在 $L+sum_{i-1}\sim R+sum_{i-1}$ 范围内的点的个数。</p>
<p><del>也可以离散化后用权值树状数组搞</del></p>
<h2 id="CF817F-MEX-Queries"><a href="#CF817F-MEX-Queries" class="headerlink" title="CF817F MEX Queries"></a>CF817F MEX Queries</h2><p><del>珂朵莉树好题</del></p>
<p>动态开点线段树维护区间推平成 $1$ 或 $0$、区间取反和区间和。</p>
<p>询问就在线段树上二分，看哪里的区间和小于区间中数的个数就往哪里跑。</p>
<h2 id="CF803G-Periodic-RMQ-Problem"><a href="#CF803G-Periodic-RMQ-Problem" class="headerlink" title="CF803G Periodic RMQ Problem"></a>CF803G Periodic RMQ Problem</h2><p>好题。</p>
<p>由于 $n\times k$ 太大了，显然要动态开点。</p>
<p>但是在新建一个节点的时候，我们需要将它的初值赋好。</p>
<p>用一个 ST 表维护一下原序列的区间 $\min$ 用来给开的点赋初值，然后就是区间推平、区间 $\min$ 的动态开点线段树板子了。</p>
<p>特别地，如果开的点经过两个 $n$ 的段（因为题目中 $n$ 循环了 $k$ 次），那么分两段讨论即可。如果开的点跨越了整个段，那么直接用整个序列的 $min$ 来赋初值。</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2020游记</title>
    <url>/2020/12/NOIP2020%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>学校模拟赛血崩，<code>RP--</code>。</p>
<a id="more"></a>
<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>下午被迫自愿去看学校的足球联赛总决赛，是社会实践记中考 1 分。于是 NOIP 前一天的加课集训就被冲了。</p>
<p>于是我们班三个勇士（我、sqrt_7、2x6_81）去找青蛙（我们班主任）请了个假。</p>
<p>青蛙挺好说话的，给我们准假了（让我们先看 10min 开幕式，然后就溜）。于是我们奔向机房。</p>
<p>老师讲了讲一些注意事项和可能踩的坑。同时加了道 Day -1 的模拟赛题的加强版。</p>
<p>晚上发现同学都在码平衡树，就我不会/fad。</p>
<p>看来数据结构真的忘光光了。</p>
<h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>考试日。带了亿些吃的。</p>
<p>然后因为怕迟到提前来了两个小时，天还是黑的，只好在旁边（400m左右）早餐店坐了亿会，背了背对拍板子（没用上）。</p>
<p>先开 T1：这不**题吗？</p>
<p>toposort，加上通分搞定。</p>
<p>看见了 $m$ 的限制，觉得会有很多人因为 $m$ 被卡。</p>
<p>然后是 T2：正解不会，去码了个 $Tn^2$ 的 hash 暴力。</p>
<p>然后就用这暴力去打了会所有字符相同的情况的表。结果 12:30 了都没打出来（期间在看其他题）。</p>
<p>出考场之后发现这 hash 可以轻松优化成 $Tn\log n$。。。</p>
<p>然后去看了看 T3。手玩了亿会发现不会，果断放弃。</p>
<p>T4 先打了个 $30$ pts 的暴力，然后打了个 $k=1$ 的情况。估分 $40$。</p>
<p>然后 12:30 了。回去看 T2 的所有字符相同的情况。</p>
<p>表还没打完，死在那里了。于是我开始推式子。</p>
<p>这式子挺好推的（</p>
<p>然后就开始码</p>
<p>然后开始调</p>
<p>终于调对了！赶快交！诶怎么 13:00 了？？</p>
<p>卡着 13 点整调出了这 8 分。。。要是在其他省估计这 8 分就有了。。可是我们 BJ 是程序回收系统。。考试结束自动关闭提交通道。。。</p>
<p>成功丢掉了这 $8$ pts。现在想想挺可惜的。</p>
<p>估分：$100+48+0+40=188$。</p>
<p>回家看 LA 群里讨论貌似 T1 要用高精？完了。。</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>BJ 选手的代码发了。</p>
<p>Luogu 自测：$90+48+0+30=168$</p>
<p>Oitiku 自测：$90+48+0+30=168$</p>
<p>T4 的 $k=1$ 情况写挂了。沦为与暴力老哥同分。</p>
<p>绵羊神仙 T2 貌似多测不清空，只有 $8$ pts 是稳的，壮烈牺牲。</p>
<p>（不过按照 CCF 数据的尿性应该所有字符串的长度都一样？那绵羊应该还没事。</p>
<h1 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h1><p>$60+48+0+35=143$。</p>
<p>T1 先乘后除死了。</p>
<p>T4 输出 $-1$ 多骗了 $5$ 分。</p>
<h1 id="Day-？？"><a href="#Day-？？" class="headerlink" title="Day ？？"></a>Day ？？</h1><p>由于是初中生，1= $\to$ 4=。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>树学竞赛——NOIP历年树题刷题计划</title>
    <url>/2020/11/%E6%A0%91%E5%AD%A6%E7%AB%9E%E8%B5%9B%E2%80%94%E2%80%94NOIP%E5%8E%86%E5%B9%B4%E6%A0%91%E9%A2%98%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>开了个新坑。。12月NOIP之前争取填完吧。。</p>
<p>目前还剩：P5659 P5024（这两个阴间题目不打算做了，所以算是填完坑了吧）</p>
<a id="more"></a>
<h1 id="P5658-括号树"><a href="#P5658-括号树" class="headerlink" title="P5658 括号树"></a><a href="https://www.luogu.com.cn/problem/P5658" target="_blank" rel="noopener">P5658 括号树</a></h1><p>先考虑一条链的情况。</p>
<p>发现这玩意可以 $\operatorname{O}(n)$ 转移。</p>
<p>然后推广到一棵树上就行了（</p>
<p>转移的细节要考虑一下，然后就没了。</p>
<p>时间复杂度 $\operatorname{O}(n)$ 。</p>
<hr>
<h1 id="P5666-树的重心"><a href="#P5666-树的重心" class="headerlink" title="P5666 树的重心"></a><a href="https://www.luogu.com.cn/problem/P5666" target="_blank" rel="noopener">P5666 树的重心</a></h1><p>一道树上倍增+换根的好题。</p>
<p>首先有一个显而易见的结论就是：一棵树的重心必定在这棵树根节点往下的重链上。</p>
<p>那么就可以倍增跳重链了。</p>
<p><code>dfs</code> 一棵树，考虑删边情况。</p>
<p>删边之后，那个子树很好处理，但是子树以外的部分需要换根解决，讨论即可。</p>
<p>时间复杂度 $\operatorname{O}(n\log n)$。</p>
<p>（貌似有 $\operatorname{O}(n)$ 做法？</p>
<hr>
<h1 id="P5021-赛道修建"><a href="#P5021-赛道修建" class="headerlink" title="P5021 赛道修建"></a><a href="https://www.luogu.com.cn/problem/P5021" target="_blank" rel="noopener">P5021 赛道修建</a></h1><p>看了题，一眼就是二分。</p>
<p>考虑二分这个长度最小的赛道的值，那么题目变成了“能否修建 $m$ 条以上的赛道使得这几条赛道的长度都 $\ge x$ ”。</p>
<p>可以一遍 dfs 解决。</p>
<p>具体来说：对于每个点，它往下可以有若干条没用过的链，那么可以两两拼起来，拼的方式跟<a href="https://www.luogu.com.cn/problem/P1094" target="_blank" rel="noopener">P1094</a>差不多。就是一个爆了，就让它自己待着；否则就两两拼，并且小的和大的拼。拼完之后多余的（太小了或者拼完了剩下了）就取个最大值了返回，在处理父亲节点的时候有用。</p>
<p>这个拼的过程可以用 <code>multiset</code> 维护，总时间复杂度 $\operatorname{O}(n\log^2n)$。</p>
<p>（话说我 #8 被卡T了，吸了氧才过</p>
<hr>
<h1 id="P2680-运输计划"><a href="#P2680-运输计划" class="headerlink" title="P2680 运输计划"></a><a href="https://www.luogu.com.cn/problem/P2680" target="_blank" rel="noopener">P2680 运输计划</a></h1><p>一眼二分题。</p>
<p>二分完了，来一波树上差分随便搞搞。</p>
<p>具体来说：二分一个 $mid$ 表示这个答案要求的最短时间，然后找一遍所有路径中超出要求的，做个差分，找到所有这些路径中都经过的一些边，枚举这些边看看有没有一条边能使得这些路径长度都 $\le mid$ 。</p>
<p>时间复杂度 $\operatorname{O}(n\log \sum t_i+m\log n)$</p>
<hr>
<h1 id="P1351-联合权值"><a href="#P1351-联合权值" class="headerlink" title="P1351 联合权值"></a><a href="https://www.luogu.com.cn/problem/P1351" target="_blank" rel="noopener">P1351 联合权值</a></h1><p>由于要求的点对之间距离为 $2$，于是考虑枚举点对之间的中转点。</p>
<p>对于每个中转点 $u$，它带来的点对的联合权值之和就是 $2$ 倍的所有与它相连的点两两配对的权值乘积之和。</p>
<p>也就是 $\sum_{(u,v)\in E}\sum_{(u,w)\in E, w\not =v}W_vW_w$。</p>
<p>这玩意可以通过完全平方公式转化成：$(\sum_{(u,v)\in E} W_v)^2-\sum_{(u,v)\in E} W_v^2$ 。</p>
<p>扫一遍每个点为中转点的情况，最后求和即可。</p>
<p>关于最大值就对于每个中转点找两个 $W$ 最大的点求联合权值，最后取 $\max$ 即可。</p>
<p>可以 $\operatorname{O}(n)$ 解决。</p>
<hr>
<h1 id="P1099-树网的核"><a href="#P1099-树网的核" class="headerlink" title="P1099 树网的核"></a><a href="https://www.luogu.com.cn/problem/P1099" target="_blank" rel="noopener">P1099 树网的核</a></h1><p>$\operatorname{O}(n^3)$ 暴力随便艹过去。。</p>
<p>先 <code>floyd</code> 一下，然后随便暴力枚举就过了。。。</p>
<hr>
<h1 id="P7073-表达式"><a href="#P7073-表达式" class="headerlink" title="P7073 表达式"></a><a href="https://www.luogu.com.cn/problem/P7073" target="_blank" rel="noopener">P7073 表达式</a></h1><p>众所周知，后缀表达式可以 $\operatorname{O}(n)$ 用一个栈求解，而且可以建一棵树。</p>
<p>那么可以把题目中的后缀表达式先建一个树出来，算出每个点子树的答案。</p>
<p>接着对于每个点 $i$ 考虑一下改变它会不会影响上面它父亲节点的结果，可以根据之前算出的答案以及它父亲的运算符来求。开一个 <code>bool</code> 数组记为 $can_i$。</p>
<p>那么对于每一个 $x_i$，如果从根节点到它的路径上所有点的 $can$ 值都为 $1$ 的话，那么改变 $x_i$ 就会改变最终结果。否则不会改变最终结果。具体实现可以对每一条根节点到叶子节点的路径都做一个 $can$ 的前缀和来解决。</p>
<p>时间复杂度 $\operatorname{O}(n+q)$。</p>
<hr>
<h1 id="P5689-多叉堆"><a href="#P5689-多叉堆" class="headerlink" title="P5689 多叉堆"></a><a href="https://www.luogu.com.cn/problem/P5689" target="_blank" rel="noopener">P5689 多叉堆</a></h1><p>算是一个树（森林？）题吧。</p>
<p>其实是 <del>树</del> 数学题。</p>
<p>用并查集维护每个树根，然后对于每棵树，令 $ans_i$ 表示以 $i$ 为根的树的答案，$sz_i$ 表示以 $i$ 为根的树的大小。</p>
<p>那么当把以 $x$ 为根的树插进以 $y$ 为根的树中时，$ans_y=ans_y\times ans_x\times\operatorname{C}_{sz_y+sz_x-1}^{sz_x}$。然后更新 $sz_y=sz_y+sz_x$。</p>
<p>对于组合数，可以预处理阶乘和阶乘的逆元来算。利用公式 $C_m^n=\frac{m!}{n!(m-n)!}$ 求解。</p>
<hr>
<h1 id="P1600-天天爱跑步"><a href="#P1600-天天爱跑步" class="headerlink" title="P1600 天天爱跑步"></a><a href="https://www.luogu.com.cn/problem/P1600" target="_blank" rel="noopener">P1600 天天爱跑步</a></h1><p>神仙树上差分题。</p>
<p>这是几个月之前做的。详细见<a href="https://blog.henrytb.ml/2020/03/%E9%A2%98%E8%A7%A3-LuoguP1600-NOIP2016-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5">我的题解</a></p>
<hr>
<h1 id="P1967-货车运输"><a href="#P1967-货车运输" class="headerlink" title="P1967 货车运输"></a><a href="https://www.luogu.com.cn/problem/P1967" target="_blank" rel="noopener">P1967 货车运输</a></h1><p>这题是好久好久之前写的呢。</p>
<p>一句话题解：在最大生成树上跑 $\operatorname{lca}$。</p>
<p>没啥好说的。</p>
<hr>
<h1 id="P1084-疫情控制"><a href="#P1084-疫情控制" class="headerlink" title="P1084 疫情控制"></a><a href="https://www.luogu.com.cn/problem/P1084" target="_blank" rel="noopener">P1084 疫情控制</a></h1><p>可以推出一个显而易见的结论：军队一定要往上移动。</p>
<p>而且时间这个东西可以二分。</p>
<p>那么问题变成：在规定时间内，能不能控制疫情？</p>
<p>首先尽可能把军队往上移，然后看看能不能移到 $1$ 这个点。</p>
<p>如果不行，那么就让它留在这里。</p>
<p>如果可以的话，分以下情况讨论：</p>
<ol>
<li>能到 $1$ 号节点但是回不来了：还不如就让它呆在这里呢</li>
<li>能去别的节点：把所有的需要军队的根节点的叶子节点求出来，然后把它们到根的距离开一个数组存。再把能去别的节点的所有军队的剩余时间都存进另一个数组，跑个双指针，就做完了。</li>
</ol>
<hr>
<h1 id="完结撒花✿✿ヽ-°▽°-ノ✿"><a href="#完结撒花✿✿ヽ-°▽°-ノ✿" class="headerlink" title="完结撒花✿✿ヽ(°▽°)ノ✿"></a>完结撒花✿✿ヽ(°▽°)ノ✿</h1>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
        <tag>水题选做</tag>
        <tag>NOIP</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S2 2020 游记</title>
    <url>/2020/11/CSP-S2-2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>去北师大附实验了，带了点吃的。</p>
<a id="more"></a>
<hr>
<p>进入考场，看见了 2 个同校神仙，rp++。</p>
<p>开机密码 <code>daydayup</code>，解压密码…老师敲错了好多遍，后来发现把大写的 I 看成 1 或 l 了。。。</p>
<p>进来看题！</p>
<p>T1：smwy，CCF我$<em>$你$*</em>$</p>
<p>没关系，不着急，慢慢来。</p>
<p>于是我分了4类讨论 T1 的日期：</p>
<ol>
<li>公元前的</li>
<li>公元后儒略历的</li>
<li>儒略历结束那一年年末（讨论这个纯属是因为我懒</li>
<li>儒略历结束的下一年开始的</li>
</ol>
<p>然后除了第三类以外每一类来个二分。。要吐血了。。</p>
<p>1h 肝完了这道题。。</p>
<p>代码冗长，详见我的T1题解（还咕着</p>
<p>T2：哦哦这题挺良心的</p>
<p>30min 搞完了</p>
<p><del>然后出考场发现不开ull见祖宗了</del></p>
<p>T3：这又是啥</p>
<p>好像是个 DAG，topsort？</p>
<p>先写了个暴力，不知道为啥样例RE了，先去看T4了。</p>
<p>T4：“看起来”挺简单</p>
<p>实际上。。。</p>
<p>不会处理“我吃了你我会变成最短的，但是最长的不敢吃我”的这种情况。。想了半天浪费了好多时间。。</p>
<p>20pts，滚了</p>
<p>回去看T3，时间不多了。</p>
<p>调那个RE，调啊调，考试结束前 1min 最后发现有个地方 <code>j</code> 写成 <code>i</code> 了。。。</p>
<p>在考试结束前 <code>30s</code> 交了题。。</p>
<p>测完样例，过了，然后发现已经到点了。</p>
<p>危险操作，请勿模仿！</p>
<p>出了考场，估分 $100+100+20+20=240$</p>
<hr>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>然后在各大 OJ 上自测。。</p>
<ul>
<li>oitiku $100+70+10+20$</li>
<li>LG $100+60+5+25$</li>
<li>牛客 $100+65+0+20$</li>
</ul>
<p>T2 不开ull见祖宗了，$100\to (60\sim100)$。</p>
<p>T3 不知道哪里挂了，$20\to (0\sim20)$</p>
<p>T2 又搞这种 $k\le 64$ 的恶心玩意，jbl。。</p>
<p>等 CCF 吧。</p>
<hr>
<h1 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h1><p>CCF 数据出了。</p>
<p>$100+75+10+20=205$。一等了。</p>
<p>莫名感觉今年 1= 有手就行？</p>
<h1 id="Day-？？"><a href="#Day-？？" class="headerlink" title="Day ？？"></a>Day ？？</h1><p>最终排名出了。比去年没进步多少。</p>
<p>但是卡线 $205$ 拿到了 $7$ 级蓝勾！开心！</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1175E Minimal Segment Cover</title>
    <url>/2020/11/%E9%A2%98%E8%A7%A3-CF1175E-Minimal-Segment-Cover/</url>
    <content><![CDATA[<p>我们先考虑一下一道“缩水版”的题目。</p>
<blockquote>
<p>已知数轴上有一个区间，左端点记为 $L$，右端点记为 $R$，以及 $n$ 条线段 $s_i$，请问在 $n$ 条线段中最少选择多少条，可以把区间完全覆盖（包括 $L$ 点和 $R$ 点）。</p>
</blockquote>
<a id="more"></a>
<p>我们可以定义 $f_i$ 表示从 $i$ 这个点，通过一条线段能到达的最右的点。</p>
<p>实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rep(i,<span class="number">1</span>,MAXR) f[i]=i; <span class="comment">//MAXR是值域</span></span><br><span class="line">rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">    f[s[i].l]=max(f[s[i].l],s[i].r);</span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">0</span>,MAXR) f[i]=max(f[i],f[i<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure>
<p>然后暴力从 $L$ 开始跳 $f$ 即可。</p>
<p>如果遇到了 $f_i=i$ 且 $i&lt;R$ 的情况，那么无解。</p>
<p>跳到 $R$ 以后 <code>break</code> 掉循环。</p>
<p>那么可以来看这道题目了。如果说要优化一次询问的过程呢？</p>
<p>可以倍增！设 $f_{i,j}$ 表示从 $i$ 这个点通过 $2^j$ 个线段能到达的最右的点。</p>
<p>这样一次询问我们就优化成了 $O(\log n)$，可以通过本题。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>,MAXL=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fare[MAXL][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> mxr=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        fare[l][<span class="number">0</span>]=max(fare[l][<span class="number">0</span>],r);</span><br><span class="line">        mxr=max(mxr,r);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">0</span>,mxr) fare[i][<span class="number">0</span>]=max(fare[i][<span class="number">0</span>],fare[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">    rep(j,<span class="number">1</span>,<span class="number">21</span>) rep(i,<span class="number">0</span>,mxr) &#123;</span><br><span class="line">        fare[i][j]=fare[fare[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">        per(j,<span class="number">21</span>,<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fare[x][j]&lt;y) &#123;</span><br><span class="line">                ans+=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                x=fare[x][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fare[x][<span class="number">0</span>]&gt;=y) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF689D Friends and Subsequences</title>
    <url>/2020/10/%E9%A2%98%E8%A7%A3-CF689D-Friends-and-Subsequences/</url>
    <content><![CDATA[<p>在这里介绍一个防止二分写挂的神仙方法（今天教练介绍的2333</p>
<a id="more"></a>
<p>我们先枚举一个左端点，发现随着右端点的增长，$\min$ 值单调递减，$\max$ 值单调递增。</p>
<p>于是可以二分一下这个右端点的可能区间。具体就二分一下右端点区间的左端和右端点区间的右端即可。使用 ST 表优化查询区间 $\min$、$\max$ 值的速度。</p>
<p>但是，这个二分很容易<strong>写挂</strong>！</p>
<p>怎么办？</p>
<p>我们索性不考虑二分的边界啥的，在 $l$ 与 $r$ 距离很小的时候就跳出二分，然后暴力地在这个 $l$ 和 $r$ 之间找一下即可！</p>
<p>这样可以减少很多细节的考虑！方便考场调试代码！</p>
<p>具体见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> mn[N][<span class="number">22</span>],mx[N][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]),mx[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b[i]),mn[i][<span class="number">0</span>]=b[i];</span><br><span class="line">    rep(j,<span class="number">1</span>,<span class="number">21</span>) &#123;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))<span class="number">-1</span>&gt;n) mx[i][j]=mx[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> mx[i][j]=max(mx[i][j<span class="number">-1</span>],mx[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(j,<span class="number">1</span>,<span class="number">21</span>) &#123;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))<span class="number">-1</span>&gt;n) mn[i][j]=mn[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> mn[i][j]=min(mn[i][j<span class="number">-1</span>],mn[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">int</span> l=i,r=n;</span><br><span class="line">        <span class="keyword">int</span> rr=<span class="number">0</span>,ll=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r-l&gt;<span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//printf("de:%lld %lld %lld\n",l,r,mid);</span></span><br><span class="line">            <span class="keyword">int</span> lg=log2(mid-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> mxx=max(mx[i][lg],mx[mid-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">int</span> mnn=min(mn[i][lg],mn[mid-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">if</span>(mxx&gt;mnn) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        per(j,r,l) &#123;</span><br><span class="line">            <span class="keyword">int</span> lg=log2(j-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> mxx=max(mx[i][lg],mx[j-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">int</span> mnn=min(mn[i][lg],mn[j-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">if</span>(mxx==mnn) &#123;rr=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l=i,r=n;</span><br><span class="line">        <span class="keyword">while</span>(r-l&gt;<span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> lg=log2(mid-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> mxx=max(mx[i][lg],mx[mid-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">int</span> mnn=min(mn[i][lg],mn[mid-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">if</span>(mxx&gt;=mnn) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(j,l,r) &#123;</span><br><span class="line">            <span class="keyword">int</span> lg=log2(j-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> mxx=max(mx[i][lg],mx[j-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">int</span> mnn=min(mn[i][lg],mn[j-(<span class="number">1</span>&lt;&lt;lg)+<span class="number">1</span>][lg]);</span><br><span class="line">            <span class="keyword">if</span>(mxx==mnn) &#123;ll=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ll&amp;&amp;rr) ans+=(rr-ll+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S1 2020 游记</title>
    <url>/2020/10/CSP-S1-2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>临阵擦枪了一波。感觉要炸</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上和同学一块坐车去首师大附中。</p>
<p>路上聊了大半路的雀魂和小半路的初赛。</p>
<hr>
<p>北洼路还是那么堵，提前下车走了几百米进了考点。</p>
<p>进考场，拿到试卷，看了一眼：</p>
<ul>
<li>单选很简单的样子</li>
<li>阅读程序题好像第一个程序挺简单，第二个有点难懂，第三个什么玩意？</li>
<li>完善程序是一个部分背包和一个状压dp，感觉部分背包在送分</li>
</ul>
<hr>
<p>开始答题了。</p>
<p>单选飞快地做完了，rp++（然后出考场之后发现自己爬楼梯那道题忘+1了，我是**）</p>
<hr>
<p>然后开始肝阅读程序。。。</p>
<p>第一个程序挺简单的，火速做完（然后对完答案后发现第一道判断题就错了，小于看成小于等于。。）</p>
<p>第二个程序嘛。。。</p>
<p>我<em>**</em>！</p>
<p>好像是个随机化 <code>nth_element</code> ？费了好大劲才做完。</p>
<p>然后出去对答案时发现单调递减和 $d[i]$ 为 $i$ 那两个复杂度分析都错了。。。wtcl</p>
<p>第三个程序：CCF nb！这手写map $\operatorname{O}(n^2)$ 笑死我了（<code>string</code> 比较是 $\operatorname{O}(n)$ 的）。。</p>
<blockquote>
<p>“CCF 教你手写 STL”.jpg</p>
</blockquote>
<p>然后时间复杂度 $\operatorname{O}(n!)$ 看起来很对，然后就打钩，然后就错了</p>
<p>第 6 题那个选择基本上是蒙的，错了</p>
<p>不过，第 5 题那个数列，找规律 nb，构造 辣鸡。花了几 min <del>大眼观察法</del>找出了规律，成就感++。</p>
<p>第三个程序做题耗时极长。。</p>
<hr>
<p>然后是完善程序。。</p>
<p>分数背包果然送分，回家对答案发现自己全对</p>
<p>状压 dp 那题感觉比去年简单，但还是错了俩</p>
<p>做完感觉完善程序比阅读程序轻松好多。。</p>
<hr>
<p>出考场，和另一个同学坐车，也聊了一路的雀魂。</p>
<p>回到家，对答案，估分 80。</p>
<p>估计能过。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF472D Design Tutorial: Inverse the Problem</title>
    <url>/2020/10/%E9%A2%98%E8%A7%A3-CF472D-Design-Tutorial-Inverse-the-Problem/</url>
    <content><![CDATA[<p>这道题挺好玩的。</p>
<a id="more"></a>
<p>先按照题目建一个以“树上两点之间距离”为边权的图，然后跑一遍最小生成树。</p>
<p>由于这张以“树上两点之间距离”为边权的图对应的树（不是刚刚求的生成树）上两个点之间只有一条路径，于是，我们可以枚举生成树上任意两个点看看这两个点在生成树上的距离和它们两个点在以“树上两点之间距离”图（就是题目给的那个邻接矩阵）上面之间的边权一不一样。如果不一样的话就不能对应一棵树。</p>
<p>可以暴力或者 <code>LCA</code> 做。</p>
<p>注意特判！</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x]==x?fa[x]:fa[x]=find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> target[<span class="number">4005</span>],pre[<span class="number">4005</span>],last[<span class="number">2005</span>],w[<span class="number">4005</span>],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> ww)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">    w[tot]=ww;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> used[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> fir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(target[ptr]!=fa) &#123;</span><br><span class="line">            dis[fir][target[ptr]]=dis[fir][u]+w[ptr];</span><br><span class="line">            dfs(target[ptr],u,fir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">bool</span> flg=<span class="number">1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) rep(j,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w);</span><br><span class="line">        <span class="keyword">if</span>(w!=<span class="number">0</span>) flg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) e[++m].u=i,e[m].v=j,e[m].w=w,mp[i][j]=mp[j][i]=w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w!=<span class="number">0</span>) &#123;<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j]!=w) &#123;<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flg&amp;&amp;n!=<span class="number">1</span>) &#123;<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) fa[i]=i;</span><br><span class="line">    sort(e+<span class="number">1</span>,e+m+<span class="number">1</span>,cmp);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=find(e[i].u),v=find(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u!=v) &#123;</span><br><span class="line">            add(e[i].u,e[i].v,e[i].w);</span><br><span class="line">            add(e[i].v,e[i].u,e[i].w);</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            used[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) dfs(i,<span class="number">0</span>,i);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=e[i].u,v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(dis[u][v]!=e[i].w) &#123;<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2020 游记</title>
    <url>/2020/08/WC2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>家里蹲。</p>
<p>明天就是人生第一次 WC 经历，感觉好紧张。。。</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>事实上，没什么好紧张的。</p>
<h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>看了看课表。</p>
<p>第二课堂讲线段树，感觉会比较难吧。</p>
<p>结果进去一看，从零开始讲线段树。。。</p>
<p>去第一课堂硬着头皮听了一会。。。又太难了听不下去。。。</p>
<p>很自闭，全程掉线。</p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>算法优化？？听听吧</p>
<p>怎么在讲二分啊？？</p>
<p>最后居然还讲了个网络流+二分的毒瘤题hhh</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><p>第二课堂是“图论中的相关算法”，听听吧。</p>
<p>草，一个上午才讲到最小生成树？？？</p>
<p>第一课堂什么神仙玩意？？？</p>
<h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2><p>“分治思想及其应用”，听听吧，说不定有 cdq、整体二分啥的。</p>
<p>还真有，赚了赚了</p>
<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><h2 id="上午-2"><a href="#上午-2" class="headerlink" title="上午"></a>上午</h2><p>第二课堂讲生成函数，几乎全程掉线。</p>
<h2 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h2><p>“从零开始学动态规划算法”。</p>
<p>这节课还不错。</p>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="上午-3"><a href="#上午-3" class="headerlink" title="上午"></a>上午</h2><p>只剩下第一课堂了，硬着头皮听吧。</p>
<p>“随机思想在 OI 中的应用”？</p>
<p>刚开始的时候：讲概率论啊。</p>
<p>然后后来就越来越变态，接着我就爬了。。</p>
<h2 id="下午-3"><a href="#下午-3" class="headerlink" title="下午"></a>下午</h2><p>讲爆搜的，这个还算能听。</p>
<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>考试日。</p>
<p>时间严重不足。</p>
<p>先看 T1。</p>
<p>感觉好神仙啊，看看测试点。</p>
<p><img src="/pics/1.png" alt=""></p>
<p>于是我就先敲了个 $O(n+qn\log n)$ 的暴力，10 分。</p>
<p>而且感觉后面的特殊性质很好玩的样子…</p>
<p>先看 T2 去。</p>
<p>T2 这题意有毒吧。。。还好有样例解释。。。</p>
<p>看了看，好像只会写暴力。</p>
<p>于是打了个 20 分的 $O(2^n)$ 做法。</p>
<p>去看 T3。</p>
<p>T3 先尝试写了一下 $N\le 1000$，$p=0$ 的背包，然后写挂了。。。过了很久还是没调出来，放弃。</p>
<p>然后写了一下 T3 的 $w_i=1$，$p=0$ 的做法，这个写对了。</p>
<p>暴力看了一下，很复杂，于是我先回去玩 T1 的特殊性质。</p>
<p>T1 这特殊性质我貌似只能搞出来一条链的情况，我太菜了。。。</p>
<p>而且还用了一个特别 sb 的方法搞，我居然写了个二分+树状数组。。。明明一个 $\lceil \frac{size_S}{2}\rceil$ 的事就能搞定。。。</p>
<p>wssb。不过写对了是写对了，T1 现在有 $20$ 分了。</p>
<p>然后去看 T3 暴力了，写了半天。然后到只剩半个小时的时候终于写出来了，于是我开始调试。</p>
<p>结果没调出来。。。</p>
<p>GG。。。</p>
<p>估分：$20+20+10=50$ 。感觉这次要拿 Fe 了。</p>
<p>smy 神仙估分 $10+20+20=50$，xcs 神仙貌似考炸了，估分 $10+0+0$。</p>
<p>下午讲题的时候，发现自己并没有听懂。</p>
<h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><h2 id="上午-4"><a href="#上午-4" class="headerlink" title="上午"></a>上午</h2><p>一上午的往年 NOI 选手交流，几乎全程摸鱼。</p>
<p>smy 神仙颓了很久的 tr，我颓了很久 OI-wiki 。</p>
<h2 id="下午-4"><a href="#下午-4" class="headerlink" title="下午"></a>下午</h2><p>要出成绩了。。。</p>
<p>首先是总的数据。$Au$ 线 $130$，$Ag$ 线 $75$，$Cu$ 线 $35$ 。</p>
<p>诶，感觉可以拿个 $Cu$ ？</p>
<p>然后是教学比赛的颁奖，感觉越来越紧张。。。</p>
<p>终于，到了选手颁奖的时候。</p>
<p>第一个公布的名单就是 $Cu$。</p>
<p>第 $2$ 页出现了 smy 神仙的名字！！smy $35$ 分 $Cu$！！！</p>
<p>然后紧接着，$40$……$45$……好多页，都没有我的名字。</p>
<p>随着页数的增加，公布的分数也离我的理论最高分越来越近……</p>
<p>我越来越紧张，越来越担心自己会挂分，甚至能听见我的心跳。</p>
<p>到了 $50$ 分的第一页，还是没有我的名字。</p>
<p>我焦急地等待着主持人把这页念完，主持人翻到了下一页。</p>
<p>我一眼就在中间看见了我的名字，我没挂分！！！$Cu$ get！</p>
<p>人生第一个奖牌，拿到了！</p>
<p>最终得分：smy $5+10+20=35$，我 $20+20+10=50$。</p>
<p>我现在还震惊我居然 $1$ 分没挂…</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年 8 月水题选做</title>
    <url>/2020/08/8%E6%9C%88%E6%B0%B4%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<p>这么快就 8 月了呢…</p>
<a id="more"></a>
<h1 id="8-1"><a href="#8-1" class="headerlink" title="8/1"></a>8/1</h1><p><a href="https://www.luogu.com.cn/problem/CF875F" target="_blank" rel="noopener">$\color{green}{\text{CF875F}}$</a></p>
<p>又一道想出结论之后就非常简单的题。</p>
<p>考虑把王子当成点，公主当成边，然后就求个最大生成基环树就好了。</p>
<p>求法魔改一下 <code>Kruskal</code> 就完事了。</p>
<h1 id="8-2"><a href="#8-2" class="headerlink" title="8/2"></a>8/2</h1><p>打了人生第一场 atcoder 。</p>
<h2 id="ABC-174"><a href="#ABC-174" class="headerlink" title="ABC 174"></a>ABC 174</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>sb 题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">30</span>)<span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>sb 题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;d);</span><br><span class="line">rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">double</span> k=<span class="built_in">sqrt</span>(<span class="number">1.0</span>*x*x+<span class="number">1.0</span>*y*y);</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=d)++ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br></pre></td></tr></table></figure>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>考虑模数周期性，然后这就是道 sb 题了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    mo=<span class="number">7</span>%k;</span><br><span class="line">    used[mo]=<span class="number">1</span>;<span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(mo!=<span class="number">0</span>) &#123;</span><br><span class="line">        ++ans;</span><br><span class="line">        mo*=<span class="number">10</span>;mo+=<span class="number">7</span>;</span><br><span class="line">        mo%=k;</span><br><span class="line">        <span class="keyword">if</span>(used[mo]) &#123;flg=<span class="number">1</span>;<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">        used[mo]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flg)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>考虑贪心。把所有的 R 移到它该移的位置（前面）即可。根本用不上改变颜色的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==<span class="string">'R'</span>) ++r;</span><br><span class="line">&#125;</span><br><span class="line">k=r;</span><br><span class="line">rep(i,<span class="number">1</span>,r) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==<span class="string">'R'</span>) --k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k);</span><br></pre></td></tr></table></figure>
<h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h3><p>二分。二分完了 <code>check</code> 随便写写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">int</span> kk=a[i]/x;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%x==<span class="number">0</span>) kk--;</span><br><span class="line">        now+=kk;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]),mx=max(mx,a[i]);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=mx;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h3><p>HH 的项链。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">rep(i,<span class="number">1</span>,m) asks[i].id=i,<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;asks[i].l,&amp;asks[i].r);</span><br><span class="line">sort(asks+<span class="number">1</span>,asks+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">    rep(j,now,asks[i].r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[a[j]]) modify(used[a[j]],<span class="number">-1</span>);</span><br><span class="line">        modify(j,<span class="number">1</span>);</span><br><span class="line">        used[a[j]]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[asks[i].id]=query(asks[i].r)-query(asks[i].l<span class="number">-1</span>);</span><br><span class="line">    now=asks[i].r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br></pre></td></tr></table></figure>
<h3 id="切题顺序：A-B-D-E-F-C"><a href="#切题顺序：A-B-D-E-F-C" class="headerlink" title="切题顺序：A-B-D-E-F-C"></a>切题顺序：A-B-D-E-F-C</h3><p>就这样愉快地 AK 了。</p>
<h1 id="8-3"><a href="#8-3" class="headerlink" title="8/3"></a>8/3</h1><p><a href="https://www.luogu.com.cn/problem/CF165D" target="_blank" rel="noopener">$\color{green}{\text{CF165D}}$</a></p>
<p>树剖裸题，只是因为有点忘记树剖怎么写了来练练手而已。</p>
<h1 id="8-5"><a href="#8-5" class="headerlink" title="8/5"></a>8/5</h1><p>晚上 CF 爆炸了。。。</p>
<h1 id="8-6"><a href="#8-6" class="headerlink" title="8/6"></a>8/6</h1><p>愉快的叉了几个同学昨天 CF 的 C 题。</p>
<p><a href="https://www.luogu.com.cn/problem/P3950" target="_blank" rel="noopener">$\color{green}{\text{P3950}}$</a></p>
<p>裸树剖题，很久以前写了但一直没调出来，今天调出来了。</p>
<p>原来是在跳重链的时候出了点锅。</p>
<h1 id="8-7"><a href="#8-7" class="headerlink" title="8/7"></a>8/7</h1><p><a href="https://www.luogu.com.cn/problem/P2787" target="_blank" rel="noopener">$\color{red}{\text{P2787}}$</a></p>
<p>开 26 棵线段树即可，但是不知道哪里写炸了全 WA。。。</p>
<p>另外，这题本来我想用珂朵莉树水的，结果发现它卡珂朵莉树。。。</p>
<h1 id="8-8"><a href="#8-8" class="headerlink" title="8/8"></a>8/8</h1><p><a href="https://www.luogu.com.cn/problem/P2837" target="_blank" rel="noopener">$\color{green}{\text{P2837}}$</a></p>
<p><del>不要说我做水题，是老师布置的</del></p>
<p>简单的线性 dp，设 $f_{i,0}$ 表示前 $i$ 头奶牛，第 $i$ 头奶牛是 $1$ 时需要改的最小数量， $f_{i,1}$ 则反之。</p>
<h1 id="8-9"><a href="#8-9" class="headerlink" title="8/9"></a>8/9</h1><p><a href="https://www.luogu.com.cn/problem/P2642" target="_blank" rel="noopener">$\color{green}{\text{P2642}}$</a></p>
<p>预处理一下前缀的最大子段和、后缀的最大子段和，然后枚举断点统计一下答案即可。</p>
<p><a href="https://www.luogu.com.cn/problem/P1982" target="_blank" rel="noopener">$\color{green}{\text{P1982}}$</a></p>
<p><del>人生苦短，我用 python</del></p>
<p>按照题意求一下前缀最大子段和，然后模拟一下。</p>
<p>但是会爆 <code>long long</code>，于是我们用 <del>python</del> 高精就能解决这道题目。</p>
<p><a href="https://www.luogu.com.cn/problem/P1043" target="_blank" rel="noopener">$\color{green}{\text{P1043}}$</a></p>
<p>简单区间 dp。</p>
<p>断环成链，设 $f_{i,j,k}$ 表示从第 $i$ 位到第 $j$ 位，分 $k$ 段得到的最大值。</p>
<p>然后设 $g_{i,j,k}$ 表示从第 $i$ 位到第 $j$ 位，分 $k$ 段得到的最小值。</p>
<p>随便转移转移就好了。</p>
<h2 id="Codeforces-Round-663-Div-2"><a href="#Codeforces-Round-663-Div-2" class="headerlink" title="Codeforces Round 663 (Div. 2)"></a>Codeforces Round 663 (Div. 2)</h2><p>今天打了场 CF。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1391A" target="_blank" rel="noopener">$\color{green}{\text{CF1391A}}$</a></p>
<p>发现 $1\sim n$ 即是合法的序列，直接输出即可。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1391B" target="_blank" rel="noopener">$\color{green}{\text{CF1391B}}$</a></p>
<p>找到右侧的 <code>R</code> 与下侧的 <code>D</code>，统计一下。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1391C" target="_blank" rel="noopener">$\color{green}{\text{CF1391C}}$</a></p>
<p>OEIS nb！</p>
<p>手玩一下，然后在 OEIS 上查 <code>0,0,2,6</code> 即可（</p>
<p>然后发现答案是 $n!-2^{n-1}$。</p>
<h1 id="8-10"><a href="#8-10" class="headerlink" title="8/10"></a>8/10</h1><p><a href="https://www.luogu.com.cn/problem/P5662" target="_blank" rel="noopener">$\color{green}{\text{P5662}}$</a></p>
<p>哈哈哈我发现我居然还没把去年 PJ AK掉。</p>
<p>大水题，对于每天都与后一天做差跑个完全背包就好了。</p>
<p><a href="https://www.luogu.com.cn/problem/P2871" target="_blank" rel="noopener">$\color{green}{\text{P2871}}$</a></p>
<p>背包裸题。</p>
<p><a href="https://www.luogu.com.cn/problem/P1164" target="_blank" rel="noopener">$\color{green}{\text{P1164}}$</a></p>
<p>背包裸题。</p>
<p><a href="https://www.luogu.com.cn/problem/P2639" target="_blank" rel="noopener">$\color{green}{\text{P2639}}$</a></p>
<p>背包裸题。<del>话说老师为啥留这么多裸题</del></p>
<p><a href="https://www.luogu.com.cn/problem/P1802" target="_blank" rel="noopener">$\color{green}{\text{P1802}}$</a></p>
<p>还是背包裸题。。。</p>
<p><a href="https://www.luogu.com.cn/problem/P1877" target="_blank" rel="noopener">$\color{green}{\text{P1877}}$</a></p>
<p><code>bool</code> 数组的背包 dp。</p>
<p><a href="https://www.luogu.com.cn/problem/P1510" target="_blank" rel="noopener">$\color{green}{\text{P1510}}$</a></p>
<p>还是背包裸题。。</p>
<p><a href="https://www.luogu.com.cn/problem/P1504" target="_blank" rel="noopener">$\color{green}{\text{P1504}}$</a></p>
<p>用背包看看哪些高度所有的城堡都能达到，然后取个最高的。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>luogu</tag>
        <tag>题解</tag>
        <tag>水题选做</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF506D Mr. Kitayuta&#39;s Colorful Graph</title>
    <url>/2020/07/%E9%A2%98%E8%A7%A3-CF506D-Mr-Kitayuta-s-Colorful-Graph/</url>
    <content><![CDATA[<p>神仙题。</p>
<p>暴力+暴力=AC。</p>
<p>没错，先想出两个暴力，然后拼起来，你就 AC 了这道题。</p>
<p><strong>用分块来选择用哪个暴力，可能也是一种正解的做法。</strong></p>
<a id="more"></a>
<p>首先我们能想到最无脑的暴力 1 。</p>
<h2 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力 1"></a>暴力 1</h2><p>对于每种颜色建一个仅含有这一种颜色的边的图，然后用并查集判连通，扫一次所有询问统计贡献。</p>
<p>时间复杂度：首先 $\operatorname{O}(m)$ 的枚举颜色，然后 $\operatorname{O}(n\alpha(n))$ 的建图+并查集（其实建图可以不用，直接并查集就够了），再加上 $\operatorname{O}(q\alpha(n))$ 的处理询问。总时间复杂度 $\operatorname{O}(m\alpha(n)(n+q))$ 。</p>
<p>这显然是过不了这道题的，那么我们再来想另一个暴力。</p>
<h2 id="暴力-2"><a href="#暴力-2" class="headerlink" title="暴力 2"></a>暴力 2</h2><p>其实只是对暴力 1 的一点修改。</p>
<p>对于每种颜色建一个仅含有这一种颜色的边的图，然后用并查集判连通，在每个连通块内枚举所有的点对 $(u,v)$ ，更新 $(u,v)$ 这个点对的贡献。</p>
<p>这个东西在连通块很小（连通块大小的平方小于 $q$ ）的时候会比暴力 1 更优一些。</p>
<p>时间复杂度：首先 $\operatorname{O}(m)$ 的枚举颜色，然后 $\operatorname{O}(n\alpha(n))$ 的建图+并查集（其实建图可以不用，直接并查集就够了），然后 $\operatorname{O}(n^2\alpha(n))$ 的算贡献。总时间复杂度 $\operatorname{O}(mn^2\alpha(n))$。</p>
<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>那么，我们就想到：可不可以在连通块大小的平方小于 $q$ 的时候用暴力 2 ，而在连通块大小的平方大于 $q$ 的时候再用暴力 1 呢？</p>
<p>当然可以。</p>
<p>什么时候一个颜色的图中每个连通块大小的平方都小于 $q$ ？</p>
<p>在 该颜色边数 $&lt;\sqrt{m}$ 的时候，所有这种颜色的所有连通块内点数的平方和不会超过 $n\sqrt n$ 。</p>
<p>于是，暴力 2 就可以胜任这部分的任务，复杂度 $\operatorname{O}(n\alpha(n)\sqrt n)$。</p>
<p>在 该颜色边数 $\ge\sqrt{m}$ 的时候，我们就可以用暴力 1 ，因为此时满足这种情况的颜色数量只会 $\le\sqrt m$。这样的话再扫一遍所有询问，复杂度是 $\operatorname{O}(\sqrt m(q\alpha(q)))$ 的。</p>
<p>这样，两个暴力拼起来，就打出了正解。</p>
<p>考虑实现统计答案时用 <code>map</code> 统计，复杂度应乘上 $\operatorname{O}(\log q)$。所以，总复杂度为：$\operatorname{O}((n\alpha(n)\sqrt n+\sqrt m(q\alpha(q)))\log q)$ 。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; e[N],qs;</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; ans,lst;</span><br><span class="line"><span class="keyword">int</span> f[N],sz[N],qto[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]==i?i:f[i]=find(f[i]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u=find(u);v=find(v);</span><br><span class="line">    <span class="keyword">if</span>(u!=v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sz[u]&gt;sz[v]) &#123;</span><br><span class="line">            f[v]=u;</span><br><span class="line">            sz[u]+=sz[v];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[u]=v;</span><br><span class="line">            sz[v]+=sz[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bao1</span><span class="params">(<span class="keyword">int</span> co)</span> </span>&#123;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) f[i]=i,sz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=e[co].begin();ii!=e[co].end();++ii) &#123;</span><br><span class="line">        merge(ii-&gt;first,ii-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=qs.begin();ii!=qs.end();++ii) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=ii-&gt;first,v=ii-&gt;second;</span><br><span class="line">        u=find(u),v=find(v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) &#123;</span><br><span class="line">            ++ans[make_pair(ii-&gt;first,ii-&gt;second)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bao2</span><span class="params">(<span class="keyword">int</span> co)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ps[N],tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=e[co].begin();ii!=e[co].end();++ii) &#123;</span><br><span class="line">        ps[++tot]=ii-&gt;first;</span><br><span class="line">        ps[++tot]=ii-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ps+<span class="number">1</span>,ps+tot+<span class="number">1</span>);</span><br><span class="line">    tot=unique(ps+<span class="number">1</span>,ps+tot+<span class="number">1</span>)-ps<span class="number">-1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,tot) f[ps[i]]=ps[i],sz[ps[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator ii=e[co].begin();ii!=e[co].end();++ii) &#123;</span><br><span class="line">        merge(ii-&gt;first,ii-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,tot) &#123;</span><br><span class="line">        rep(j,i+<span class="number">1</span>,tot) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> u=find(ps[i]),v=find(ps[j]);</span><br><span class="line">            <span class="keyword">if</span>(u==v) flg=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(flg&amp;&amp;ans.count(make_pair(ps[i],ps[j]))) &#123;</span><br><span class="line">                ans[make_pair(ps[i],ps[j])]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;c);</span><br><span class="line">        num[c]++;e[c].push_back(make_pair(min(u,v),max(u,v)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,q) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(!ans.count(make_pair(min(u,v),max(u,v)))) &#123;</span><br><span class="line">            qs.push_back(make_pair(min(u,v),max(u,v)));</span><br><span class="line">            ++now;</span><br><span class="line">            lst[make_pair(min(u,v),max(u,v))]=now;</span><br><span class="line">            qto[i]=now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> qto[i]=lst[make_pair(min(u,v),max(u,v))];</span><br><span class="line">        ans[make_pair(min(u,v),max(u,v))]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&gt;=<span class="built_in">sqrt</span>(m)) &#123;</span><br><span class="line">                bao1(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> bao2(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,q) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=qs[qto[i]<span class="number">-1</span>].first,v=qs[qto[i]<span class="number">-1</span>].second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[make_pair(u,v)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年 7 月水题选做</title>
    <url>/2020/07/7%E6%9C%88%E6%B0%B4%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<h1 id="7-20"><a href="#7-20" class="headerlink" title="7/20"></a>7/20</h1><p>这个东西是为了膜 <a href="https://registergen.github.io" target="_blank" rel="noopener">RegisterGen神仙</a> 而发出来的。</p>
<a id="more"></a>
<p><a href="https://www.luogu.com.cn/problem/CF506D" target="_blank" rel="noopener">$\color{green}{\text{CF506D}}$</a></p>
<p>神仙题。</p>
<p>暴力+暴力=AC。</p>
<p>没错，先想出两个暴力，然后拼起来，你就 AC 了这道题。</p>
<p>详细见<a href="/2020/07/题解-CF506D-Mr-Kitayuta-s-Colorful-Graph">我的题解</a>。</p>
<h1 id="7-21"><a href="#7-21" class="headerlink" title="7/21"></a>7/21</h1><p>今天打了场 div2 的 CF 。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1382A" target="_blank" rel="noopener">$\color{green}{\text{CF1382A}}$</a></p>
<p>sb 题。找一下两个数组有没有相同的数，完事。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1382B" target="_blank" rel="noopener">$\color{green}{\text{CF1382B}}$</a></p>
<p>仔细想想，发现所有 $\ge 2$ 的数都可以换成 $2$ 。</p>
<p>再想想，对于一个 $2$ ，先取到它的人可以调整先后手顺序。</p>
<p>那么，拿到第一个 $2$ 的人就可以调整顺序，使得他拿到第二个 $2$ ，以此类推。</p>
<p>这样，拿到第一个 $2$ 的人就把调整顺序的主动权牢牢控制在了他手中。所以拿到第一个 $2$ 的人有必胜策略。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1381A1" target="_blank" rel="noopener">$\color{green}{\text{CF1382C1}}$</a> 和 <a href="https://www.luogu.com.cn/problem/CF1381A2" target="_blank" rel="noopener">$\color{green}{\text{CF1382C2}}$</a></p>
<p>这题没让我们最小化操作次数啥的，只用求出一个可行解就完事了。</p>
<p>那么我们就可以随便乱搞了。</p>
<p>想想有什么状态是这两个 $01$ 串都能达到的？而且很好写的？</p>
<p>当然是 $111\cdots1$ 啦！</p>
<p>那么我们就可以处理一下第一个串到 $111\cdots1$ 的操作、第二个串到 $111\cdots1$ 的操作，然后拼起来，完事。</p>
<p>处理这个操作怎么 $\operatorname{O}(n)$ 呢？</p>
<p>我们可以预处理这两个串的极大全 $0$ 子串，然后随便做就完事了。</p>
<h1 id="7-22"><a href="#7-22" class="headerlink" title="7/22"></a>7/22</h1><p>全天有课且无 CF ，咕咕。</p>
<h1 id="7-23"><a href="#7-23" class="headerlink" title="7/23"></a>7/23</h1><p>全天有课且无 CF ，咕咕。</p>
<h1 id="7-24"><a href="#7-24" class="headerlink" title="7/24"></a>7/24</h1><p><a href="https://www.luogu.com.cn/problem/P4768" target="_blank" rel="noopener">$\color{green}{\text{P4768}}$</a></p>
<p>终于 A 了归程！</p>
<p>若不强制在线，可以将询问按海拔排序用并查集处理。</p>
<p>强制在线就用可持久化并查集就完事了。</p>
<p>另外：关于 SPFA ，它死了。</p>
<h1 id="7-25"><a href="#7-25" class="headerlink" title="7/25"></a>7/25</h1><p>晚上有事，白天有课，咕咕。</p>
<h1 id="7-26"><a href="#7-26" class="headerlink" title="7/26"></a>7/26</h1><p>咕咕咕咕咕！</p>
<h1 id="7-27"><a href="#7-27" class="headerlink" title="7/27"></a>7/27</h1><p>晚上是学校集训的摸底赛，除了最后一题都很水。。</p>
<p>但是乐多赛这玩意真恶心。。</p>
<p>放一张榜：</p>
<p><img src="https://i.loli.net/2020/07/27/zoS6tyEfwCAlMBq.jpg" alt=""></p>
<p>orz 绵羊，rG %%%</p>
<h1 id="7-28"><a href="#7-28" class="headerlink" title="7/28"></a>7/28</h1><p><a href="https://www.luogu.com.cn/problem/CF547D" target="_blank" rel="noopener">$\color{green}{\text{CF547D}}$</a></p>
<p>一个很难想但是想出来了就很好写的题。</p>
<p>对于每个点，将它的 $x$ 坐标与 $y$ 坐标连边，然后跑一遍欧拉回路。</p>
<p>完事。</p>
<h1 id="7-29"><a href="#7-29" class="headerlink" title="7/29"></a>7/29</h1><p>咕咕咕咕咕</p>
<p>话说我咕的天数比 xcs 神仙多多了。</p>
<h1 id="7-30"><a href="#7-30" class="headerlink" title="7/30"></a>7/30</h1><p><a href="https://www.luogu.com.cn/problem/P5829" target="_blank" rel="noopener">$\color{green}{\text{P5829}}$</a></p>
<p>KMP 自动机的模板。</p>
<p>在 KMP 自动机上找两个前缀的 $\operatorname{LCA}$ 就好了。</p>
<h1 id="7-31"><a href="#7-31" class="headerlink" title="7/31"></a>7/31</h1><p><a href="https://www.luogu.com.cn/problem/P2503" target="_blank" rel="noopener">$\color{green}{\text{P2503}}$</a></p>
<p>《random_shuffle 在 OI 中的应用》</p>
<p><code>random_shuffle</code> 若干次，每次都贪心求一下答案然后取个 $\min$ ，就切了这道题。</p>
<p><a href="https://www.luogu.com.cn/problem/CF896E" target="_blank" rel="noopener">$\color{green}{\text{CF896E}}$</a></p>
<p>循环展开+玄学卡常的暴力艹过去了哈哈哈哈哈哈</p>
<h2 id="另外昨天打了一场-CF-Div2"><a href="#另外昨天打了一场-CF-Div2" class="headerlink" title="另外昨天打了一场 CF Div2"></a>另外昨天打了一场 CF Div2</h2><p>这场 D 题比较水，于是我先去做 D 。眼疾手快切掉了之后发现自己变成了 rk15 。。。</p>
<p>但是 C 题一直没有调出来。。。就眼睁睁看着自己名次掉啊掉挺难受的。。</p>
<p>最终结果，可以看见我的 C 题多么惨烈：</p>
<p><img src="https://i.loli.net/2020/08/01/SebJfLdps6wi1Tl.png" alt="CF.png"></p>
<p><a href="https://codeforces.com/contest/1388/problem/A" target="_blank" rel="noopener">$\color{green}{\text{CF1388A}}$</a></p>
<p>sb 结论题。大部分情况输出 <code>n-6-10-14</code> 就完事。</p>
<p>小部分无解、重复数字的情况讨论一下。</p>
<p><a href="https://codeforces.com/contest/1388/problem/B" target="_blank" rel="noopener">$\color{green}{\text{CF1388B}}$</a></p>
<p>也是道很好推的结论题。</p>
<p>可以发现让位数越大越好，那么每个数位就只能取 $8$ 和 $9$ 。</p>
<p>又因为他后头会擦掉一些位数，那么就把被擦掉的位数填上 $8$ ，剩下的填 $9$ 就能在最大化答案的同时最小化那个数。</p>
<p><a href="https://codeforces.com/contest/1388/problem/C" target="_blank" rel="noopener">$\color{red}{\text{CF1388C}}$</a></p>
<p>难受啊，考试的时候一直 <code>WA on pretest 3</code> 。没调出来。</p>
<p>思路就是先统计一下经过某个点的人流量，然后配合 $h$ 值求出到每个点的时候有好心情的人。</p>
<p>然后我就 <code>WA</code> 得很惨。。。但是思路是对的，就是小细节问题。</p>
<p><a href="https://codeforces.com/contest/1388/problem/D" target="_blank" rel="noopener">$\color{green}{\text{CF1388D}}$</a></p>
<p>当时写完 A 和 B 之后我直接去做 D 题了，因为我一眼看出了做法。</p>
<p>把 $b$ 数组看做下标之间的连边（$i$ 连向 $b_i$），那么这个 $a$ 数组之间就连成了一个 DAG 。</p>
<p>拓扑排序一下，如果当前的权值 $&gt;0$ 就把当前权值累加进下一个，然后按顺序丢进输出的序列。否则就不加，然后从末尾倒序丢进序列。</p>
<p>最后输出就按顺序输出那个序列就完事了。</p>
<p>当时我切掉 D 题是第 $37$ 分钟，全场 rk15 。</p>
<p>（截图只截到了 rk16 的时候）</p>
<p><img src="https://i.loli.net/2020/08/01/BPl7WT8QeSvuJoY.png" alt=""></p>
<p>后来嘛，就一直掉啊掉，C 题爆炸导致我一直掉到了 rk859 。</p>
<p>不过还是上分了的， <code>rating+=94</code> 。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>luogu</tag>
        <tag>题解</tag>
        <tag>水题选做</tag>
      </tags>
  </entry>
  <entry>
    <title>ZR2020春季NOIP模拟赛day4总结</title>
    <url>/2020/03/ZR2020%E6%98%A5%E5%AD%A3NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9Bday4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="d7a31644024f4ddd7e2eaf637168e89ce917fbfa923a1e5aa815459af2dd9370">a3e4f48b81db38135a5ff9adeee672dc202c767c025bac6bbf465deff10e4a8711aba74008397e266eef2d9b9ad75dffc952d6a6ee1fd944640ed39c6b4a68a1ffda5062de1fc206cd29cd43cf4dfd6b6e3ee40877de9ae01ff67da8df5b4824d82748e780c8fddec3a122f2762102b81e87c81ca924e1cb6b108f592e9699bc4122943dbc65a40f23c32bbd03589041ad739988590fd12859ff59d005d0cbc9f3b221b50818ba123dc671a33d525195dd895e753415fbebd3142e7fc538f9da0d34311041bef5e43b86af0bd02f0f61b7d0418d3cefbd745766a0ebf3f16ae153a4cf059f2cacb713332fb816288c30056a9b9328b5c956207e9a2ebd3399b9b6dab0408d56134fe53a683c2c2eed92421b7fd122b5130544ec4287ed361adf9060f90da227dc29bc5f8146e04d2613fb4a2c05e8134f25740a69ae8d085e9811827da3d57f56707bd7cbecd17e642e7515950cbbe02a42a013c4ba2c2c41fd99e8f9e31fcaa711c2008875c5d4eaf86c53838533fe89940d82532b64f4ddf772e6cfc516e217006f5602f53372b8cbd053558eb2a2438dbf41229acda4f786f40cfb2d4f8efd3ced4fa4be7351765db085a4851d8332d676b4ce2fe7f0da9ee39b3e030a34207745ce2e671496095bc1a5f45d016abf82ebf86dcc5efc98034a4d7f595d9f02c5e9b50f9390befa34bde926a5da188eeed4fbea6f6681de16a3bcaf4a4d5a7577d59021e834ae8d2edd7d63dddeca164cb7d8b1d713bde58f85761542ebb67bc59d50c75aeb4dd6eaeda109e1b572c2e4c8ce5f19e6c4afa16055e6bfae6bd3820252ee82759ca27c9e81d8ebc47e26af506bf81970c0f84e2c42e04dbca48ebc440c3e0018e0b645a5e4baa9ea35f6db14f7c17d1e853c67e3b2b535e638a397cbaf88b60ea7491a514a719c4ce2c657bba17318b8032c4436202b0dff199e227ecbc262937a4b263e6476c314fc3d90ab5ddd102a70085bad6dd2f5b7708e3811735843db8f101486c5440e695886f721a6537aa859fbebd81c948dc96d4736b858f1c58c984617a215a40e35c1a7a04d7813cb262d2684b1bae2c90de8b93e6a613e2a18c3eac871eb5e4fadea7a5429130513cf6d040d70f7e827515f1530211cfdea596418bec1312091b368e9855696fa7f727dc098f94128979a42a5ffe6d9550eb0845412b3ce688b68654c2f3f5a0981af6524f02bb4e305a96065fe45f3b4cff493a0d4000a2e6297bd776889bcdd40ea4c433edc841319f32fd4f65338af9b1674ee1aa5cd6cb9fa2415ed638d1f16d30507895f209685d455dff24a71f25e4db51cf0f3b73505329cff27b79262825183e5dc6552fbce43d78caeee91f4ff8c450da190028c4aeccc7e6671924fa27f3b0d8edf557958c95a647f3d72b118c2a5c896e420573fe584e695f1c8ac93cc17724b2aa86e5cda98fd0360c0549e43b58abac21318e48f04c28563acc27349dcdb5ce89a3dc873569ff4074e168f05f27465b8d17429840893f0f23b001ffff6a8160cba2dd875ce1f79e7a8819db6606cde337f7e041b353851131ea9949f31c74851d5d224f414c27fc9fc6c4a6db3b29477c36e7d83b6d89d65070f7fd6259ac114a26a6c003aefec35282283ff86d8d0b761a06e8182a7df12f43ec6fee2164b4a722766d0212ea02292f7b749882c9fd81292c29589fbbc53aebf11556c53fd1303348577112a9e5d4709ddc6031a393c8e684a2d656c2c24f190e9d41d25fcb46d5a9322fcba2a845bba19e5283331b5ff1780aee0e109db1bf76e34ef5531ea863a0438b2dd3ced10a737de351abc3e650f01b0745e7a029b6d5d33f431cc</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LuoguP1600 [NOIP2016]天天爱跑步</title>
    <url>/2020/03/%E9%A2%98%E8%A7%A3-LuoguP1600-NOIP2016-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1600" target="_blank" rel="noopener">题目传送门</a></p>
<h1 id="前置知识：树上差分"><a href="#前置知识：树上差分" class="headerlink" title="前置知识：树上差分"></a>前置知识：树上差分</h1><p>各位大佬们肯定知道在数组上差分是什么吧：差分数组中的值是原数组中这个位置与它左边（或右边，写法无所谓）位置的差。这个方法可以把“区间加”转化为“左端点加，右端点减”。</p>
<a id="more"></a>
<p>然后对于一个位置，它的值就是差分数组中的前缀和。</p>
<p>例如：一个数组 $[1,0,2,5,3]$。</p>
<p>它的差分数组就是 $[1,-1,2,3,-2]$ 。</p>
<p>在区间 $[2,4]$ 上 $+1$ ，就等价于在差分数组中下标为 $2$ 的地方 $+1$ ，下标为 $5$ 的地方 $-1$ 。差分数组变为 $[1,0,2,3,-3]$。</p>
<p>此时求原数组下标为 $4$ 的地方就是求差分数组的下标范围 $[1,4]$ 的和，为 $6$ 。</p>
<p>类似地，我们可以把差分这个算法转化到树上。</p>
<p>设差分数组为 $b$ ，对于树上的一个路径加 $1$ ，例如 $u\to v$ 这条路径上面所有点的权值 $+1$ ，我们可以把它转化成 $b[u]$ 加 $1$ ，$b[v]$ 加 $1$ ，$b[\operatorname{lca}(u,v)]$ 减 $1$ ， $b[fa[\operatorname{lca}(u,v)]]$ 减 $1$ 。最后对于一个点上的权值，我们求这个点的差分数组的子树和就可以了。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>《算法竞赛进阶指南》大法好！</p>
<p>首先对于每个玩家的跑步路线，我们把它拆成两段： $S_i\to \operatorname{lca}(S_i,T_i)$ 和 $\operatorname{lca}(S_i,T_i)\to T_i$（不包括 $\operatorname{lca}(S_i,T_i)$ ）。</p>
<p>然后分开考虑：</p>
<ol>
<li>若一个观察员 $x$ 处在 $S_i$ 到 $\operatorname{lca}(S_i,T_i)$ 的路径上，当且仅当 $deep[S_i]-deep[x]=w[x]$ 时，这个观察员可以观察到这个玩家 $i$ 。其中 $deep$ 数组表示节点的深度。</li>
<li>若一个观察员 $x$ 处在 $\operatorname{lca}(S_i,T_i)$ 到 $T_i$ 的路径上，当且仅当 $deep[S_i]+deep[x]-2\times deep[\operatorname{lca}(S_i,T_i)]=w[x]$ 时，这个观察员可以观察到这个玩家 $i$ 。</li>
</ol>
<p>对于情况一，把关于 $x$ 的项都移到等式右边，得到 $deep[S_i]=deep[x]+w[x]$ 时，这个玩家可以被位于点 $x$ 的观察员观察到。</p>
<p>那么这种情况就转化为：每一个玩家在 $S_i$ 到 $\operatorname{lca}(S_i,T_i)$ 的路径上放一个类型为 $deep[S_i]$ 的物品。最后求任意 $x$ 处的类型为 $deep[x]+w[x]$ 的物品有多少个。</p>
<p>看到这里，就知道可以用树上差分了！</p>
<p>“路径 $u\to v$ 上放类型为 $k$ 的物品”可以转化为：在 $u$ 处产生一个物品 $k$ ， $v$ 处也产生一个物品 $k$ ，在 $fa[\operatorname{lca}(u,v)]$ 处减去两个物品 $k$ 。然后对于一个点上拥有的物品，我们求这个点的子树中所有的物品即可。</p>
<p>情况二类似，请读者自行推导（<del>或者看《算法竞赛进阶指南》中的结果，只要你有</del>）。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> grep(u) for(int ptr=last[u];ptr;ptr=pre[ptr])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">5</span>,LOGMAX=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s[N],t[N],w[N];</span><br><span class="line"><span class="keyword">int</span> target[<span class="number">2</span>*N],pre[<span class="number">2</span>*N],last[N],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deep[N],bel[N][LOGMAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    deep[u]=deep[fa]+<span class="number">1</span>;</span><br><span class="line">    bel[u][<span class="number">0</span>]=fa;</span><br><span class="line">    rep(i,<span class="number">1</span>,LOGMAX<span class="number">-1</span>) &#123;</span><br><span class="line">        bel[u][i]=bel[bel[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    grep(u) <span class="keyword">if</span>(target[ptr]!=fa) dfs(target[ptr],u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bok1[N],bok2[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[u]&lt;deep[v]) swap(u,v);</span><br><span class="line">    per(i,LOGMAX<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(deep[bel[u][i]]&gt;=deep[v]) u=bel[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line">    per(i,LOGMAX<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(bel[u][i]!=bel[v][i]) u=bel[u][i],v=bel[v][i];</span><br><span class="line">    <span class="keyword">return</span> bel[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c[N*<span class="number">2</span>],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=c[w[u]+deep[u]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok1[u].begin();ii!=bok1[u].end();++ii) ++c[*ii];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok2[u].begin();ii!=bok2[u].end();++ii) --c[*ii];</span><br><span class="line">    grep(u) <span class="keyword">if</span>(target[ptr]!=fa) dfs1(target[ptr],u);</span><br><span class="line">    <span class="keyword">int</span> ans=c[w[u]+deep[u]]-now;</span><br><span class="line">    sum[u]+=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=c[w[u]-deep[u]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok1[u].begin();ii!=bok1[u].end();++ii) ++c[*ii];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ii=bok2[u].begin();ii!=bok2[u].end();++ii) --c[*ii];</span><br><span class="line">    grep(u) <span class="keyword">if</span>(target[ptr]!=fa) dfs2(target[ptr],u);</span><br><span class="line">    <span class="keyword">int</span> ans=c[w[u]-deep[u]]-now;</span><br><span class="line">    sum[u]+=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s[i],&amp;t[i]);</span><br><span class="line">        <span class="keyword">int</span> lca=query(s[i],t[i]);</span><br><span class="line">        bok1[s[i]].push_back(deep[s[i]]);</span><br><span class="line">        bok2[bel[lca][<span class="number">0</span>]].push_back(deep[s[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    rep(i,<span class="number">1</span>,n) bok1[i].clear(),bok2[i].clear();</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> lca=query(s[i],t[i]);</span><br><span class="line">        bok1[t[i]].push_back(deep[s[i]]<span class="number">-2</span>*deep[lca]);</span><br><span class="line">        bok2[lca].push_back(deep[s[i]]<span class="number">-2</span>*deep[lca]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%d "</span>,sum[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ZR2020春季NOIP模拟赛day3总结</title>
    <url>/2020/03/ZR2020%E6%98%A5%E5%AD%A3NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9Bday3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="e5b14ec0593ce6bf9d29b30fcdfcc6272d5a816f3b582fc39447d2ec9bef2243">2610e6f9332f0e99dc1d9430e23048d6cf0ef08c8ac1e07d3300ae0f9e4dc84914bb775af9d74637b7ea2d72de7c0093e2d8fc336dfd2107a359a9d1633b3309492529a2fbba8e671ae28303f0c36f92ca6a83f9923a00816c057fe1b0fffb40127d0d0c09b2cbec5b933908e4c20840c94faf172bdef113d421d29633cb0e3ff427ddb92b41095869bd43c077622e7302968bc7a0e23a762c0a238b59c9000b49e47699b55cbc4d102d4c8c0d590dcea52cf35681205b87dddff65f412efe65b4d9fcd3db54231be0a986ea67b3d29ae39aaf05bac7a2d9849f246953404e60474516143ad0f851b12a58eff36ea7c399022e3113dd2a075aae99c686f8896d4b0ee93c1c0a245d9385e81a5a69dd459caacea6cd8e800c8abe47bbf98f822269a0b5e55aa88b2c2623cb695c161c31be360aed4041357ba8de0f8afe729d4a942869c517f1be2f91b291a60f17c96730bc7ce8a806de55916b85011aa3cdc638cb7643971bcdeb1ef4d6114d057fe33494c5516d20c406d97a357fe6b7dd8854e0bbfe7133e165f4b04d8e28a6bd4bd7c4776cd1443e641e4cf35c8a510571c8c8f5df82678cf240f9079babbd066b4c938a91d0720fe6ae18e5185e5ac2f6dba38d73dbb823f74391a729aacec44a409dd9593d35a80cd81aaf613e854527488b0e56a1954e81897e9a16e69fc43d23af136f8f0619d66447bd3bebd0aa92291ba1a2dc56d0b2f24987a0431204f794a7562462562ba87302936ea32f7199fb16e06f03d73928884dff30d3486ada416c1bbf5f0ebe00c673d75541628273d9f28cba1b11c16128e00016a862acc594d01e0c7f9887e5806db962f1904b23d7b6e6a2a13bf99f850f3e4ced77e04da39aea04e995f2f2c704ccde88fb3d6b79b21e7845a11f66314ac651efcb3f33dcf20b0e746dc0565d65edd735d59177ec3d714e89ea9fe5a6571f26f227f83c04d6f6389ca26fd7b4a941d931cab19f78bb15904f4dd3b0b6757f6147b430b7bf1377c4932f80bc6ceec6c2fbf4ff86976ddba00929eae299be2da4649ed11592d278ae4896736b57410e0beb7669b0bcea04695177ced666b4ead1e42f9e7dfa0c101506192274b2237d0ab87034f0a537037892b64811cce8b4fac2ebed6b846f3db160601b229d4803998e3b8e1ef715a261dd0994b63d421b6f3131e2949f05c4d8f4b3674f5881c70f0df4db035a9c731fb966a53dc293518df8cbe985b6e19dbbb24fc839b90865fa6429dcc9256399b086cb00e0ef99dd107d9998f8d012ea77425d8d02c2efd7aedcbba8951e907f740646a02139ea374181c077b515e321606d0fde1680bfe59b7f186bd86abebce28787cb04a4eee26f6a2cea59a9beea6770d7181031eb7f8b4b77341bf9819193232ea8a629904f577b7ab0ddb2d4264218e2cbc64d97bbd8556865c2652a763f0693f75b35f708e6af5517b785b25d22ef138c644122d458b40f37bee01292101412ed49bcf1a2acda7454a8425c7073bc85764daf27e7a6b75a8b95788938f9fcc9a51b19f0c16b4416f4a429a45d903f40b81ddd9bb7a78f2ab5b6fe9478eb7a372a3b9f201c887dfe015928c589cbb1b9742cc8a6e49c1362704911ac1c35e1474e4fb22ec5352f3dfd3df21087cc1bbe5d9cf7cd7212334ac73554821c5d68fa1d9850bc1304f4868a153c31ec008cde6ec22c5d9865a6078817465e311a38c049b0fb15c961b8fd3f2806dee1e3ea4ca4e31430f48657e9cd67f727956d798f45e0461e80b1d8df2798f7829c721dff28f6469c1e38e59077096ce3c5b9a65453be068d9f25f86332fa96bef06c87a53d854263a9e396c92fd2e10f90338c1d9dfbc6d3586f947092f7f6a6d5e759554f85f68fee13f1f74505c9fbedeaef4638ceea3399cc73d5a58815f35eb905593dd6a98f15788bc0ea6f27e6d97316e74f0d17c8966e14dc81fae581fe6eb2207c9fb9168f3d2fcc8d0d61f3296a98898a89b58eb26e684cb4c5de69ed91bb36f4654bff00166929b6951ad1b96d16376aba5ea13e8c3b80017cfb611b5495d45fb7842c4f82eee24c5ac3ff4ec7ae20ca198020be2abb04a8cf48ba00ab407818215d90a64911d03058670f68ba6e2100ba62f797a9bfbf90275dc39205ba1eb8b5252427e16ff8e39fcbb803e1b7e14d9103150c5bdfbb8702c35c6313ef23b691e445f27755782173</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LuoguP2602 [ZJOI2010]数字计数</title>
    <url>/2020/03/%E9%A2%98%E8%A7%A3-LuoguP2602-ZJOI2010-%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2602" target="_blank" rel="noopener">题目传送门</a></p>
<p>题意：给定两个正整数 $a$ 和 $b$ ，求在 $[a,b]$ 中的所有整数中，每个数码各出现了多少次。</p>
<p>数据范围：$a\le b\le 10^{12}$</p>
<p>首先，这道题显然是数位 DP 的套路题（统计某个区间内满足某个性质的数有多少之类的题基本都是数位DP）。</p>
<a id="more"></a>
<p>设状态 $f[i][sum]$ 表示已经考虑到了前 $i$ 位，目前的某个数码 $d$ 的个数为 $sum$ 。</p>
<p>我们可以转移：$f[i][sum]=\sum f[i-1][sum-(now==d)]$ ，其中 $now$ 表示考虑的第 $i$ 位上的数码。</p>
<p>采用记忆化搜索进行转移处理数位 DP 是很方便的，具体实现见代码（有注释）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">15</span>][<span class="number">15</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,num[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> sum,<span class="keyword">int</span> d,<span class="keyword">bool</span> lim,<span class="keyword">bool</span> zer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    x表示当前到了第几位，sum表示当前答案，d表示需要处理个数的数码，</span></span><br><span class="line"><span class="comment">    lim表示是否在上界，zer表示是否为前导0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="comment">//递归到终点了，返回答案</span></span><br><span class="line">    <span class="keyword">if</span>(~f[x][sum][lim][zer]) <span class="keyword">return</span> f[x][sum][lim][zer];</span><br><span class="line">    <span class="comment">//给f数组加入了lim和zer两个0/1量来保证返回的数据是符合当前条件的。</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,lim?num[x]:<span class="number">9</span>) &#123;</span><br><span class="line">        <span class="comment">//这里判断lim是为了处理在上界时只能for到b的那一位的情况。</span></span><br><span class="line">        <span class="keyword">if</span>(zer&amp;&amp;i==<span class="number">0</span>) ans+=dp(x<span class="number">-1</span>,sum,d,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//前导的0不计入答案。</span></span><br><span class="line">        <span class="keyword">else</span> ans+=dp(x<span class="number">-1</span>,sum+(i==d),d,lim&amp;&amp;(i==num[x]),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][sum][lim][zer]=ans; <span class="comment">//赋值用于记忆化。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) num[++tot]=x%<span class="number">10</span>,x/=<span class="number">10</span>; <span class="comment">//拆位。</span></span><br><span class="line">    <span class="keyword">return</span> dp(tot,<span class="number">0</span>,d,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%llu%llu"</span>,&amp;a,&amp;b);</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">9</span>) <span class="built_in">printf</span>(<span class="string">"%llu "</span>,sol(i,b)-sol(i,a<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ZR2020春季NOIP模拟赛day2总结</title>
    <url>/2020/03/ZR2020%E6%98%A5%E5%AD%A3NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9Bday2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这篇文章需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="550a87a364f54e8712b34a1bc719961c82941bd31384839b1a5f20753a92a06e">fc64cbd0556ec1bf561d9ef649835821ef2e62a9e0abb9292ff81767627d374e5d09c68ea842cc6d931e510ca79fd058df85115dcb8a64175493c45adaeb56ef51462976fc1850a9c5f5d33ad4c0cdc1c2c2d9158965281e9aec01905254cdcfc5c7a6a5409458e369630e3696222b25c6461ff5b804babd3f15968222c414b35d840b6734cd4034b0d60e03436c7c875ac150c48bc8bf2ff670c7674a2d668665adbf0ebf28eae3fa72d548298c70b893a1f7dd938faf0d084b9f6e6415c09771c7d684b20cdf6c3e70f9fef0431f5fe3cf9e48c57a1caf93ea1c8eae86f7ba9f97ce5a01331a58ace09675237d795e640959e01b6bf5601a5e05cd8e3971c9661895cfd40adcc14d3fc7c5cd353ddc92c7f452d45870d5920bc670074fa7d863581e9bc7008e98135f91b45892ad45aa62af6f3c9d31bd0b318cb42c69133835bf6d483f399fad4af89093a32f53753609c2c00519d7e83df9afcb81697e168e9f19dd37d3f71759a4e08286a04507fe310aee2c0c18e3fc6832240f31e0b04da32b67eb79ff26d589b40f7f780ce0c4f3586880bc56f4b5df8edbe4cb3b618b66a6480816c26cd2a324792e87f54be2dbfd6e377ef179c98175ae4ec39d415bdb408fd16040b10f0e7fb6361c17989d971d0ad9361926f71aaabb70c6c9a73792ebdf670e08b544aff740196a6e2aa558c60a45a3077aeb10fd6306e651e4a498c84b3951cc4855553e29fa02397905f54215d28c195bcbe63ab77be3bd3384701960b7fdeddea6ab50cf74a50bdd0d3f3a6f14a7c1a8d993441d43e6af6ff70935a98b363ff68f2d51764d72c2bc96924b4200bcf1f99cff812aa0595733d4e9b2f0687d28f2d8d8cdc986fd0f85a821cc7b3d0b9a6412e13773bf926036458579e2a995337d8a5542096e1081db6fe66a22af3c9cce8b358488a2e9658bd434514b2e310c19b7a8f4c86253617b040b6988e61845daf7dba87e950ed61f600cacee5c9c1e2819070e54f827672baffa31729309f195d4fafa88a372d5f5c5bbbd77efa498a7cb00642792cced7c8e2172fd47befec5aa260ee2d17663c1374e9930410ab8e73afe3e4be4a020e86e2a0e4e1641ff229b5c8a68fdefe5b487955c4e60dc5131d7829d76332ded246669683e76744d88f7f1c93121224aef4a6e53b31c6e93f017f269a15d0afbd24ccc7fcdadd55e75895f98df6194e1a5fb448ab76c01f86ac8a996651e4834e25303f34c2af5635ede5f00795e8d7440a62ace7409903cd44aaf7a2bf19c142bb8fdb676a35003a016af7376fae7094db8c20e8deda3d6d9d098c9f3d93e37ea547de865c98869a9464c311f1fedc66719469e6bd6e8f9298db2bc54c4c58a1ae5a4c96a67f4139b6bac4a26314594668238f3d2a0759d4d222b2e1dafa5c1fbaf784101af22e3a69b4383470f5bc11b08dc413776664a724982c6f7770014d50654b3a3b97c782287e314f57eceb85a9d91d2e9869fdb3ca7fc9161a31efb67f37fea6d9f5acd95e8cdbe680eea02537f51cb28411d0f101465d7c1166192631d8fd06e660528a4c5cb1cb21059827b34abe297bf577f6fb6a578998a269ba0afbbfcc6353008441ad82d774824391f8ab1d6fe780ac70ffefa540aa3d703b88b449fc15af0320d35f25b0eb39cb8ab3ba52b0dd8f6b98b1dab686b648e70f405aab7c34ecf3a8b3875834e4bb5cabd3f1d3c3ea4512f4772ce1b515008f4256d1b149e09c86956c5a396654e5f259c7024385d088377d1487ee2c0a3fd03cdeeb20c4d77284187eb54bb11df60a96191f28459503b92faeee26a114d37c7560f04f43c8cfd88971071c73154c2fdd2d01f49f36b3849b145eaa9b0ce9013ef6a4288709690282fded40e5c1e7f4d3959d517ea92032b079eac518d81043b1d0133951859a4927ebe9ca62abf3faa5df0922097ab2d159027a00f2efc005cf90512efe33e61e833298a41e2cb1c586d54609d4bdeb2377de20831ff71f7a46dfa19307eea2c3a0ab5c8a9806b09e9458ac5a176b404feaf7a57762ab9d9ed1e8253f89909d4c80caefc3e0123592637e866fd4e3d902fcf8982127983c9a3808121ec980a2e5f14a4bd8b020b07e46a52f6689759c0cb12659f6b80f438af5701954166044798e84e28d6f0d990d46a8ecfe7e17741f3b3345f0b495338e1d1276236bced4118fbb52d02fbdd46faae207161ac593e40a8a0c5434961fe71a91ae27e2c940a450b112fc1540186dd329bb13b907eba2f9d5296017b5669235b6393fd12f184f2b351575f331cab32f576d1f9fef617e4b36853660991419d75f447383c234b13a0d1ed13cfe844b45c1da241e5c1b76dedf7d26bed902e31ebf50f90f621e07595ede313d41b6b9bed8bbbfdff0f6f46daf7c53b2d5b52ab402512dc9e5bdd906ccd73103d6957109067064e77928f0339d93c1be532f313919e86ebb8e93dfd61943524ec7e89503dff3509be149eb4ab34acc0e2378a0b8c6c6da5fd6617de9fc5896a6864c906b20c5ee69bebafd6e8a425bac4384c983668e2b1ed1cc7c9af594a6c32e52ae06c10a78af37b399e74b2f67d71abaccf8b5a6937b5e7a42050a2dbc26cb385a44d811d609377ff8e7c32580d3027e83a8b5098fa7f9057fc96eaa9e9605f9dd887647b47915d53e7abc1f2d7bf31423fe7ac7278c3d201bc517313f30f31c669f1ffb071e25971a6bfbce1db547d5f2ac234a6e9042a3bd0e83db64fb0515d1745cc22a10d9105cf5c8093f8dae745116ac1e397b950c6bcd9038dda682487e92d53f70b572a084a2668ec89f60171a564</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LuoguP3469 [POI2008]BLO-Blockade</title>
    <url>/2020/02/%E9%A2%98%E8%A7%A3-LuoguP3469-POI2008-BLO-Blockade/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3469" target="_blank" rel="noopener">题目传送门</a></p>
<p>题意：有$n$个点、$m$条边的无向图，对任意$1\le i\le n$，求出将第$i$个点和与其关联的边删去时，有多少个有序点对$(u,v)$满足$u$和$v$不连通。</p>
<p>显然，这道题需要用到割点。</p>
<a id="more"></a>
<p>先考虑$i$不是割点的情况。因为$i$不是割点，所以把$i$和与其相关联的边去掉时，其他$n-1$个点依然是连通的。因此答案为$2(n-1)$。（注意题目中说的是<strong>有序点对</strong>）</p>
<p>然后来考虑$i$是割点的情况。</p>
<p>很显然，若$i$是割点，删去$i$和与其相关联的边后，原图会变成若干个连通块。那怎么求这些连通块的大小呢？</p>
<p>我们思考一下：tarjan算法是如何判定割点的？</p>
<p>答案是：在搜索树上，如果$i$不是根节点，则如果有任意$son_i$满足$dfn[i]\le low[son_i]$，$i$即为割点。当$dfn[i]\le low[son_i]$时，$son_i$除了往上走树边到达$i$以外不能到达$i$子树外的地方，也就是说删除$(i,son_i)$这条边后，图会分为$son_i$的子树与其它这两个部分。所以$i$就是割点。</p>
<p>所以这道题的答案就很显而易见了：对任意满足割点判定式$dfn[i]\le low[son_i]$的儿子$son_i$，在删去$i$和与其相关联的边后，$son_i$的子树会变成图中的一个单独的连通块。因此我们只需要在tarjan找割点的同时统计一下这些子树的大小加进答案里即可。</p>
<p>别忘了还有一个连通块是除了$i$子树以外的所有点。</p>
<p>Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,M=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> target[M],last[N],pre[M],tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],sz[N],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u]=<span class="number">1</span>;</span><br><span class="line">    dfn[u]=low[u]=++cnt;</span><br><span class="line">    <span class="keyword">int</span> flg=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> iscut=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=target[ptr];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            sz[u]+=tarjan(v);</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;=dfn[u]) &#123;</span><br><span class="line">                ++flg;</span><br><span class="line">                ans[u]+=sz[v]*(n-sz[v]);</span><br><span class="line">                sum+=sz[v];</span><br><span class="line">                <span class="keyword">if</span>(u!=<span class="number">1</span>||flg&gt;<span class="number">1</span>) iscut=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> low[u]=min(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iscut) ans[u]+=(sum+<span class="number">1</span>)*(n-sum<span class="number">-1</span>)+(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> ans[u]=<span class="number">2</span>*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> sz[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    tarjan(<span class="number">1</span>);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>题解UVa1220 Hali-Bula的晚会</title>
    <url>/2020/02/%E9%A2%98%E8%A7%A3UVa1220-Hali-Bula%E7%9A%84%E6%99%9A%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="刘汝佳大法好！"><a href="#刘汝佳大法好！" class="headerlink" title="刘汝佳大法好！"></a>刘汝佳大法好！</h1><p>是不是感觉看到这题很熟悉？好像很像<a href="https://www.luogu.com.cn/problem/P1352" target="_blank" rel="noopener">没有上司的舞会</a>这题诶！</p>
<p>可是我们发现，这里还新加了一个“判断唯一性”的任务。</p>
<a id="more"></a>
<p>我们定义：</p>
<p>$d(u,0)$表示不选$u$的$u$的子树的最大独立集的节点个数</p>
<p>$d(u,1)$表示选$u$的$u$的子树的最大独立集的节点个数</p>
<p>$f(u,0)$表示不选$u$的$u$的子树的最大独立集的唯一性（$0$不唯一，$1$唯一）</p>
<p>$f(u,1)$表示选$u$的$u$的子树的最大独立集的唯一性（$0$不唯一，$1$唯一）</p>
<p>则</p>
<script type="math/tex; mode=display">d(u,1)=1+\sum_{(u,v)\in E}d(v,0)</script><script type="math/tex; mode=display">d(u,0)=\sum_{(u,v)\in E}\max\{d(v,0),d(v,1)\}</script><p>以上两个就是求最大独立集的转移方程。</p>
<p>然后考虑怎么判断唯一性。</p>
<p>对于$f(u,1)$的情况：如果$u$的任意一个儿子$v$的$f(v,0)=0$，那么$f(u,1)$就等于$0$。</p>
<p>对于$f(u,0)$的情况：设$v$为$u$的任意一个儿子</p>
<ul>
<li>若$d(v,0)=d(v,1)$，则$f(u,0)=0$。</li>
<li>若$d(v,0)&gt;d(v,1)$且$f(v,0)=0$，则$f(u,0)=0$。</li>
<li>反之亦然。</li>
</ul>
<p>以下为代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot=<span class="number">0</span>,target[N],pre[N],last[N];</span><br><span class="line"><span class="keyword">int</span> d[N][<span class="number">2</span>],f[N][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot]=v;</span><br><span class="line">    pre[tot]=last[u];</span><br><span class="line">    last[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!last[u]) &#123;</span><br><span class="line">        d[u][<span class="number">0</span>]=<span class="number">0</span>;f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        d[u][<span class="number">1</span>]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][<span class="number">1</span>]=<span class="number">1</span>;f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    d[u][<span class="number">0</span>]=<span class="number">0</span>;d[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        dfs(target[ptr]);</span><br><span class="line">        <span class="keyword">if</span>(f[target[ptr]][<span class="number">0</span>]==<span class="number">0</span>) f[u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        d[u][<span class="number">1</span>]+=d[target[ptr]][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v=target[ptr];</span><br><span class="line">        <span class="keyword">if</span>(d[v][<span class="number">0</span>]==d[v][<span class="number">1</span>]) f[u][<span class="number">0</span>]=<span class="number">0</span>,d[u][<span class="number">0</span>]+=d[v][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[v][<span class="number">0</span>]&gt;d[v][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[v][<span class="number">0</span>])f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            d[u][<span class="number">0</span>]+=d[v][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[v][<span class="number">0</span>]&lt;d[v][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[v][<span class="number">1</span>])f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            d[u][<span class="number">0</span>]+=d[v][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">string</span> x,y;</span><br><span class="line">        mp.clear();</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        mp[x]=++cnt;</span><br><span class="line">        rep(i,<span class="number">1</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(!mp.count(x)) mp[x]=++cnt;</span><br><span class="line">            <span class="keyword">if</span>(!mp.count(y)) mp[y]=++cnt;</span><br><span class="line">            add(mp[y],mp[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">1</span>][<span class="number">0</span>]==d[<span class="number">1</span>][<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">"%d No\n"</span>,d[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[<span class="number">1</span>][<span class="number">0</span>]&gt;d[<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!f[<span class="number">1</span>][<span class="number">0</span>]) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[<span class="number">1</span>][<span class="number">0</span>]&lt;d[<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,d[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!f[<span class="number">1</span>][<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>题解UVa12186 工人的请愿书</title>
    <url>/2020/02/%E9%A2%98%E8%A7%A3UVa12186-%E5%B7%A5%E4%BA%BA%E7%9A%84%E8%AF%B7%E6%84%BF%E4%B9%A6/</url>
    <content><![CDATA[<h2 id="刘汝佳大法好！"><a href="#刘汝佳大法好！" class="headerlink" title="刘汝佳大法好！"></a>刘汝佳大法好！</h2><p>设$dp(u)$表示让$u$号员工给上级发信至少需要多少个工人。</p>
<p>那么假设$u$的子节点个数为$k$个，则至少需要$c=(kT-1)/100+1$个直接下属发信才可以让$u$号员工给上级发信（注意以上公式括号内的$-1$是为了防止$kT$为$100$的倍数而减一的）。</p>
<a id="more"></a>
<p>则我们更新$dp(u)$的方法是：将$u$的$k$个下属中$dp$值最小的$c$个做和，即可保证$dp(u)$是最小的。</p>
<p>最后答案就是$dp(0)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="keyword">int</span> target[N],pre[N],last[N],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    target[++tot] = v;</span><br><span class="line">    pre[tot] = last[u];</span><br><span class="line">    last[u] =  tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!last[u]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp[N],cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ptr=last[u];ptr;ptr=pre[ptr]) &#123;</span><br><span class="line">        tmp[++cnt]=dfs(target[ptr]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(tmp+<span class="number">1</span>,tmp+cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ned = (cnt*t<span class="number">-1</span>)/<span class="number">100</span>+<span class="number">1</span>,dp=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,ned) dp+=tmp[i]; <span class="comment">//取最小的c个dp值</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;t)&amp;&amp;n&amp;&amp;t) &#123;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            add(x+<span class="number">1</span>,i+<span class="number">1</span>); <span class="comment">//这里我把点的编号加一了，从0~n变成了1~n+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dfs(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-J/S 2019游记</title>
    <url>/2020/02/CSP-J-S-2019%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>日常肝作业+复习到12点.jpg</p>
<p>瞎背了背板子，在背匈牙利的时候被rui_er大佬喷了：</p>
<blockquote>
<p>rui_er: “匈牙利多简单~”</p>
</blockquote>
<p>dijkstra这么zz的算法都经常背错，我也是自闭了…</p>
<p>爆0预定</p>
<a id="more"></a>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>昨天没睡好.jpg</p>
<p>忍着眼皮子想要打架的欲望起了床。。。</p>
<p>开始一天的旅程</p>
<p>首先临阵擦枪，在车上背了背LCA板子，又复习了一下dijkstra <del>（尽管这两天都没用到）</del></p>
<p>迷迷糊糊走进了考场</p>
<h2 id="Senior-Day-1"><a href="#Senior-Day-1" class="headerlink" title="Senior Day 1"></a>Senior Day 1</h2><p>三样密码都没猜对</p>
<p>看T1</p>
<p>诶诶诶T1这不是道**题吗？</p>
<p>赶快A掉，看T2</p>
<p>我先花了半个多小时好不容易YY出了一条链情况的$O(n)$算法</p>
<p>又花了十几分钟打了一下。本来冲着100分去的，但是由于我太菜，代码能力有点弱，70跑路（100看脸，能被半链半菊花卡死）</p>
<p>T3是什么？能吃么？10分走人</p>
<p>回去检查T1T2</p>
<p>文件名都没问题</p>
<p>看看数据范围</p>
<p>诶诶诶T1我$n=63$怎么炸了？</p>
<p>赶快<code>unsigned long long</code>。。。</p>
<p>诶诶诶$n=64$怎么又炸了？</p>
<p>改成<code>(1&lt;&lt;(n-1))-1+(1&lt;&lt;(n-1))</code>。。。</p>
<p>总算好了，虚惊一场</p>
<p>20分差点没了</p>
<p>今年真**难</p>
<p>希望是Day1 Day2 难度互换了</p>
<p>估分：100+70+10=180</p>
<h2 id="Junior"><a href="#Junior" class="headerlink" title="Junior"></a>Junior</h2><p>普及没什么压力</p>
<p>T1：zz题，50秒AC</p>
<p>T2：暴力模拟即可，常数45，听说有人被大样例卡常了？！</p>
<p>T3：看起来是原题，可我还是不会。打了个部分分和假贪心，大概40分</p>
<p>T4：一眼题。打完发现大样例RE了。。。可只剩下十分钟不到了没时间调试了，40分跑路</p>
<p>总结：今天T4太可惜了，丢了60分。。。</p>
<p>T3完全背包没看出来.jpg</p>
<p>我连每天全卖光都想到了，然后呢，就去想假贪心了。。。</p>
<p>估分100+100+40+40=280，可惜没上300</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>昨晚肝作业++</p>
<h2 id="Senior-Day-2"><a href="#Senior-Day-2" class="headerlink" title="Senior Day 2"></a>Senior Day 2</h2><p>密码还是没猜对</p>
<p>打开题目，一惊：凉了！</p>
<p>原来Day1 Day2难度并没有互换。。。</p>
<p>T1第一眼不会，T2第一眼不会</p>
<p>跑去打T1部分分。</p>
<p>匆匆忙忙打了个12分的$m=2,a_{i,j}&lt;2$的部分分走了</p>
<p>T2呢？暴力+假贪心12+rand()分跑路。</p>
<p>过去看T3</p>
<p>我*！T3好像部分分很足的样子！</p>
<p>一言不合就40分暴力，$O(m)$枚举删边，$O(n)$找重心。</p>
<p>再来个15分的一条链，获得55分。</p>
<p>估分12+12+55=79</p>
<p>于是TG总估分就出来了。100+70+10+12+12+55=259。</p>
<p>事实证明，之前背的板子都没用上。。。</p>
<h1 id="Day-4（2019-11-19）"><a href="#Day-4（2019-11-19）" class="headerlink" title="Day 4（2019.11.19）"></a>Day 4（2019.11.19）</h1><p>于是BJ的选手代码出来了。</p>
<p>跑洛谷上去测民间数据，100+70+10+8+12+55=255。D2T1好像挂了？</p>
<p>跑icode上去查估分，95+70+10+4+0+55=234。额更玄学了，T1我明明好好检查了呀？D2T1和T2可能真的挂了。。。</p>
<p>然而这样icode估分好像还是我们弱校rk1？不可能吧.jpg</p>
<p>深深感到自己的渺小</p>
<h1 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h1><p>于是发分了</p>
<p>PJ炸了，100+100+30+35=265。不过一等还在。</p>
<p><del>PJ不上300还比TG考的低太没面子了</del></p>
<p>TG D1T2数据水，70-&gt;100，但D2T1果然挂了，0分。</p>
<p>于是TG 100+100+10+0+12+55=277拿了个省一qwq</p>
<p><del>看来以后不要相信icode</del></p>
<p><del>以下是吐槽：</del></p>
<p><del>一个奖状要100！CCF NB！</del></p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>赛后总结</tag>
        <tag>游记</tag>
      </tags>
  </entry>
</search>
